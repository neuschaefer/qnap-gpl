
apcupsd now is using threads (processes) and IPC shared memory for all its operations.
Every thread is timed by alarm() and SIGALRM.
There is one chunk of shared memory that is an UPSINFO structure and this is
the way all threads communicate one to the other.
The area must be locked before modifying it and can be unlocked only at the
end of an handler.
The area can be leaved unlocked only if the routine involved don't want to
modify myUPS.

Graph of operations:

         +- actions thread \
         +- net thread      \
apcupsd -+- serial thread    - [ UPSINFO shared structure]
         +- reports thread  /
         +- pipe thread    /
         +- slaves thread /

If a thread must write to shared structure we _have_ to lock it.
Imagine serial and net that need to write:

1 - do_serial wait for unlock then read shared data and unlock
2 - do_net wait for unlock then read shared data and unlock
3 - do_serial wait for unlock then write shared data and unlock
4 - do_net wait for unlock then write shared data and unlock but this data is
    just been updated by serial so the shared data now contain thrashed data.

We have to lock the data until the thread is ended:
1 - do_serial wait for unlock then read shared data (don't unlock)
2 - do_net wait for unlock
3 - do_serial write shared data and unlock
4 - do_net waiting for unlock can read shared data
5 - do_net write shared data and unlock

This is called serialization.

For read-only threads we can:

1 - do_report wait for unlock then read shared data and unlock and that's all.

Of course that was only examples because at this time I have not yet analyzed
the code to search for threads that don't update the myUPS structure. For this
reason now all the threads lock shared data until their update and return.

