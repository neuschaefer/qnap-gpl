Sections 

1. General Questions
2. Setup
3. Common Problems
4. Troubleshooting
5. Security Aspects
6. Backup and Data Recovery
7. Interoperability with other Disk Encryption Tools
8. Issues with Specific Versions of cryptsetup
9. References and Further Reading
A. Contributors


1. General Questions 


 * 1.1 What is this?

  This is the FAQ (Frequently Asked Questions) for cryptsetup. It
  covers Linux disk encryption with plain dm-crypt (one passphrase,
  no management, no metadata on disk) and LUKS (multiple user keys
  with one master key, anti-forensic features, metadata block at
  start of device, ...). The latest version of this FAQ should
  usually be available at
  http://code.google.com/p/cryptsetup/wiki/FrequentlyAskedQuestions


 * 1.2 WARNINGS

  ATTENTION: If you are going to read just one thing, make it the
  section on Backup and Data Recovery. By far the most questions on
  the cryptsetup mailing list are from people that managed to damage
  the start of their LUKS partitions, i.e. the LUKS header. In
  most cases, there is nothing that can be done to help these poor
  souls recover their data. Make sure you understand the problem and
  limitations imposed by the LUKS security model BEFORE you face
  such a disaster! In particular, make sure you have a current header
  backup before doing any potentially dangerous operations.

  SSDs/FLASH DRIVES: SSDs and Flash are different. Currently it is
  unclear how to get LUKS or plain dm-crypt to run on them with the
  full set of security features intact. This may or may not be a
  problem, depending on the attacher model. See Section 5.17.

  BACKUP: Yes, encrypted disks die, just as normal ones do. A full
  backup is mandatory, see Section "6. Backup and Data Recovery" on
  options for doing encrypted backup.

  CLONING/IMAGING: If you clone or image a LUKS container, you make a
  copy of the LUKS header and the master key will stay the same!
  That means that if you distribute an image to several machines, the
  same master key will be used on all of them, regardless of whether
  you change the passphrases. Do NOT do this! If you do, a root-user
  on any of the machines with a mapped (decrypted) container or a
  passphrase on that machine can decrypt all other copies, breaking
  security. See also Item 6.15.

  DISTRIBUTION INSTALLERS: Some distribution installers offer to
  create LUKS containers in a way that can be mistaken as activation
  of an existing container. Creating a new LUKS container on top of
  an existing one leads to permanent, complete and irreversible data
  loss. It is strongly recommended to only use distribution
  installers after a complete backup of all LUKS containers has been
  made.

  NO WARNING ON NON-INTERACTIVE FORMAT: If you feed cryptsetup from
  STDIN (e.g. via GnuPG) on LUKS format, it does not give you the
  warning that you are about to format (and e.g. will lose any
  pre-existing LUKS container on the target), as it assumes it is
  used from a script. In this scenario, the responsibility for
  warning the user and possibly checking for an existing LUKS header
  is shifted to the script. This is a more general form of the
  previous item.

  LUKS PASSPHRASE IS NOT THE MASTER KEY: The LUKS passphrase is not
  used in deriving the master key. It is used in decrypting a master
  key that is randomly selected on header creation. This means that
  if you create a new LUKS header on top of an old one with
  exactly the same parameters and exactly the same passphrase as the
  old one, it will still have a different master key and your data
  will be permanently lost.

  PASSPHRASE CHARACTER SET: Some people have had difficulties with
  this when upgrading distributions. It is highly advisable to only
  use the 95 printable characters from the first 128 characters of
  the ASCII table, as they will always have the same binary
  representation. Other characters may have different encoding
  depending on system configuration and your passphrase will not
  work with a different encoding. A table of the standardized first
  128 ASCII characters can, e.g. be found on
  http://en.wikipedia.org/wiki/ASCII


 * 1.3 System specific warnings

  - Ubuntu as of 4/2011: It seems the installer offers to create
  LUKS partitions in a way that several people mistook for an offer
  to activate their existing LUKS partition. The installer gives no
  or an inadequate warning and will destroy your old LUKS header,
  causing permanent data loss. See also the section on Backup and
  Data Recovery.

  This issue has been acknowledged by the Ubuntu dev team, see here:
  http://launchpad.net/bugs/420080

  Update 7/2012: I am unsure whether this has been fixed by now, best
  be careful.


 * 1.4 My LUKS-device is broken! Help!

  First: Do not panic! In many cases the data is still recoverable.
  Do not do anything hasty! Steps:

  - Take some deep breaths. Maybe add some relaxing music. This may
  sound funny, but I am completely serious. Often, critical damage is
  done only after the initial problem.

  - Do not reboot. The keys mays still be in the kernel if the device
  is mapped.

  - Make sure others do not reboot the system.

  - Do not write to your disk without a clear understanding why this
  will not make matters worse. Do a sector-level backup before any
  writes. Often you do not need to write at all to get enough access
  to make a backup of the data.

  - Relax some more.

  - Read section 6 of this FAQ.

  - Ask on the mailing-list if you need more help.


 * 1.5 Who wrote this?

  Current FAQ maintainer is Arno Wagner <arno@wagner.name>. Other
  contributors are listed at the end. If you want to contribute, send
  your article, including a descriptive headline, to the maintainer,
  or the dm-crypt mailing list with something like "FAQ ..." in the
  subject. You can also send more raw information and have me write
  the section. Please note that by contributing to this FAQ, you
  accept the license described below.

  This work is under the "Attribution-Share Alike 3.0 Unported"
  license, which means distribution is unlimited, you may create
  derived works, but attributions to original authors and this
  license statement must be retained and the derived work must be
  under the same license. See
  http://creativecommons.org/licenses/by-sa/3.0/ for more details of
  the license.

  Side note: I did text license research some time ago and I think
  this license is best suited for the purpose at hand and creates the
  least problems.


 * 1.5 Where is the project website?

  There is the project website at http://code.google.com/p/cryptsetup/
  Please do not post questions there, nobody will read them. Use
  the mailing-list instead.


 * 1.6 Is there a mailing-list?

  Instructions on how to subscribe to the mailing-list are at on the
  project website. People are generally helpful and friendly on the
  list.

  The question of how to unsubscribe from the list does crop up
  sometimes. For this you need your list management URL, which is
  sent to you initially and once at the start of each month. Go to
  the URL mentioned in the email and select "unsubscribe". This page
  also allows you to request a password reminder.

  Alternatively, you can send an Email to dm-crypt-request@saout.de
  with just the word "help" in the subject or message body. Make sure
  to send it from your list address.

  The mailing list archive is here:
  http://dir.gmane.org/gmane.linux.kernel.device-mapper.dm-crypt


2. Setup 


 * 2.1 What is the difference between "plain" and LUKS format?

  First, unless you happen to understand the cryptographic background
  well, you should use LUKS. It does protect the user from a lot of
  common mistakes. Plain dm-crypt is for experts.

  Plain format is just that: It has no metadata on disk, reads all
  parameters from the commandline (or the defaults), derives a
  master-key from the passphrase and then uses that to de-/encrypt
  the sectors of the device, with a direct 1:1 mapping between
  encrypted and decrypted sectors.

  Primary advantage is high resilience to damage, as one damaged
  encrypted sector results in exactly one damaged decrypted sector.
  Also, it is not readily apparent that there even is encrypted data
  on the device, as an overwrite with crypto-grade randomness (e.g.
  from /dev/urandom) looks exactly the same on disk.

  Side-note: That has limited value against the authorities. In
  civilized countries, they cannot force you to give up a crypto-key
  anyways. In the US, the UK and dictatorships around the world,
  they can force you to give up the keys (using imprisonment or worse
  to pressure you), and in the worst case, they only need a
  nebulous "suspicion" about the presence of encrypted data. My
  advice is to either be ready to give up the keys or to not have
  encrypted data when traveling to those countries, especially when
  crossing the borders.

  Disadvantages are that you do not have all the nice features that
  the LUKS metadata offers, like multiple passphrases that can be
  changed, the cipher being stored in the metadata, anti-forensic
  properties like key-slot diffusion and salts, etc..

  LUKS format uses a metadata header and 8 key-slot areas that are
  being placed at the beginning of the disk, see below under "What
  does the LUKS on-disk format looks like?". The passphrases are used
  to decrypt a single master key that is stored in the anti-forensic
  stripes.

  Advantages are a higher usability, automatic configuration of
  non-default crypto parameters, defenses against low-entropy
  passphrases like salting and iterated PBKDF2 passphrase hashing,
  the ability to change passphrases, and others.

  Disadvantages are that it is readily obvious there is encrypted
  data on disk (but see side note above) and that damage to the
  header or key-slots usually results in permanent data-loss. See
  below under "6. Backup and Data Recovery" on how to reduce that
  risk. Also the sector numbers get shifted by the length of the
  header and key-slots and there is a loss of that size in capacity
  (1MB+4096B for defaults and 2MB for the most commonly used
  non-default XTS mode).


 * 2.2 Can I encrypt an already existing, non-empty partition to use
   LUKS?

  There is no converter, and it is not really needed. The way to do
  this is to make a backup of the device in question, securely wipe
  the device (as LUKS device initialization does not clear away old
  data), do a luksFormat, optionally overwrite the encrypted device,
  create a new filesystem and restore your backup on the now
  encrypted device. Also refer to sections "Security Aspects" and
  "Backup and Data Recovery".

  For backup, plain GNU tar works well and backs up anything likely
  to be in a filesystem.


 * 2.3 How do I use LUKS with a loop-device?

  This can be very handy for experiments. Setup is just the same as
  with any block device. If you want, for example, to use a 100MiB
  file as LUKS container, do something like this:

      head -c 100M /dev/zero > luksfile  # create empty file
      losetup /dev/loop0 luksfile        # map luksfile to /dev/loop0
      cryptsetup luksFormat /dev/loop0   # create LUKS on loop device
 
  Afterwards just use /dev/loop0 as a you would use a LUKS partition.
  To unmap the file when done, use "losetup -d /dev/loop0".


 * 2.4 When I add a new key-slot to LUKS, it asks for a passphrase but
   then complains about there not being a key-slot with that
   passphrase?

  That is as intended. You are asked a passphrase of an existing
  key-slot first, before you can enter the passphrase for the new
  key-slot. Otherwise you could break the encryption by just adding a
  new key-slot. This way, you have to know the passphrase of one of
  the already configured key-slots in order to be able to configure a
  new key-slot.


 * 2.5 Encryption on top of RAID or the other way round?

  Unless you have special needs, place encryption between RAID and
  filesystem, i.e. encryption on top of RAID. You can do it the other
  way round, but you have to be aware that you then need to give the
  passphrase for each individual disk and RAID autodetection will
  not work anymore. Therefore it is better to encrypt the RAID
  device, e.g. /dev/dm0 .


 * 2.6 How do I read a dm-crypt key from file?

  Note that the file will still be hashed first, just like keyboard
  input. Use the --key-file option, like this:

      cryptsetup create --key-file keyfile e1 /dev/loop0
 

 * 2.7 How do I read a LUKS slot key from file?

  What you really do here is to read a passphrase from file, just as
  you would with manual entry of a passphrase for a key-slot. You can
  add a new passphrase to a free key-slot, set the passphrase of an
  specific key-slot or put an already configured passphrase into a
  file. In the last case make sure no trailing newline (0x0a) is
  contained in the key file, or the passphrase will not work because
  the whole file is used as input.

  To add a new passphrase to a free key slot from file, use something
  like this:

      cryptsetup luksAddKey /dev/loop0 keyfile
 
  To add a new passphrase to a specific key-slot, use something like
  this:

      cryptsetup luksAddKey --key-slot 7 /dev/loop0 keyfile
 
  To supply a key from file to any LUKS command, use the --key-file
  option, e.g. like this:

      cryptsetup luksOpen --key-file keyfile /dev/loop0 e1
 

 * 2.8 How do I read the LUKS master key from file?

  The question you should ask yourself first is why you would want to
  do this. The only legitimate reason I can think of is if you want
  to have two LUKS devices with the same master key. Even then, I
  think it would be preferable to just use key-slots with the same
  passphrase, or to use plain dm-crypt instead. If you really have a
  good reason, please tell me. If I am convinced, I will add how to
  do this here.


 * 2.9 What are the security requirements for a key read from file?

  A file-stored key or passphrase has the same security requirements
  as one entered interactively, however you can use random bytes and
  thereby use bytes you cannot type on the keyboard. You can use any
  file you like as key file, for example a plain text file with a
  human readable passphrase. To generate a file with random bytes,
  use something like this:

      head -c 256 /dev/random > keyfile
 

 * 2.10 If I map a journaled file system using dm-crypt/LUKS, does it
   still provide its usual transactional guarantees?

  Yes, it does, unless a very old kernel is used. The required flags
  come from the filesystem layer and are processed and passed onwards
  by dm-crypt. A bit more information on the process by which
  transactional guarantees are implemented can be found here:

  http://lwn.net/Articles/400541/

  Please note that these "guarantees" are weaker than they appear to
  be. One problem is that quite a few disks lie to the OS about
  having flushed their buffers. Some other things can go wrong as
  well. The filesystem developers are aware of these problems and
  typically can make it work anyways. That said, dm-crypt/LUKS will
  not make things worse.

  One specific problem you can run into though is that you can get
  short freezes and other slowdowns due to the encryption layer.
  Encryption takes time and forced flushes will block for that time.
  For example, I did run into frequent small freezes (1-2 sec) when
  putting a vmware image on ext3 over dm-crypt. When I went back to
  ext2, the problem went away. This seems to have gotten better with
  kernel 2.6.36 and the reworking of filesystem flush locking
  mechanism (less blocking of CPU activity during flushes). It
  should improve further and eventually the problem should go away.


 * 2.11 Can I use LUKS or cryptsetup with a more secure (external)
   medium for key storage, e.g. TPM or a smartcard?

  Yes, see the answers on using a file-supplied key. You do have to
  write the glue-logic yourself though. Basically you can have
  cryptsetup read the key from STDIN and write it there with your
  own tool that in turn gets the key from the more secure key
  storage.


 * 2.12 Can I resize a dm-crypt or LUKS partition?

  Yes, you can, as neither dm-crypt nor LUKS stores partition size.
  Whether you should is a different question. Personally I recommend
  backup, recreation of the encrypted partition with new size,
  recreation of the filesystem and restore. This gets around the
  tricky business of resizing the filesystem. Resizing a dm-crypt or
  LUKS container does not resize the filesystem in it. The backup is
  really non-optional here, as a lot can go wrong, resulting in
  partial or complete data loss. Using something like gparted to
  resize an encrypted partition is slow, but typically works. This
  will not change the size of the filesystem hidden under the
  encryption though.

  You also need to be aware of size-based limitations. The one
  currently relevant is that aes-xts-plain should not be used for
  encrypted container sizes larger than 2TiB. Use aes-xts-plain64
  for that.


3. Common Problems 


 * 3.1 My dm-crypt/LUKS mapping does not work! What general steps are
   there to investigate the problem?

  If you get a specific error message, investigate what it claims
  first. If not, you may want to check the following things.

  - Check that "/dev", including "/dev/mapper/control" is there. If it
  is missing, you may have a problem with the "/dev" tree itself or
  you may have broken udev rules.

  - Check that you have the device mapper and the crypt target in your
  kernel. The output of "dmsetup targets" should list a "crypt"
  target. If it is not there or the command fails, add device mapper
  and crypt-target to the kernel.

  - Check that the hash-functions and ciphers you want to use are in
  the kernel. The output of "cat /proc/crypto" needs to list them.


 * 3.2 My dm-crypt mapping suddenly stopped when upgrading cryptsetup.

  The default cipher, hash or mode may have changed (the mode changed
  from 1.0.x to 1.1.x). See under "Issues With Specific Versions of
  cryptsetup".


 * 3.3 When I call cryptsetup from cron/CGI, I get errors about
   unknown features?

  If you get errors about unknown parameters or the like that are not
  present when cryptsetup is called from the shell, make sure you
  have no older version of cryptsetup on your system that then gets
  called by cron/CGI. For example some distributions install
  cryptsetup into /usr/sbin, while a manual install could go to
  /usr/local/sbin. As a debugging aid, call "cryptsetup --version"
  from cron/CGI or the non-shell mechanism to be sure the right
  version gets called.


 * 3.4 Unlocking a LUKS device takes very long. Why?

  The iteration time for a key-slot (see Section 5 for an explanation
  what iteration does) is calculated when setting a passphrase. By
  default it is 1 second on the machine where the passphrase is set.
  If you set a passphrase on a fast machine and then unlock it on a
  slow machine, the unlocking time can be much longer. Also take into
  account that up to 8 key-slots have to be tried in order to find the
  right one.

  If this is problem, you can add another key-slot using the slow
  machine with the same passphrase and then remove the old key-slot.
  The new key-slot will have an iteration count adjusted to 1 second
  on the slow machine. Use luksKeyAdd and then luksKillSlot or
  luksRemoveKey.

  However, this operation will not change volume key iteration count
  (MK iterations in output of "cryptsetup luksDump"). In order to
  change that, you will have to backup the data in the LUKS
  container (i.e. your encrypted data), luksFormat on the slow
  machine and restore the data. Note that in the original LUKS
  specification this value was fixed to 10, but it is now derived
  from the PBKDF2 benchmark as well and set to iterations in 0.125
  sec or 1000, whichever is larger. Also note that MK iterations
  are not very security relevant. But as each key-slot already takes
  1 second, spending the additional 0.125 seconds really does not
  matter.


 * 3.5 "blkid" sees a LUKS UUID and an ext2/swap UUID on the same
   device. What is wrong?

  Some old versions of cryptsetup have a bug where the header does
  not get completely wiped during LUKS format and an older ext2/swap
  signature remains on the device. This confuses blkid.

  Fix: Wipe the unused header areas by doing a backup and restore of
  the header with cryptsetup 1.1.x:

      cryptsetup luksHeaderBackup --header-backup-file <file> <device>
      cryptsetup luksHeaderRestore --header-backup-file <file> <device>
 

 * 3.6 cryptsetup segfaults on Gentoo amd64 hardened ...

  There seems to be some interference between the hardening and and
  the way cryptsetup benchmarks PBKDF2. The solution to this is
  currently not quite clear for an encrypted root filesystem.     For
  other uses, you can apparently specify USE="dynamic" as compile
  flag, see http://bugs.gentoo.org/show_bug.cgi?id=283470


4. Troubleshooting 


 * 4.1 I get the error "LUKS keyslot x is invalid." What does that
   mean?

  This means that the given keyslot has an offset that points
  outside the valid keyslot area. Typically, the reason is a
  corrupted LUKS header because something was written to the start of
  the device the LUKS container is on. Refer to Section "Backup and
  Data Recovery" and ask on the mailing list if you have trouble
  diagnosing and (if still possible) repairing this.


 * 4.2 Can a bad RAM module cause problems?

  LUKS and dm-crypt can give the RAM quite a workout, especially when
  combined with software RAID. In particular the combination RAID5 +
  LUKS + XFS seems to uncover RAM problems that never caused obvious
  problems before. Symptoms vary, but often the problem manifest
  itself when copying large amounts of data, typically several times
  larger than your main memory.

  Side note: One thing you should always do on large data
  copy/movements is to run a verify, for example with the "-d"
  option of "tar" or by doing a set of MD5 checksums on the source
  or target with

      find . -type f -exec md5sum \{\} \; > checksum-file
 
  and then a "md5sum -c checksum-file" on the other side. If you get
  mismatches here, RAM is the primary suspect. A lesser suspect is
  an overclocked CPU. I have found countless hardware problems in
  verify runs after copying or making backups. Bit errors are much
  more common than most people think.

  Some RAM issues are even worse and corrupt structures in one of the
  layers. This typically results in lockups, CPU state dumps in the
  system logs, kernel panic or other things. It is quite possible to
  have the problem with an encrypted device, but not with an
  otherwise the same unencrypted device. The reason for that is that
  encryption has an error amplification property: You flip one bit
  in an encrypted data block, and the decrypted version has half of
  its bits flipped. This is an important security property for modern
  ciphers. With the usual modes in cryptsetup (CBC, ESSIV, XTS), you
  get up to a completely changed 512 byte block per bit error. A
  corrupt block causes a lot more havoc than the occasionally
  flipped single bit and can result in various obscure errors.

  Note, that a verify run on copying between encrypted or
  unencrypted devices will reliably detect corruption, even when the
  copying itself did not report any problems. If you find defect
  RAM, assume all backups and copied data to be suspect, unless you
  did a verify.


 * 4.3 How do I test RAM?

  First you should know that overclocking often makes memory
  problems worse. So if you overclock (which I strongly recommend
  against in a system holding data that has some worth), run the
  tests with the overclocking active.

  There are two good options. One is Memtest86+ and the other is
  "memtester" by Charles Cazabon. Memtest86+ requires a reboot and
  then takes over the machine, while memtester runs from a
  root-shell. Both use different testing methods and I have found
  problems fast with each one that the other needed long to find. I
  recommend running the following procedure until the first error is
  found:

  - Run Memtest86+ for one cycle

  - Run memtester for one cycle (shut down as many other applications
  as possible)

  - Run Memtest86+ for 24h or more

  - Run memtester for 24h or more

  If all that does not produce error messages, your RAM may be sound,
  but I have had one weak bit that Memtest86+ needed around 60 hours
  to find. If you can reproduce the original problem reliably, a good
  additional test may be to remove half of the RAM (if you have more
  than one module) and try whether the problem is still there and if
  so, try with the other half. If you just have one module, get a
  different one and try with that. If you do overclocking, reduce
  the settings to the most conservative ones available and try with
  that.


5. Security Aspects 


 * 5.1 Is LUKS insecure? Everybody can see I have encrypted data!

  In practice it does not really matter. In most civilized countries
  you can just refuse to hand over the keys, no harm done. In some
  countries they can force you to hand over the keys, if they suspect
  encryption. However the suspicion is enough, they do not have to
  prove anything. This is for practical reasons, as even the presence
  of a header (like the LUKS header) is not enough to prove that you
  have any keys. It might have been an experiment, for example. Or it
  was used as encrypted swap with a key from /dev/random. So they
  make you prove you do not have encrypted data. Of course that is
  just as impossible as the other way round.

  This means that if you have a large set of random-looking data,
  they can already lock you up. Hidden containers (encryption hidden
  within encryption), as possible with Truecrypt, do not help
  either. They will just assume the hidden container is there and
  unless you hand over the key, you will stay locked up. Don't have
  a hidden container? Though luck. Anybody could claim that.

  Still, if you are concerned about the LUKS header, use plain
  dm-crypt with a good passphrase. See also Section 2, "What is the
  difference between "plain" and LUKS format?"


 * 5.2 Should I initialize (overwrite) a new LUKS/dm-crypt partition?

  If you just create a filesystem on it, most of the old data will
  still be there. If the old data is sensitive, you should overwrite
  it before encrypting. In any case, not initializing will leave the
  old data there until the specific sector gets written. That may
  enable an attacker to determine how much and where on the
  partition data was written. If you think this is a risk, you can
  prevent this by overwriting the encrypted device (here assumed to
  be named "e1") with zeros like this:

      dd_rescue -w /dev/zero /dev/mapper/e1
 
  or alternatively with one of the following more standard commands:

      cat /dev/zero > /dev/mapper/e1
      dd if=/dev/zero of=/dev/mapper/e1
       

 * 5.3 How do I securely erase a LUKS (or other) partition?

  For LUKS, if you are in a desperate hurry, overwrite the LUKS
  header and key-slot area. This means overwriting the first
  (keyslots x stripes x keysize) + offset bytes. For the default
  parameters, this is the 1'052'672 bytes, i.e. 1MiB + 4096 of the
  LUKS partition. For 512 bit key length (e.g. for aes-xts-plain with
  512 bit key) this is 2MiB. (The different offset stems from
  differences in the sector alignment of the key-slots.) If in doubt,
  just be generous and overwrite the first 10MB or so, it will likely
  still be fast enough. A single overwrite with zeros should be
  enough. If you anticipate being in a desperate hurry, prepare the
  command beforehand. Example with /dev/sde1 as the LUKS partition
  and default parameters:

      head -c 1052672 /dev/zero > /dev/sde1; sync
 
  A LUKS header backup or full backup will still grant access to
  most or all data, so make sure that an attacker does not have
  access to backups or destroy them as well.

  If you have time, overwrite the whole LUKS partition with a single
  pass of zeros. This is enough for current HDDs. For SSDs or FLASH
  (USB sticks) you may want to overwrite the whole drive several
  times to be sure data is not retained by wear leveling. This is
  possibly still insecure as SSD technology is not fully understood
  in this regard. Still, due to the anti-forensic properties of the
  LUKS key-slots, a single overwrite of an SSD or FLASH drive could
  be enough. If in doubt, use physical destruction in addition. Here
  is a link to some current research results on erasing SSDs and
  FLASH drives:
  http://www.usenix.org/events/fast11/tech/full_papers/Wei.pdf

  Keep in mind to also erase all backups.

  Example for a zero-overwrite erase of partition sde1 done with
  dd_rescue:

      dd_rescue -w /dev/zero /dev/sde1   
 

 * 5.4 How do I securely erase a backup of a LUKS partition or header?

  That depends on the medium it is stored on. For HDD and SSD, use
  overwrite with zeros. For an SSD or FLASH drive (USB stick), you
  may want to overwrite the complete SSD several times and use
  physical destruction in addition, see last item. For re-writable
  CD/DVD, a single overwrite should also be enough, due to the
  anti-forensic properties of the LUKS keyslots. For write-once
  media, use physical destruction. For low security requirements,
  just cut the CD/DVD into several parts. For high security needs,
  shred or burn the medium. If your backup is on magnetic tape, I
  advise physical destruction by shredding or burning, after
  overwriting . The problem with magnetic tape is that it has a
  higher dynamic range than HDDs and older data may well be
  recoverable after overwrites. Also write-head alignment issues can
  lead to data not actually being deleted at all during overwrites.


 * 5.5 What about backup? Does it compromise security?

  That depends. See item 6.7.


 * 5.6 Why is all my data permanently gone if I overwrite the LUKS
   header?

  Overwriting the LUKS header in part or in full is the most common
  reason why access to LUKS containers is lost permanently.
  Overwriting can be done in a number of fashions, like creating a
  new filesystem on the raw LUKS partition, making the raw partition
  part of a raid array and just writing to the raw partition.

  The LUKS header contains a 256 bit "salt" value and without that no
  decryption is possible. While the salt is not secret, it is
  key-grade material and cannot be reconstructed. This is a
  cryptographically strong "cannot". From observations on the
  cryptsetup mailing-list, people typically go though the usual
  stages of grief (Denial, Anger, Bargaining, Depression, Acceptance)
  when this happens to them. Observed times vary between 1 day and 2
  weeks to complete the cycle. Seeking help on the mailing-list is
  fine. Even if we usually cannot help with getting back your data,
  most people found the feedback comforting.

  If your header does not contain an intact salt, best go directly
  to the last stage ("Acceptance") and think about what to do now.
  There is one exception that I know of: If your LUKS container is
  still open, then it may be possible to extract the master key from
  the running system. See Item "How do I recover the master key from
  a mapped LUKS container?" in Section "Backup and Data Recovery".


 * 5.7 What is a "salt"?

  A salt is a random key-grade value added to the passphrase before
  it is processed. It is not kept secret. The reason for using salts
  is as follows: If an attacker wants to crack the password for a
  single LUKS container, then every possible passphrase has to be
  tried. Typically an attacker will not try every binary value, but
  will try words and sentences from a dictionary.

  If an attacker wants to attack several LUKS containers with the
  same dictionary, then a different approach makes sense: Compute the
  resulting slot-key for each dictionary element and store it on
  disk. Then the test for each entry is just the slow unlocking with
  the slot key (say 0.00001 sec) instead of calculating the slot-key
  first (1 sec). For a single attack, this does not help. But if you
  have more than one container to attack, this helps tremendously,
  also because you can prepare your table before you even have the
  container to attack! The calculation is also very simple to
  parallelize. You could, for example, use the night-time unused CPU
  power of your desktop PCs for this.

  This is where the salt comes in. If the salt is combined with the
  passphrase (in the simplest form, just appended to it), you
  suddenly need a separate table for each salt value. With a
  reasonably-sized salt value (256 bit, e.g.) this is quite
  infeasible.


 * 5.8 Is LUKS secure with a low-entropy (bad) passphrase?

  Note: You should only use the 94 printable characters from 7 bit
  ASCII code to prevent your passphrase from failing when the
  character encoding changes, e.g. because of a system upgrade, see
  also the note at the very start of this FAQ under "WARNINGS".

  This needs a bit of theory. The quality of your passphrase is
  directly related to its entropy (information theoretic, not
  thermodynamic). The entropy says how many bits of "uncertainty" or
  "randomness" are in you passphrase. In other words, that is how
  difficult guessing the passphrase is.

  Example: A random English sentence has about 1 bit of entropy per
  character. A random lowercase (or uppercase) character has about
  4.7 bit of entropy.

  Now, if n is the number of bits of entropy in your passphrase and t
  is the time it takes to process a passphrase in order to open the
  LUKS container, then an attacker has to spend at maximum

      attack_time_max = 2^n * t 
 
  time for a successful attack and on average half that. There is no
  way getting around that relationship. However, there is one thing
  that does help, namely increasing t, the time it takes to use a
  passphrase, see next FAQ item.

  Still, if you want good security, a high-entropy passphrase is the
  only option. For example, a low-entropy passphrase can never be
  considered secure against a TLA-level (Three Letter Agency level,
  i.e. government-level) attacker, no matter what tricks are used in
  the key-derivation function. Use at least 64 bits for secret stuff.
  That is 64 characters of English text (but only if randomly chosen)
  or a combination of 12 truly random letters and digits.

  For passphrase generation, do not use lines from very well-known
  texts (religious texts, Harry potter, etc.) as they are to easy to
  guess. For example, the total Harry Potter has about 1'500'000
  words (my estimation). Trying every 64 character sequence starting
  and ending at a word boundary would take only something like 20
  days on a single CPU and is entirely feasible. To put that into
  perspective, using a number of Amazon EC2 High-CPU Extra Large
  instances (each gives about 8 real cores), this test costs
  currently about 50USD/EUR, but can be made to run arbitrarily fast.

  On the other hand, choosing 1.5 lines from, say, the Wheel of Time
  is in itself not more secure, but the book selection adds quite a
  bit of entropy. (Now that I have mentioned it here, don't use tWoT
  either!) If you add 2 or 3 typos or switch some words around, then
  this is good passphrase material.


 * 5.9 What is "iteration count" and why is decreasing it a bad idea?

  Iteration count is the number of PBKDF2 iterations a passphrase is
  put through before it is used to unlock a key-slot. Iterations are
  done with the explicit purpose to increase the time that it takes
  to unlock a key-slot. This provides some protection against use of
  low-entropy passphrases.

  The idea is that an attacker has to try all possible passphrases.
  Even if the attacker knows the passphrase is low-entropy (see last
  item), it is possible to make each individual try take longer. The
  way to do this is to repeatedly hash the passphrase for a certain
  time. The attacker then has to spend the same time (given the same
  computing power) as the user per try. With LUKS, the default is 1
  second of PBKDF2 hashing.

  Example 1: Lets assume we have a really bad passphrase (e.g. a
  girlfriends name) with 10 bits of entropy. With the same CPU, an
  attacker would need to spend around 500 seconds on average to
  break that passphrase. Without iteration, it would be more like
  0.0001 seconds on a modern CPU.

  Example 2: The user did a bit better and has 32 chars of English
  text. That would be about 32 bits of entropy. With 1 second
  iteration, that means an attacker on the same CPU needs around 136
  years. That is pretty impressive for such a weak passphrase.
  Without the iterations, it would be more like 50 days on a modern
  CPU, and possibly far less.

  In addition, the attacker can both parallelize and use special
  hardware like GPUs or FPGAs to speed up the attack. The attack can
  also happen quite some time after the luksFormat operation and CPUs
  can have become faster and cheaper. For that reason you want a
  bit of extra security. Anyways, in Example 1 your are screwed.
  In example 2, not necessarily. Even if the attack is faster, it
  still has a certain cost associated with it, say 10000 EUR/USD
  with iteration and 1 EUR/USD without iteration. The first can be
  prohibitively expensive, while the second is something you try
  even without solid proof that the decryption will yield something
  useful.

  The numbers above are mostly made up, but show the idea. Of course
  the best thing is to have a high-entropy passphrase.

  Would a 100 sec iteration time be even better? Yes and no.
  Cryptographically it would be a lot better, namely 100 times better.
  However, usability is a very important factor for security
  technology and one that gets overlooked surprisingly often. For
  LUKS, if you have to wait 2 minutes to unlock the LUKS container,
  most people will not bother and use less secure storage instead. It
  is better to have less protection against low-entropy passphrases
  and people actually use LUKS, than having them do without
  encryption altogether.

  Now, what about decreasing the iteration time? This is generally a
  very bad idea, unless you know and can enforce that the users only
  use high-entropy passphrases. If you decrease the iteration time
  without ensuring that, then you put your users at increased risk,
  and considering how rarely LUKS containers are unlocked in a
  typical work-flow, you do so without a good reason. Don't do it.
  The iteration time is already low enough that users with entropy
  low passphrases are vulnerable. Lowering it even further increases
  this danger significantly.


 * 5.10 Some people say PBKDF2 is insecure?

  There is some discussion that a hash-function should have a "large
  memory" property, i.e. that it should require a lot of memory to be
  computed. This serves to prevent attacks using special programmable
  circuits, like FPGAs, and attacks using graphics cards. PBKDF2
  does not need a lot of memory and is vulnerable to these attacks.
  However, the publication usually referred in these discussions is
  not very convincing in proving that the presented hash really is
  "large memory" (that may change, email the FAQ maintainer when it
  does) and it is of limited usefulness anyways. Attackers that use
  clusters of normal PCs will not be affected at all by a "large
  memory" property. For example the US Secret Service is known to
  use the off-hour time of all the office PCs of the Treasury for
  password breaking. The Treasury has about 110'000 employees.
  Assuming every one has an office PC, that is significant computing
  power, all of it with plenty of memory for computing "large
  memory" hashes. Bot-net operators also have all the memory they
  want. The only protection against a resourceful attacker is a
  high-entropy passphrase, see items 5.8 and 5.9.


 * 5.11 What about iteration count with plain dm-crypt?

  Simple: There is none. There is also no salting. If you use plain
  dm-crypt, the only way to be secure is to use a high entropy
  passphrase. If in doubt, use LUKS instead.


 * 5.12 Is LUKS with default parameters less secure on a slow CPU?

  Unfortunately, yes. However the only aspect affected is the
  protection for low-entropy passphrase or master-key. All other
  security aspects are independent of CPU speed.

  The master key is less critical, as you really have to work at it
  to give it low entropy. One possibility is to supply the master key
  yourself. If that key is low-entropy, then you get what you
  deserve. The other known possibility is to use /dev/urandom for
  key generation in an entropy-starved situation (e.g. automatic
  installation on an embedded device without network and other entropy
  sources).

  For the passphrase, don't use a low-entropy passphrase. If your
  passphrase is good, then a slow CPU will not matter. If you insist
  on a low-entropy passphrase on a slow CPU, use something like
  "--iter-time=10" or higher and wait a long time on each LUKS unlock
  and pray that the attacker does not find out in which way exactly
  your passphrase is low entropy. This also applies to low-entropy
  passphrases on fast CPUs. Technology can do only so much to
  compensate for problems in front of the keyboard.


 * 5.13 Why was the default aes-cbc-plain replaced with aes-cbc-essiv?

  Note: This item applies both to plain dm-crypt and to LUKS

  The problem is that cbc-plain has a fingerprint vulnerability, where
  a specially crafted file placed into the crypto-container can be
  recognized from the outside. The issue here is that for cbc-plain
  the initialization vector (IV) is the sector number. The IV gets
  XORed to the first data chunk of the sector to be encrypted. If you
  make sure that the first data block to be stored in a sector
  contains the sector number as well, the first data block to be
  encrypted is all zeros and always encrypted to the same ciphertext.
  This also works if the first data chunk just has a constant XOR
  with the sector number. By having several shifted patterns you can
  take care of the case of a non-power-of-two start sector number of
  the file.

  This mechanism allows you to create a pattern of sectors that have
  the same first ciphertext block and signal one bit per sector to the
  outside, allowing you to e.g. mark media files that way for
  recognition without decryption. For large files this is a
  practical attack. For small ones, you do not have enough blocks to
  signal and take care of different file starting offsets.

  In order to prevent this attack, the default was changed to
  cbc-essiv. ESSIV uses a keyed hash of the sector number, with the
  encryption key as key. This makes the IV unpredictable without
  knowing the encryption key and the watermarking attack fails.


 * 5.14 Are there any problems with "plain" IV? What is "plain64"?

  First, "plain" and "plain64" are both not secure to use with CBC,
  see previous FAQ item.

  However there are modes, like XTS, that are secure with "plain" IV.
  The next limit is that "plain" is 64 bit, with the upper 32 bit set
  to zero. This means that on volumes larger than 2TiB, the IV
  repeats, creating a vulnerability that potentially leaks some
  data. To avoid this, use "plain64", which uses the full sector
  number up to 64 bit. Note that "plain64" requires a kernel >=
  2.6.33. Also note that "plain64" is backwards compatible for
  volume sizes <= 2TiB, but not for those > 2TiB. Finally, "plain64"
  does not cause any performance penalty compared to "plain".


 * 5.15 What about XTS mode?

  XTS mode is potentially even more secure than cbc-essiv (but only if
  cbc-essiv is insecure in your scenario). It is a NIST standard and
  used, e.g. in Truecrypt. At the moment, if you want to use it, you
  have to specify it manually as "aes-xts-plain", i.e.

      cryptsetup -c aes-xts-plain luksFormat <device>
 
  For volumes >2TiB and kernels >= 2.6.33 use "plain64" (see FAQ
  item on "plain" and "plain64"):

      cryptsetup -c aes-xts-plain64 luksFormat <device>
 
  There is a potential security issue with XTS mode and large blocks.
  LUKS and dm-crypt always use 512B blocks and the issue does not
  apply.


 * 5.16 Is LUKS FIPS-140-2 certified?

  No. But that is more a problem of FIPS-140-2 than of LUKS. From a
  technical point-of-view, LUKS with the right parameters would be
  FIPS-140-2 compliant, but in order to make it certified, somebody
  has to pay real money for that. And then, whenever cryptsetup is
  changed or extended, the certification lapses and has to be
  obtained again.

  From the aspect of actual security, LUKS with default parameters
  should be as good as most things that are FIPS-140-2 certified,
  although you may want to make sure to use /dev/random (by
  specifying --use-random on luksFormat) as randomness source for
  the master key to avoid being potentially insecure in an
  entropy-starved situation.


 * 5.16 What about Plausible Deniability?

  First let me attempt a definition for the case of encrypted
  filesystems: Plausible deniability is when you hide encrypted data
  inside an encrypted container and it is not possible to prove it is
  there. The idea is compelling and on first glance it seems
  possible to do it. And from a cryptographic point of view, it
  actually is possible.

  So, does it work in practice? No, unfortunately. The reasoning used
  by its proponents is fundamentally flawed in several ways and the
  cryptographic properties fail fatally when colliding with the real
  world.

  First, why should "I do not have a hidden partition" be any more
  plausible than "I forgot my crypto key" or "I wiped that partition
  with random data, nothing in there"? I do not see any reason.

  Second, there are two types of situations: Either they cannot force
  you to give them the key (then you simply do not) or the can. In
  the second case, they can always do bad things to you, because they
  cannot prove that you have the key in the first place! This means
  they do not have to prove you have the key, or that this random
  looking data on your disk is actually encrypted data. So the
  situation will allow them to waterboard/lock-up/deport you
  anyways, regardless of how "plausible" your deniability is. Do not
  have a hidden partition you could show to them, but there are
  indications you may? Too bad for you. Unfortunately "plausible
  deniability" also means you cannot prove there is no hidden data.

  Third, hidden partitions are not that hidden. There are basically
  just two possibilities: a) Make a large crypto container, but put a
  smaller filesystem in there and put the hidden partition into the
  free space. Unfortunately this is glaringly obvious and can be
  detected in an automated fashion. This means that the initial
  suspicion to put you under duress in order to make you reveal you
  hidden data is given. b) Make a filesystem that spans the whole
  encrypted partition, and put the hidden partition into space not
  currently used by that filesystem. Unfortunately that is also
  glaringly obvious, as you then cannot write to the filesystem
  without a high risk of destroying data in the hidden container.
  Have not written anything to the encrypted filesystem  in a while?
  Too bad, they have the suspicion they need to do unpleasant things
  to you.

  To be fair, if you prepare option b) carefully and directly before
  going into danger, it may work. But then, the mere presence of
  encrypted data may already be enough to get you into trouble in
  those places were they can demand encryption keys.

  Here is an additional reference for some problems with plausible
  deniability: http://www.schneier.com/paper-truecrypt-dfs.pdf I
  strongly suggest you read it.

  So, no, I will not provide any instructions on how to do it with
  plain dm-crypt or LUKS. If you insist on shooting yourself in the
  foot, you can figure out how to do it yourself.


 * 5.17 What about SSDs or Flash Drives?

  The problem is that you cannot reliably erase parts of these
  devices, mainly due to wear-leveling and possibly defect
  management.

  Basically, when overwriting a sector (of 512B), what the device
  does is to move an internal sector (may be 128kB or even larger) to
  some pool of discarded, not-yet erased unused sectors, take a
  fresh empty sector from the empty-sector pool and copy the old
  sector over with the changes to the small part you wrote. This is
  done in some fashion so that larger writes do not cause a lot of
  small internal updates.

  The thing is that the mappings between outside-adressable sectors
  and inside sectors is arbitrary (and the vendors are not talking).
  Also the discarded sectors are not necessarily erased immediately.
  They may linger a long time.

  For plain dm-crypt, the consequences are that older encrypted data
  may be lying around in some internal pools of the device. Thus may
  or may not be a problem and depends on the application. Remember
  the same can happen with a filesystem if consecutive writes to the
  same area of a file can go to different sectors.

  However, for LUKS, the worst case is that key-slots and LUKS
  header may end up in these internal pools. This means that password
  management functionality is compromised (the old passwords may
  still be around, potentially for a very long time) and that fast
  erase by overwriting the header and key-slot area is insecure.

  Also keep in mind that the discarded/used pool may be large. For
  example, a 240GB SSD has about 16GB of spare area in the chips that
  it is free to do with as it likes. You would need to make each
  individual key-slot larger than that to allow reliable overwriting.
  And that assumes the disk thinks all other space is in use.
  Reading the internal pools using forensic tools is not that hard,
  but may involve some soldering.

  What to do?

  If you trust the device vendor (you probably should not...) you can
  try an ATA "secure erase" command for SSDs. That does not work for
  USB keys though. And if it finishes after a few seconds, it was
  possibly faked by the SSD.

  If you can do without password management and are fine with doing
  physical destruction for permenently deleting data (allways after
  one or several full overwrites!), you can use plain dm-crypt or
  LUKS.

  If you want or need the original LUKS security features to work,
  you can use a detached LUKS header and put that on a conventional,
  magnetic disk. That leaves potentially old encrypted data in the
  pools on the disk, but otherwise you get LUKS with the same
  security as on a magnetic disk.

  If you are concerned about your laptop being stolen, you are likely
  fine using LUKS on an SSD. An attacker would need to have access
  to an old passphrase (and the key-slot for this old passphrase
  would actually need to still be somewhere in the SSD) for your
  data to be at risk. So unless you pasted your old passphrase all
  over the Internet or the attacker has knowledge of it from some
  other source and does a targetted laptop theft to get at your
  data, you should be fine.


6. Backup and Data Recovery 


 * 6.1 Why do I need Backup?

  First, disks die. The rate for well-treated (!) disk is about 5%
  per year, which is high enough to worry about. There is some
  indication that this may be even worse for some SSDs. This applies
  both to LUKS and plain dm-crypt partitions.

  Second, for LUKS, if anything damages the LUKS header or the
  key-stripe area then decrypting the LUKS device can become
  impossible. This is a frequent occurrence. For example an
  accidental format as FAT or some software overwriting the first
  sector where it suspects a partition boot sector typically makes a
  LUKS partition permanently inaccessible. See more below on LUKS
  header damage.

  So, data-backup in some form is non-optional. For LUKS, you may
  also want to store a header backup in some secure location. This
  only needs an update if you change passphrases.


 * 6.2 How do I backup a LUKS header?

  While you could just copy the appropriate number of bytes from the
  start of the LUKS partition, the best way is to use command option
  "luksHeaderBackup" of cryptsetup. This protects also against
  errors when non-standard parameters have been used in LUKS
  partition creation. Example:

 
     cryptsetup luksHeaderBackup --header-backup-file <file> <device>
 
  To restore, use the inverse command, i.e.

     cryptsetup luksHeaderRestore --header-backup-file <file> <device>
 

 * 6.3 How do I test a LUKS header?

  Use

     cryptsetup -v isLuks <device>
 
  on the device. Without the "-v" it just signals its result via
  exit-status. You can also use the more general test

      blkid -p <device>
 
  which will also detect other types and give some more info. Omit
  "-p" for old versions of blkid that do not support it.


 * 6.4 How do I backup a LUKS or dm-crypt partition?

  There are two options, a sector-image and a plain file or
  filesystem backup of the contents of the partition. The sector
  image is already encrypted, but cannot be compressed and contains
  all empty space. The filesystem backup can be compressed, can
  contain only part of the encrypted device, but needs to be
  encrypted separately if so desired.

  A sector-image will contain the whole partition in encrypted form,
  for LUKS the LUKS header, the keys-slots and the data area. It can
  be done under Linux e.g. with dd_rescue (for a direct image copy)
  and with "cat" or "dd". Example:

      cat /dev/sda10 > sda10.img
      dd_rescue /dev/sda10 sda10.img 
 
  You can also use any other backup software that is capable of making
  a sector image of a partition. Note that compression is
  ineffective for encrypted data, hence it does not make sense to
  use it.

  For a filesystem backup, you decrypt and mount the encrypted
  partition and back it up as you would a normal filesystem. In this
  case the backup is not encrypted, unless your encryption method
  does that. For example you can encrypt a backup with "tar" as
  follows with GnuPG:

      tar cjf - <path> | gpg --cipher-algo AES -c - > backup.tbz2.gpg
 
  And verify the backup like this if you are at "path":

      cat backup.tbz2.gpg | gpg - | tar djf - 
 
  Note: Always verify backups, especially encrypted ones.

  In both cases GnuPG will ask you interactively for your symmetric
  key. The verify will only output errors. Use "tar dvjf -" to get
  all comparison results. To make sure no data is written to disk
  unencrypted, turn off swap if it is not encrypted before doing the
  backup.

  You can of course use different or no compression and you can use
  an asymmetric key if you have one and have a backup of the secret
  key that belongs to it.

  A second option for a filesystem-level backup that can be used when
  the backup is also on local disk (e.g. an external USB drive) is
  to use a LUKS container there and copy the files to be backed up
  between both mounted containers. Also see next item.


 * 6.5 Do I need a backup of the full partition? Would the header and
   key-slots not be enough?

  Backup protects you against two things: Disk loss or corruption
  and user error. By far the most questions on the dm-crypt mailing
  list about how to recover a damaged LUKS partition are related
  to user error. For example, if you create a new filesystem on a
  LUKS partition, chances are good that all data is lost
  permanently.

  For this case, a header+key-slot backup would often be enough. But
  keep in mind that a well-treated (!) HDD has roughly a failure
  risk of 5% per year. It is highly advisable to have a complete
  backup to protect against this case.


  * *6.6 What do I need to backup if I use "decrypt_derived"?

  This is a script in Debian, intended for mounting /tmp or swap with
  a key derived from the master key of an already decrypted device.
  If you use this for an device with data that should be persistent,
  you need to make sure you either do not lose access to that master
  key or have a backup of the data. If you derive from a LUKS
  device, a header backup of that device would cover backing up the
  master key. Keep in mind that this does not protect against disk
  loss.

  Note: If you recreate the LUKS header of the device you derive from
  (using luksFormat), the master key changes even if you use the same
  passphrase(s) and you will not be able to decrypt the derived
  device with the new LUKS header.


 * 6.7 Does a backup compromise security?

  Depends on how you do it. However if you do not have one, you are
  going to eventually lose your encrypted data.

  There are risks introduced by backups. For example if you
  change/disable a key-slot in LUKS, a binary backup of the partition
  will still have the old key-slot. To deal with this, you have to
  be able to change the key-slot on the backup as well, securely
  erase the backup or do a filesystem-level backup instead of a binary
  one.

  If you use dm-crypt, backup is simpler: As there is no key
  management, the main risk is that you cannot wipe the backup when
  wiping the original. However wiping the original for dm-crypt
  should consist of forgetting the passphrase and that you can do
  without actual access to the backup.

  In both cases, there is an additional (usually small) risk with
  binary backups: An attacker can see how many sectors and which
  ones have been changed since the backup. To prevent this, use a
  filesystem level backup method that encrypts the whole backup in
  one go, e.g. as described above with tar and GnuPG.

  My personal advice is to use one USB disk (low value data) or
  three disks (high value data) in rotating order for backups, and
  either use independent LUKS partitions on them, or use encrypted
  backup with tar and GnuPG.

  If you do network-backup or tape-backup, I strongly recommend to
  go the filesystem backup path with independent encryption, as you
  typically cannot reliably delete data in these scenarios,
  especially in a cloud setting. (Well, you can burn the tape if it
  is under your control...)


 * 6.8 What happens if I overwrite the start of a LUKS partition or
   damage the LUKS header or key-slots?

  There are two critical components for decryption: The salt values
  in the header itself and the key-slots. If the salt values are
  overwritten or changed, nothing (in the cryptographically strong
  sense) can be done to access the data, unless there is a backup
  of the LUKS header. If a key-slot is damaged, the data can still
  be read with a different key-slot, if there is a remaining
  undamaged and used key-slot. Note that in order to make a key-slot
  unrecoverable in a cryptographically strong sense, changing about
  4-6 bits in random locations of its 128kiB size is quite enough.


 * 6.9 What happens if I (quick) format a LUKS partition?

  I have not tried the different ways to do this, but very likely you
  will have written a new boot-sector, which in turn overwrites the
  LUKS header, including the salts, making your data permanently
  irretrievable, unless you have a LUKS header backup. You may also
  damage the key-slots in part or in full. See also last item.


 * 6.10 How do I recover the master key from a mapped LUKS container?

  This is typically only needed if you managed to damage your LUKS
  header, but the container is still mapped, i.e. "luksOpen"ed. It
  also helps if you have a mapped container that you forgot or do not
  know a passphrase for (e.g. on a long running server.)

  WARNING: Things go wrong, do a full backup before trying this!

  WARNING: This exposes the master key of the LUKS container. Note
  that both ways to recreate a LUKS header with the old master key
  described below will write the master key to disk. Unless you are
  sure you have securely erased it afterwards, e.g. by writing it to
  an encrypted partition, RAM disk or by erasing the filesystem you
  wrote it to by a complete overwrite, you should change the master
  key afterwards.    Changing the master key requires a full data
  backup, luksFormat and then restore of the backup.

  First, there is a script by Milan that automates    the whole
  process, except generating a new LUKS header with the old master
  key (it prints the command for that though):

http://code.google.com/p/cryptsetup/source/browse/misc/luks-header-from-active

  You can also do this manually. Here is how:

  - Get the master key from the device mapper. This is done by the
  following command. Substitute c5 for whatever you mapped to:

      # dmsetup table --target crypt --showkey /dev/mapper/c5
      Result:
      0 200704 crypt aes-cbc-essiv:sha256 
      a1704d9715f73a1bb4db581dcacadaf405e700d591e93e2eaade13ba653d0d09 
      0 7:0 4096
 
  The result is actually one line, wrapped here for clarity. The long
  hex string is the master key.

  - Convert the master key to a binary file representation. You can
  do this manually, e.g. with hexedit. You can also use the tool
  "xxd" from vim like this:

      echo "a1704d9....53d0d09" | xxd -r -p > <master-key-file>
 
  - Do a luksFormat to create a new LUKS header.

    NOTE: If your header is intact and you just forgot the
  passphrase, you can just set a new passphrase, see next
  sub-item.

  Unmap the device before you do that (luksClose). Then do

      cryptsetup luksFormat --master-key-file=<master-key-file> <luks device>
 
  Note that if the container was created with other than the default
  settings of the cryptsetup version you are using, you need to give
  additional parameters specifying the deviations. If in doubt, try
  the script by Milan. It does recover the other parameters as well.

  Side note: This is the way the decrypt_derived script gets at the
  master key. It just omits the conversion and hashes the master key
  string.

  - If the header is intact and you just forgot the passphrase, just
  set a new passphrase like this:

      cryptsetup luksAddKey --master-key-file=<master-key-file> <luks device>
 
  You may want to disable the old one afterwards.


 * 6.11 What does the on-disk structure of dm-crypt look like?

  There is none. dm-crypt takes a block device and gives encrypted
  access to each of its blocks with a key derived from the passphrase
  given. If you use a cipher different than the default, you have to
  specify that as a parameter to cryptsetup too. If you want to
  change the password, you basically have to create a second
  encrypted device with the new passphrase and copy your data over.
  On the plus side, if you accidentally overwrite any part of a
  dm-crypt device, the damage will be limited to the are you
  overwrote.


 * 6.12 What does the on-disk structure of LUKS look like?

  A LUKS partition consists of a header, followed by 8 key-slot
  descriptors, followed by 8 key slots, followed by the encrypted
  data area.

  Header and key-slot descriptors fill the first 592 bytes. The
  key-slot size depends on the creation parameters, namely on the
  number of anti-forensic stripes, key material offset and master
  key size.

  With the default parameters, each key-slot is a bit less than
  128kiB in size. Due to sector alignment of the key-slot start,
  that means the key block 0 is at offset 0x1000-0x20400, key
  block 1 at offset 0x21000-0x40400, and key block 7 at offset
  0xc1000-0xe0400. The space to the next full sector address is
  padded with zeros. Never used key-slots are filled with what the
  disk originally contained there, a key-slot removed with
  "luksRemoveKey" or "luksKillSlot" gets filled with 0xff. Due to
  2MiB default alignment, start of the data area for cryptsetup 1.3
  and later is at 2MiB, i.e. at 0x200000. For older versions, it is
  at 0x101000, i.e. at 1'052'672 bytes, i.e. at 1MiB + 4096 bytes
  from the start of the partition. Incidentally, "luksHeaderBackup"
  for a LUKS container created with default parameters dumps exactly
  the first 2MiB (or 1'052'672 bytes for   headers created with
  cryptsetup versions < 1.3) to file and "luksHeaderRestore" restores
  them.

  For non-default parameters, you have to figure out placement
  yourself. "luksDump" helps. See also next item. For the most common
  non-default settings, namely aes-xts-plain with 512 bit key, the
  offsets are: 1st keyslot 0x1000-0x3f800, 2nd keyslot
  0x40000-0x7e000, 3rd keyslot 0x7e000-0xbd800, ..., and start of
  bulk data at 0x200000.

  The exact specification of the format is here:
  http://code.google.com/p/cryptsetup/wiki/Specification


 * 6.13 What is the smallest possible LUKS container?

  Note: From cryptsetup 1.3 onwards, alignment is set to 1MB. With
  modern Linux partitioning tools that also align to 1MB, this will
  result in alignment to 2k sectors and typical Flash/SSD sectors,
  which is highly desirable for a number of reasons. Changing the
  alignment is not recommended.

  That said, with default parameters, the data area starts at
  exactly 2MB offset (at 0x101000 for cryptsetup versions before
  1.3). The smallest data area you can have is one sector of 512
  bytes. Data areas of 0 bytes can be created, but fail on mapping.

  While you cannot put a filesystem into something this small, it may
  still be used to contain, for example, key. Note that with current
  formatting tools, a partition for a container this size will be
  3MiB anyways. If you put the LUKS container into a file (via
  losetup and a loopback device), the file needs to be 2097664 bytes
  in size, i.e. 2MiB + 512B.

  There two ways to influence the start of the data area are key-size
  and alignment.

  For alignment, you can go down to 1 on the parameter. This will
  still leave you with a data-area starting at 0x101000, i.e.
  1MiB+4096B (default parameters) as alignment will be rounded up to
  the next multiple of 8 (i.e. 4096 bytes) If in doubt, do a dry-run
  on a larger file and dump the LUKS header to get actual
  information.

  For key-size, you can use 128 bit (e.g. AES-128 with CBC), 256 bit
  (e.g. AES-256 with CBC) or 512 bit (e.g. AES-256 with XTS mode).
  You can do 64 bit (e.g. blowfish-64 with CBC), but anything below
  128 bit has to be considered insecure today.

  Example 1 - AES 128 bit with CBC:

      cryptsetup luksFormat -s 128 --align-payload=8 <device>
 
  This results in a data offset of 0x81000, i.e. 516KiB or 528384
  bytes. Add one 512 byte sector and the smallest LUKS container size
  with these parameters is 516KiB + 512B or 528896 bytes.

  Example 2 - Blowfish 64 bit with CBC (WARNING: insecure):

      cryptsetup luksFormat -c blowfish -s 64 --align-payload=8 /dev/loop0
 
  This results in a data offset of 0x41000, i.e. 260kiB or 266240
  bytes, with a minimal LUKS container size of 260kiB + 512B or
  266752 bytes.


 * 6.14 I think this is overly complicated. Is there an alternative?

  Not really. Encryption comes at a price. You can use plain
  dm-crypt to simplify things a bit. It does not allow multiple
  passphrases, but on the plus side, it has zero on disk description
  and if you overwrite some part of a plain dm-crypt partition,
  exactly the overwritten parts are lost (rounded up to sector
  borders).


 * 6.15 Can I clone a LUKS container?

  You can, but it breaks security, because the cloned container has
  the same header and hence the same master key. You cannot change
  the master key on a LUKS container, even if you change the
  passphrase(s), the master key stays the same. That means whoever
  has access to one of the clones can decrypt them all, completely
  bypassing the passphrases.

  The right way to do this is to first luksFormat the target
  container, then to clone the contents of the source container, with
  both containers mapped, i.e. decrypted. You can clone the decrypted
  contents of a LUKS container in binary mode, although you may run
  into secondary issues with GUIDs in filesystems, partition tables,
  RAID-components and the like. These are just the normal problems
  binary cloning causes.

  Note that if you need to ship (e.g.) cloned LUKS containers with a
  default passphrase, that is fine as long as each container was
  individually created (and hence has its own master key). In this
  case, changing the default passphrase will make it secure again.


7. Interoperability with other Disk Encryption Tools  


 * 7.1 What is this section about?

  Cryptsetup for plain dm-crypt can be used to access a number of
  on-disk formats created by tools like loop-aes patched into
  losetup. This sometimes works and sometimes does not.    This
  section collects insights into what works, what does not and where
  more information is required.

  Additional information may be found in the mailing-list archives,
  mentioned at the start of this FAQ document. If you have a
  solution working that is not yet documented here and think a wider
  audience may be interested, please email the FAQ maintainer.


 * 7.2 loop-aes: General observations.

  One problem is that there are different versions of losetup around.
  loop-aes is a patch for losetup. Possible problems and deviations
  from cryptsetup option syntax include:

  - Offsets specified in bytes (cryptsetup: 512 byte sectors)

  - The need to specify an IV offset

  - Encryption mode needs specifying (e.g. "-c twofish-cbc-plain")

  - Key size needs specifying (e.g. "-s 128" for 128 bit keys)

  - Passphrase hash algorithm needs specifying

  Also note that because plain dm-crypt and loop-aes format does not
  have metadata, and while the loopAES extension for cryptsetup tries
  autodetection (see command loopaesOpen), it may not always work.
  If you still have the old set-up, using a verbosity option (-v)
  on mapping with the old tool or having a look into the system logs
  after setup could give you the information you need. Below, there
  are also some things that worked for somebody.


 * 7.3 loop-aes patched into losetup on Debian 5.x, kernel 2.6.32

  In this case, the main problem seems to be that this variant of
  losetup takes the offset (-o option) in bytes, while cryptsetup
  takes it in sectors of 512 bytes each. Example: The losetup command

  losetup -e twofish -o 2560 /dev/loop0 /dev/sdb1 
  mount /dev/loop0 mount-point
 
  translates to

  cryptsetup create -c twofish -o 5 --skip 5 e1 /dev/sdb1
  mount /dev/mapper/e1 mount-point
 

 * 7.4 loop-aes with 160 bit key

  This seems to be sometimes used with twofish and blowfish and
  represents a 160 bit ripemed160 hash output padded to 196 bit key
  length. It seems the corresponding options for cryptsetup are

  --cipher twofish-cbc-null -s 192 -h ripemd160:20
 

 * 7.5 loop-aes v1 format OpenSUSE

  Apparently this is done by older OpenSUSE distros and stopped
  working from OpenSUSE 12.1 to 12.2. One user had success with the
  following:

  cryptsetup create <target> <device> -c aes -s 128 -h sha256
 

8. Issues with Specific Versions of cryptsetup 


 * 8.1 When using the create command for plain dm-crypt with
   cryptsetup 1.1.x, the mapping is incompatible and my data is not
   accessible anymore!

  With cryptsetup 1.1.x, the distro maintainer can define different
  default encryption modes for LUKS and plain devices. You can check
  these compiled-in defaults using "cryptsetup --help". Moreover, the
  plain device default changed because the old IV mode was
  vulnerable to a watermarking attack.

  If you are using a plain device and you need a compatible mode, just
  specify cipher, key size and hash algorithm explicitly. For
  compatibility with cryptsetup 1.0.x defaults, simple use the
  following:

    cryptsetup create -c aes-cbc-plain -s 256 -h ripemd160 <name> <dev>
 
  LUKS stores cipher and mode in the metadata on disk, avoiding this
  problem.


 * 8.2 cryptsetup on SLED 10 has problems...

  SLED 10 is missing an essential kernel patch for dm-crypt, which
  is broken in its kernel as a result. There may be a very old
  version of cryptsetup (1.0.x) provided by SLED, which should also
  not be used anymore as well. My advice would be to drop SLED 10.


9. References and Further Reading 


 * Purpose of this Section

  The purpose of this section is to collect references to all
  materials that do not fit the FAQ but are relevant in some fashion.
  This can be core topics like the LUKS spec or disk encryption, but
  it can also be more tangential, like secure storage management or
  cryptography used in LUKS. It should still have relevance to
  cryptsetup and its applications.

  If you wan to see something added here, send email to the
  maintainer (or the cryptsetup mailing list) giving an URL, a
  description (1-3 lines preferred) and a section to put it in. You
  can also propose new sections.

  At this time I would like to limit the references to things that
  are available on the web.


 * Specifications

  - LUKS on-disk format spec:
  http://code.google.com/p/cryptsetup/wiki/Specification


 * Code Examples

  - Some code examples are in the source package under docs/examples


 * Tools


 * SSD and Flash Disk Related


 * Disk Encryption


 * Attacks Against Disk Encryption


 * Risk Management as Relevant for Disk Encryption


 * Cryptography


 * Secure Storage

 A. Contributors In no particular order:

  - Arno Wagner

  - Milan Broz

