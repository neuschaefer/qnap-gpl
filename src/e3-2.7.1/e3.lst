     1                                  ;--------------------------------------------------------------------
     2                                  ;
     3                                  ;  e3.asm v2.7.1 Copyright (C) 2000-2007 Albrecht Kleine <kleine@ak.sax.de>
     4                                  ;
     5                                  ;  This program is free software; you can redistribute it and/or modify
     6                                  ;  it under the terms of the GNU General Public License as published by
     7                                  ;  the Free Software Foundation; either version 2 of the License, or
     8                                  ;  (at your option) any later version.
     9                                  ;
    10                                  ;  This program is distributed in the hope that it will be useful,
    11                                  ;  but WITHOUT ANY WARRANTY; without even the implied warranty of
    12                                  ;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    13                                  ;  GNU General Public License for more details.
    14                                  ;
    15                                  ;  You should have received a copy of the GNU General Public License
    16                                  ;  along with this program; if not, write to the Free Software
    17                                  ;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
    18                                  ;
    19                                  ;----------------------------------------------------------------------
    20                                  ;
    21                                  %include "e3.h"
    22                              <1> ;--------------------------------------------------------------------------
    23                              <1> ;  e3.asm v2.7.0 Copyright (C) 2000-06 Albrecht Kleine <kleine@ak.sax.de>
    24                              <1> ;
    25                              <1> ;  see GNU copyright details in e3.asm
    26                              <1> ;--------------------------------------------------------------------------
    27                              <1> 
    28                              <1> %define WS 1
    29                              <1> %define EM 2
    30                              <1> %define PI 4
    31                              <1> %define VI 8
    32                              <1> %define NE 16
    33                              <1> ;---change DEFAULT_MODE from WS to VI---
    34                              <1> %define DEFAULT_MODE VI			;<---- select one of WS, EM, NE, PI, VI
    35                              <1> %define MAKE_BACKUP
    36                              <1> %define LESSWRITEOPS
    37                              <1> ;-------
    38                              <1> %define UTF8				;for UTF8 console or xterm e.g. @ Suse 9.1
    39                              <1> ;%define UTF8RTS				;runtime detection of UTF8 console display
    40                              <1> ;-------
    41                              <1> %define BEEP_IN_VI			;undef if you hate beeping computers
    42                              <1> %define USE_MATH			;undef if you don't use the numerics
    43                              <1> %define USE_PIPE			;undef if you don't use piping through sed/ex
    44                              <1> %define USE_BUILTINHELP			;undef if you really don't need help (saves some space)
    45                              <1> %define USE_UNDO			;undef if there is low memory
    46                              <1> ;;;%define USE_EXT_MOVE			;smart move mode for Home,End,BOF,EOF keys
    47                              <1> ;
    48                              <1> ;-------
    49                              <1> ;
    50                              <1> ;	D O   N O T   C H A N G E   B E L O W   L I N E
    51                              <1> ;----------------------------------------------------------------------
    52                              <1> %ifndef LINUX
    53                              <1>  %undef UTF8
    54                              <1> %endif
    55                              <1> 
    56                              <1> %ifndef UTF8
    57                              <1>   %undef UTF8RTS
    58                              <1> %endif
    59                              <1> 
    60                              <1> %ifdef NETBSD
    61                              <1> %define FREEBSD
    62                              <1> %endif
    63                              <1> %ifdef OPENBSD
    64                              <1> %define FREEBSD
    65                              <1> %endif
    66                              <1> ;
    67                              <1> ;beware of SYS_... constants > 255! (see NetBSD)
    68                              <1> ;
    69                              <1> %ifdef BEOS
    70                              <1> 	;posix/termios.h				;termios eq termio
    71                              <1> 	%define TERMIOS_SET 8001h			;TCSETA
    72                              <1> 	%define TERMIOS_GET 8000h			;TCGETA
    73                              <1> 	%define TERMIOS_WSIZE 800Ch			;TIOCGWINSZ
    74                              <1> 	%define NCCS 11
    75                              <1> 	%define VMIN 4
    76                              <1> 	%define speed_t1		resb
    77                              <1> 	%undef USE_PIPE
    78                              <1> %define SYS_exit	63
    79                              <1> %define SYS_read	2
    80                              <1> %define SYS_write	3
    81                              <1> %define SYS_open	0
    82                              <1> %define SYS_close	1
    83                              <1> %define SYS_unlink	39
    84                              <1> %define SYS_lseek	5
    85                              <1> %define SYS_rename	38
    86                              <1> %define SYS_ioctl	4
    87                              <1> 
    88                              <1> MAXERRNO	equ 30
    89                              <1> ERRNOMEM	equ 12
    90                              <1> ERRNOIO		equ 5
    91                              <1> 
    92                              <1> 	%macro errortext 0
    93                              <1> db "Op not permitted",10		;1
    94                              <1> db "No such file|directory",10		;2
    95                              <1> db 10					;3
    96                              <1> db 10					;4
    97                              <1> db "Input/output",10			;5
    98                              <1> db "No such device",10			;6
    99                              <1> db 10					;7
   100                              <1> db 10					;8
   101                              <1> db "Bad file descriptor",10		;9
   102                              <1> db "No child processes",10		;10
   103                              <1> db 10					;11		
   104                              <1> db "Memory exhausted",10		;12
   105                              <1> db "Permission denied",10		;13
   106                              <1> db 10					;14
   107                              <1> db 10					;15
   108                              <1> db "Device|resource busy",10		;16
   109                              <1> db "File exists",10			;17
   110                              <1> db 10					;18
   111                              <1> db "No such device",10			;19
   112                              <1> db 10					;20
   113                              <1> db "Is a directory",10			;21
   114                              <1> db "Invalid argument",10		;22
   115                              <1> db "Too many open files",10		;23
   116                              <1> db "Too many open files",10		;24
   117                              <1> db "Inappropriate ioctl",10		;25
   118                              <1> db "Text file busy",10			;26
   119                              <1> db "File too large",10			;27
   120                              <1> db "No space on device",10		;28
   121                              <1> db "Illegal seek",10			;29
   122                              <1> db "R/O file system",10			;30
   123                              <1> 	%endmacro
   124                              <1> 
   125                              <1> %else
   126                              <1> %ifdef QNX
   127                              <1> 	;termios.h
   128                              <1> 	;sys/ioctl.h
   129                              <1> 	%define TERMIOS_SET   804c7414h	;TIOCSETA
   130                              <1> 	%define TERMIOS_GET   404c7413h	;TIOCGETA
   131                              <1> 	%define TERMIOS_WSIZE 40087468h	;TIOCGWINSZ
   132                              <1> 	;		      rw	
   133                              <1> 	;		        size
   134                              <1> 	;			  't'
   135                              <1> 	;			    nr.
   136                              <1> 	%define NCCS 40
   137                              <1> 	%define VMIN 6
   138                              <1> 	%define speed_t2	resd
   139                              <1> ;-------
   140                              <1> ;the QNX version is linked against libc
   141                              <1> %define LIBC
   142                              <1> extern open,read,write,close,lseek,rename,_exit,ioctl,fstat,fchown,select,unlink
   143                              <1> extern errno
   144                              <1> %undef USE_PIPE
   145                              <1> 	%define SYS_fstat		;dummy
   146                              <1> 	struc stat_struc
   147                              <1> .st_ino:	resd 2 
   148                              <1> .st_size:	resd 2
   149                              <1> .st_dev:	resd 1
   150                              <1> .st_rdev:	resd 1
   151                              <1> .st_uid:	resd 1;24
   152                              <1> .st_gid:	resd 1;28
   153                              <1> .st_ctime:	resd 1;
   154                              <1> .st_atime:	resd 1;
   155                              <1> .st_mtime:	resd 1;40
   156                              <1> .st_mode:	resd 1;44
   157                              <1> .st_dummy:	resd 20		;who cares?
   158                              <1> 	endstruc
   159                              <1> MAXERRNO	equ 30
   160                              <1> ERRNOMEM	equ 12
   161                              <1> ERRNOIO		equ 5
   162                              <1> 
   163                              <1> 	%macro errortext 0
   164                              <1> db "Op not permitted",10		;1
   165                              <1> db "No such file|directory",10		;2
   166                              <1> db 10					;3
   167                              <1> db 10					;4
   168                              <1> db "Input/output",10			;5
   169                              <1> db "No such device",10			;6
   170                              <1> db 10					;7
   171                              <1> db 10					;8
   172                              <1> db "Bad file descriptor",10		;9
   173                              <1> db "No child processes",10		;10
   174                              <1> db 10					;11		
   175                              <1> db "Memory exhausted",10		;12
   176                              <1> db "Permission denied",10		;13
   177                              <1> db 10					;14
   178                              <1> db 10					;15
   179                              <1> db "Device|resource busy",10		;16
   180                              <1> db "File exists",10			;17
   181                              <1> db 10					;18
   182                              <1> db "No such device",10			;19
   183                              <1> db 10					;20
   184                              <1> db "Is a directory",10			;21
   185                              <1> db "Invalid argument",10		;22
   186                              <1> db "Too many open files",10		;23
   187                              <1> db "Too many open files",10		;24
   188                              <1> db "Inappropriate ioctl",10		;25
   189                              <1> db "Text file busy",10			;26
   190                              <1> db "File too large",10			;27
   191                              <1> db "No space on device",10		;28
   192                              <1> db "Illegal seek",10			;29
   193                              <1> db "R/O file system",10			;30
   194                              <1> 	%endmacro
   195                              <1> 
   196                              <1> %else
   197                              <1> %ifdef ATHEOS	;--------------------- A T H E O S -----------------------
   198                              <1> 	;posix/termbits.h
   199                              <1> 	%define TERMIOS_SET 5406h
   200                              <1> 	%define TERMIOS_GET 5405h
   201                              <1> 	%define TERMIOS_WSIZE 5413h
   202                              <1> 	%define NCCS 19
   203                              <1> 	%define VMIN 6
   204                              <1> 	;posix/stat.h
   205                              <1> 	struc stat_struc
   206                              <1> .st_dev:	resd 1
   207                              <1> .st_ino:	resd  2
   208                              <1> .st_mode:	resd 1
   209                              <1> .st_nlink:	resd 1
   210                              <1> .st_uid:	resd 1
   211                              <1> .st_gid:	resd 1
   212                              <1> .st_rdev:	resd 1
   213                              <1> .st_size:	resd  2
   214                              <1> .st_blksize:	resd 1
   215                              <1> .st_blocks:	resd  2
   216                              <1> .st_atime:	resd 1
   217                              <1> .__unused1:	resd 1
   218                              <1> .st_mtime:	resd 1
   219                              <1> .__unused2:	resd 1
   220                              <1> .st_ctime:	resd 1
   221                              <1> .__unused3:	resd 1
   222                              <1> .__unused4:	resd 1
   223                              <1> .__unused5:	resd 1
   224                              <1> 	endstruc
   225                              <1> 	%undef USE_PIPE
   226                              <1> 
   227                              <1> %define SYS_exit	6
   228                              <1> %define SYS_read	3
   229                              <1> %define SYS_write	4
   230                              <1> %define SYS_open	1
   231                              <1> %define SYS_close	2
   232                              <1> %define SYS_unlink	20
   233                              <1> %define SYS_lseek	13
   234                              <1> %define SYS_kill	92
   235                              <1> %define SYS_rename	7
   236                              <1> %define SYS_ioctl	116
   237                              <1> %define SYS_sigaction	93
   238                              <1> %define SYS_fchown	86
   239                              <1> %define SYS_fstat	11
   240                              <1> %define SYS_select	42
   241                              <1> 
   242                              <1> SIGCONT		equ 18
   243                              <1> SIGSTOP		equ 19
   244                              <1> 
   245                              <1> 
   246                              <1> MAXERRNO	equ 30
   247                              <1> ERRNOMEM	equ 12
   248                              <1> ERRNOIO		equ 5
   249                              <1> 
   250                              <1> 	%macro errortext 0
   251                              <1> db "Op not permitted",10		;1
   252                              <1> db "No such file|directory",10		;2
   253                              <1> db 10					;3
   254                              <1> db 10					;4
   255                              <1> db "Input/output",10			;5
   256                              <1> db "No such device",10			;6
   257                              <1> db 10					;7
   258                              <1> db 10					;8
   259                              <1> db "Bad file descriptor",10		;9
   260                              <1> db "No child processes",10		;10
   261                              <1> db 10					;11		
   262                              <1> db "Memory exhausted",10		;12
   263                              <1> db "Permission denied",10		;13
   264                              <1> db 10					;14
   265                              <1> db 10					;15
   266                              <1> db "Device|resource busy",10		;16
   267                              <1> db "File exists",10			;17
   268                              <1> db 10					;18
   269                              <1> db "No such device",10			;19
   270                              <1> db 10					;20
   271                              <1> db "Is a directory",10			;21
   272                              <1> db "Invalid argument",10		;22
   273                              <1> db "Too many open files",10		;23
   274                              <1> db "Too many open files",10		;24
   275                              <1> db "Inappropriate ioctl",10		;25
   276                              <1> db "Text file busy",10			;26
   277                              <1> db "File too large",10			;27
   278                              <1> db "No space on device",10		;28
   279                              <1> db "Illegal seek",10			;29
   280                              <1> db "R/O file system",10			;30
   281                              <1> 	%endmacro
   282                              <1> %else
   283                              <1> %ifdef LINUX	;----------------------- L I N U X -----------------------
   284                              <1> 	;asm/termbits.h
   285                              <1> 	;asm/ioctls.h
   286                              <1> 	%define TERMIOS_SET 5402h			;TCSETS
   287                              <1> 	%define TERMIOS_GET 5401h			;TCGETS
   288                              <1> 	%define TERMIOS_WSIZE 5413h			;TIOCGWINSZ
   289                              <1> 	%define NCCS 19
   290                              <1> 	%define VMIN 6
   291                              <1> ;-------
   292                              <1> %ifndef AMD64
   293                              <1> 	;asm/stat.h
   294                              <1> 	%define UIDGID_WORD
   295                              <1> 	struc stat_struc
   296 00000000 <res 00000004>      <1> .st_dev:	resd 1
   297 00000004 <res 00000004>      <1> .st_ino:	resd 1		;unsigned long  st_ino;
   298 00000008 <res 00000002>      <1> .st_mode:	resw 1		;unsigned short st_mode;
   299 0000000A <res 00000002>      <1> .st_nlink:	resw 1
   300 0000000C <res 00000002>      <1> .st_uid:	resw 1
   301 0000000E <res 00000002>      <1> .st_gid:	resw 1
   302 00000010 <res 00000004>      <1> .st_rdev:	resd 1
   303 00000014 <res 00000004>      <1> .st_size:	resd 1
   304 00000018 <res 00000004>      <1> .st_blksize:	resd 1
   305 0000001C <res 00000004>      <1> .st_blocks:	resd 1
   306 00000020 <res 00000004>      <1> .st_atime:	resd 1
   307 00000024 <res 00000004>      <1> .__unused1:	resd 1
   308 00000028 <res 00000004>      <1> .st_mtime:	resd 1
   309 0000002C <res 00000004>      <1> .__unused2:	resd 1
   310 00000030 <res 00000004>      <1> .st_ctime:	resd 1
   311 00000034 <res 00000004>      <1> .__unused3:	resd 1
   312 00000038 <res 00000004>      <1> .__unused4:	resd 1
   313 0000003C <res 00000004>      <1> .__unused5:	resd 1
   314                              <1> 	endstruc
   315                              <1> 
   316                              <1> %define SYS_exit	1
   317                              <1> %define SYS_fork	2
   318                              <1> %define SYS_read	3
   319                              <1> %define SYS_write	4
   320                              <1> %define SYS_open	5
   321                              <1> %define SYS_close	6
   322                              <1> %define SYS_unlink	10
   323                              <1> %define SYS_execve	11
   324                              <1> %define SYS_lseek	19
   325                              <1> %define SYS_utime	30
   326                              <1> %define SYS_kill	37
   327                              <1> %define SYS_rename	38
   328                              <1> %define SYS_pipe	42
   329                              <1> %define SYS_brk		45
   330                              <1> %define SYS_ioctl	54
   331                              <1> %define SYS_dup2	63
   332                              <1> %define SYS_sigaction	67
   333                              <1> %define SYS_rt_sigaction 174
   334                              <1> %define SYS_readlink	85
   335                              <1> %define SYS_fchmod	94
   336                              <1> %define SYS_fchown	95
   337                              <1> %define SYS_fstat	108
   338                              <1> %define SYS_wait4	114
   339                              <1> %define SYS_select	142
   340                              <1> %ifndef ARMCPU
   341                              <1> %define time_t	resd
   342                              <1> %endif
   343                              <1> %else				;;--------- AMD64
   344                              <1> 	struc stat_struc
   345                              <1> .st_dev:	resq 1
   346                              <1> .st_ino:	resq 1
   347                              <1> .st_nlink:	resq 1
   348                              <1> .st_mode:	resd 1
   349                              <1> .st_uid:	resd 1
   350                              <1> .st_gid:	resd 1
   351                              <1> .__unused0:	resd 1
   352                              <1> .st_rdev:	resq 1
   353                              <1> .st_size:	resq 1
   354                              <1> .st_blksize:	resq 1
   355                              <1> .st_blocks:	resq 1
   356                              <1> .st_atime:	resq 1
   357                              <1> .__unused1:	resq 1
   358                              <1> .st_mtime:	resq 1
   359                              <1> .__unused2:	resq 1
   360                              <1> .st_ctime:	resq 1
   361                              <1> .__unused3:	resq 1
   362                              <1> .__unused4:	resq 1
   363                              <1> .__unused5:	resq 1
   364                              <1> 	endstruc
   365                              <1> %define SYS_exit	60
   366                              <1> %define SYS_fork	57
   367                              <1> %define SYS_read	0
   368                              <1> %define SYS_write	1
   369                              <1> %define SYS_open	2
   370                              <1> %define SYS_close	3
   371                              <1> %define SYS_unlink	87
   372                              <1> %define SYS_execve	59
   373                              <1> %define SYS_lseek	8
   374                              <1> %define SYS_utime	132	;30
   375                              <1> %define SYS_kill	62
   376                              <1> %define SYS_rename	82
   377                              <1> %define SYS_pipe	22
   378                              <1> %define SYS_brk		12
   379                              <1> %define SYS_ioctl	16
   380                              <1> %define SYS_dup2	33
   381                              <1> %define SYS_rt_sigaction 13
   382                              <1> %define SYS_rt_sigreturn 15
   383                              <1> %define SYS_readlink	89
   384                              <1> %define SYS_fchmod	91
   385                              <1> %define SYS_fchown	93
   386                              <1> %define SYS_fstat	5
   387                              <1> %define SYS_wait4	61
   388                              <1> %define SYS_select	23	;142
   389                              <1> 
   390                              <1> %define time_t	resq
   391                              <1> %endif
   392                              <1> 
   393                              <1> %ifndef ARMCPU
   394                              <1> 	struc utimbuf_struc
   395 00000000 <res 00000004>      <1> .actime: time_t  1
   396 00000004 <res 00000004>      <1> .modtime:time_t 1
   397                              <1> 	endstruc
   398                              <1> %else
   399                              <1> 	struc utimbuf_struc
   400                              <1> .actime: resd  1
   401                              <1> .modtime:resd 1
   402                              <1> 	endstruc
   403                              <1> %endif
   404                              <1> %ifdef CRIPLED_ELF
   405                              <1> %define USE_SPECIAL_HEADER		;special ELF header etc
   406                              <1> %endif
   407                              <1> 
   408                              <1> ;-------
   409                              <1> %ifdef UTF8
   410                              <1>  %define NEW_CURSOR_MGNT		;switch cursor depending of 'INSERT'-mode
   411                              <1>  %undef CURSORMGNT			;switch cursor depending of 'INSERT'-mode
   412                              <1>  ;no more support of CURSORMGNT for UTF-8 thus replaced by:
   413                              <1>  ;8.Juni 2004: see /usr/src/linux/Documentation/VGA-softcursor.txt
   414                              <1> %else
   415                              <1>  %define CURSORMGNT
   416                              <1>  ;trad style
   417                              <1>  %ifdef AMD64
   418                              <1>   %undef CURSORMGNT			;work around January 2006
   419                              <1>  %endif
   420                              <1> %endif
   421                              <1> ;--------
   422                              <1> 
   423                              <1> SIGCONT		equ 18
   424                              <1> SIGSTOP		equ 19
   425                              <1> 
   426                              <1> %define CAPTURE_STDERR
   427                              <1> %ifdef EX
   428                              <1>  %define USE_EX_NO_SED
   429                              <1>  %define EX_PATH '/usr/bin/ex'		;(ex is usually a symlink to vi)   [ old was /bin/ex ]
   430                              <1> %else
   431                              <1>  %undef USE_EX_NO_SED
   432                              <1>  %ifndef PERLPIPE
   433                              <1>  %define SEDPATH '/bin/sed'		;DEFAULT
   434                              <1>  %else
   435                              <1>  %define SEDPATH '/usr/bin/perl'
   436                              <1>  %endif
   437                              <1> %endif
   438                              <1> 
   439                              <1> MAXERRNO	equ 32
   440                              <1> ERRNOMEM	equ 12
   441                              <1> ERRNOIO		equ 5
   442                              <1> ERRNOEXEC	equ 31
   443                              <1> 	%macro errortext 0
   444                              <1> db "Op not permitted",10		;1
   445                              <1> db "No such file|directory",10		;2
   446                              <1> db 10					;3
   447                              <1> db 10					;4
   448                              <1> db "Input/output",10			;5
   449                              <1> db "No such device",10			;6
   450                              <1> db 10					;7
   451                              <1> db 10					;8
   452                              <1> db "Bad file descriptor",10		;9
   453                              <1> db "No child processes",10		;10
   454                              <1> db 10					;11		
   455                              <1> db "Memory exhausted",10		;12
   456                              <1> db "Permission denied",10		;13
   457                              <1> db 10					;14
   458                              <1> db 10					;15
   459                              <1> db "Device|resource busy",10		;16
   460                              <1> db "File exists",10			;17
   461                              <1> db 10					;18
   462                              <1> db "No such device",10			;19
   463                              <1> db 10					;20
   464                              <1> db "Is a directory",10			;21
   465                              <1> db "Invalid argument",10		;22
   466                              <1> db "Too many open files",10		;23
   467                              <1> db "Too many open files",10		;24
   468                              <1> db "Inappropriate ioctl",10		;25
   469                              <1> db "Text file busy",10			;26
   470                              <1> db "File too large",10			;27
   471                              <1> db "No space on device",10		;28
   472                              <1> db "Illegal seek",10			;29
   473                              <1> db "R/O file system",10			;30
   474                              <1> db "Can't exec "			;31
   475                              <1> %ifdef USE_EX_NO_SED
   476                              <1> db EX_PATH,10
   477                              <1> %else
   478                              <1> db SEDPATH,10
   479                              <1> %endif
   480                              <1> db "Broken pipe",10			;32
   481                              <1> 	%endmacro
   482                              <1> %ifdef LIBC
   483                              <1>  extern open,read,write,close,lseek,rename,_exit,ioctl,fstat,fchown,select,unlink,fchmod
   484                              <1>  extern _errno
   485                              <1>  %undef SYS_readlink
   486                              <1>  %undef SYS_brk
   487                              <1>  %undef SYS_kill
   488                              <1>  %undef SYS_sigaction
   489                              <1>  %undef SYS_rt_sigaction
   490                              <1>  %undef USE_PIPE
   491                              <1> %endif
   492                              <1> %ifdef ARMCPU
   493                              <1>  %undef USE_MATH
   494                              <1>  %undef USE_UNDO
   495                              <1>  %undef USE_PIPE
   496                              <1> %endif
   497                              <1> %else
   498                              <1> %ifdef FREEBSD	;----------------------- FREE B S D -----------------------
   499                              <1> 	;sys/termios.h
   500                              <1> 	%define TERMIOS_SET   802c7414h		;TIOCSETA
   501                              <1> 	%define TERMIOS_GET   402c7413h		;TIOCGETA
   502                              <1> 	%define TERMIOS_WSIZE 40087468h
   503                              <1> 	;		      rw	
   504                              <1> 	;		        size
   505                              <1> 	;			  't'
   506                              <1> 	;			    nr.
   507                              <1> 	%define NCCS 20
   508                              <1> 	%define VMIN 16
   509                              <1> 	%define speed_t3	resd
   510                              <1> 	%define ICRNL	0x100 
   511                              <1> 	%define IXON	0x200
   512                              <1> 	%define ICANON	0x100
   513                              <1> 	%define ISIG	0x80
   514                              <1> 	%define ECHO	0x8
   515                              <1> 	%define TSize   word			;due oversized ICANON
   516                              <1> ;------
   517                              <1> 
   518                              <1> 	struc stat_struc
   519                              <1> .st_dev:	resd 1
   520                              <1> .st_ino:	resd 1
   521                              <1> %ifdef OPENBSD
   522                              <1> .st_mode:	resw 1				;for syscall 279
   523                              <1> .st_nlink:	resw 1				;ditto
   524                              <1> %else
   525                              <1> .st_mode:	resd 1
   526                              <1> .st_nlink:	resd 1
   527                              <1> %endif
   528                              <1> .st_uid:	resd 1
   529                              <1> .st_gid:	resd 1
   530                              <1> .st_rdev:	resd 1
   531                              <1> .st_atime:	resd 1
   532                              <1> .st_atimes:	resd 1
   533                              <1> .st_mtime:	resd 1
   534                              <1> .st_mtimes:	resd 1
   535                              <1> .st_ctime:	resd 1
   536                              <1> .st_ctimes:	resd 1
   537                              <1> .st_size:	resd 2
   538                              <1> .st_blocks:	resd 2
   539                              <1> .st_blksize:	resd 1
   540                              <1> .st_flags:	resd 1
   541                              <1> .st_gen:	resd 1
   542                              <1> .st_spare:	resd 5
   543                              <1> 	endstruc
   544                              <1> 
   545                              <1> %define SYS_exit	1
   546                              <1> %define SYS_fork	2
   547                              <1> %define SYS_read	3
   548                              <1> %define SYS_write	4
   549                              <1> %define SYS_open	5
   550                              <1> %define SYS_close	6
   551                              <1> %define SYS_unlink	10
   552                              <1> %define SYS_execve	59
   553                              <1> %define SYS_lseek	199	;old was 19
   554                              <1> %define SYS_utime	138
   555                              <1> %define SYS_kill	37
   556                              <1> %define SYS_rename	128
   557                              <1> %define SYS_pipe	42
   558                              <1> %define SYS_ioctl	54
   559                              <1> %define SYS_dup2	90
   560                              <1> %define SYS_sigaction	46	;also 342 *** take care if >255 cause only register al used
   561                              <1> %define SYS_readlink	58
   562                              <1> %define SYS_fchown	123
   563                              <1> %define SYS_fchmod      124
   564                              <1> %define SYS_fstat	279	;old was 189
   565                              <1> %define SYS_wait4	7
   566                              <1> %define SYS_select	93
   567                              <1> 
   568                              <1> %ifdef OPENBSD
   569                              <1> %undef SYS_kill
   570                              <1> %undef SYS_sigaction
   571                              <1> %undef  SYS_fstat	
   572                              <1> %define SYS_fstat	189	;could not test 292
   573                              <1> %endif
   574                              <1> 
   575                              <1> %ifdef NETBSD
   576                              <1> %undef SYS_kill		;both
   577                              <1> %undef SYS_sigaction	;currently only for old COMPAT layer working
   578                              <1> %endif
   579                              <1> 
   580                              <1> 
   581                              <1> %define time_t	resd
   582                              <1> 
   583                              <1> 	struc utimbuf_struc
   584                              <1> .actime: time_t  2
   585                              <1> .modtime:time_t 2
   586                              <1> 	endstruc
   587                              <1> 	
   588                              <1> %undef CAPTURE_STDERR
   589                              <1> %ifdef EX
   590                              <1>  %define USE_EX_NO_SED
   591                              <1>  %define EX_PATH '/usr/bin/ex'		;(ex is usually a symlink to vi)   [ old was /bin/ex ]
   592                              <1> %else
   593                              <1>  %undef USE_EX_NO_SED
   594                              <1>  %ifndef PERLPIPE
   595                              <1>  %define SEDPATH '/usr/bin/sed'		;DEFAULT
   596                              <1>  %else
   597                              <1>  %define SEDPATH '/usr/bin/perl'
   598                              <1>  %endif
   599                              <1> %endif
   600                              <1> 
   601                              <1> MAXERRNO	equ 32
   602                              <1> ERRNOMEM	equ 12
   603                              <1> ERRNOIO		equ 5
   604                              <1> ERRNOEXEC	equ 31
   605                              <1> ERRNOREGFILE	equ 21
   606                              <1> 	%macro errortext 0
   607                              <1> db "Op not permitted",10		;1
   608                              <1> db "No such file|directory",10		;2
   609                              <1> db 10					;3
   610                              <1> db 10					;4
   611                              <1> db "Input/output",10			;5
   612                              <1> db "No such device",10			;6
   613                              <1> db 10					;7
   614                              <1> db 10					;8
   615                              <1> db "Bad file descriptor",10		;9
   616                              <1> db "No child processes",10		;10
   617                              <1> db 10					;11		
   618                              <1> db "Memory exhausted",10		;12
   619                              <1> db "Permission denied",10		;13
   620                              <1> db 10					;14
   621                              <1> db 10					;15
   622                              <1> db "Device busy",10			;16
   623                              <1> db "File exists",10			;17
   624                              <1> db 10					;18
   625                              <1> db "No such device",10			;19
   626                              <1> db 10					;20
   627                              <1> db "Is a directory",10			;21
   628                              <1> db "Invalid argument",10		;22
   629                              <1> db "Too many open files",10		;23
   630                              <1> db "Too many open files",10		;24
   631                              <1> db "Inappropriate ioctl",10		;25
   632                              <1> db "Text file busy",10			;26
   633                              <1> db "File too large",10			;27
   634                              <1> db "No space on device",10		;28
   635                              <1> db "Illegal seek",10			;29
   636                              <1> db "R/O file system",10			;30
   637                              <1> db "Can't exec "			;31
   638                              <1> %ifdef USE_EX_NO_SED
   639                              <1> db EX_PATH,10
   640                              <1> %else
   641                              <1> db SEDPATH,10
   642                              <1> %endif
   643                              <1> db "Broken pipe",10			;32
   644                              <1> 	%endmacro
   645                              <1> %ifdef LIBC
   646                              <1>  extern open,read,write,close,lseek,rename,_exit,ioctl,fstat,fchown,select,unlink,fchmod
   647                              <1>  extern errno
   648                              <1>  %undef SYS_readlink
   649                              <1>  %undef SYS_brk
   650                              <1>  %undef SYS_kill
   651                              <1>  %undef SYS_sigaction
   652                              <1>  %undef USE_PIPE
   653                              <1> %endif
   654                              <1> 
   655                              <1> %else
   656                              <1> %ifdef W32	;----------------------- W I N  32 -----------------------
   657                              <1> %define W32LF				;<-- controls linefeed style
   658                              <1> 
   659                              <1> STD_INPUT_HANDLE	equ -10
   660                              <1> STD_OUTPUT_HANDLE	equ -11
   661                              <1> ENABLE_WINDOW_INPUT	equ 8
   662                              <1> FILE_ATTRIBUTE_NORMAL	equ 128
   663                              <1> OPEN_EXISTING		equ 3
   664                              <1> CREATE_ALWAYS		equ 2
   665                              <1> GENERIC_READ		equ $80000000
   666                              <1> GENERIC_WRITE		equ $40000000
   667                              <1> INVALID_HANDLE_VALUE	equ -1
   668                              <1> FOREGROUND_BLUE		equ 1
   669                              <1> FOREGROUND_GREEN	equ 2
   670                              <1> FOREGROUND_RED		equ 4
   671                              <1> FOREGROUND_INTENSITY	equ 8
   672                              <1> DARKWHITE		equ (FOREGROUND_GREEN|FOREGROUND_BLUE|FOREGROUND_RED)
   673                              <1> WHITE			equ (DARKWHITE|FOREGROUND_INTENSITY)
   674                              <1> BACKGROUND_BLUE		equ 16
   675                              <1> YELLOW_BLUE		equ FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY|BACKGROUND_BLUE
   676                              <1> YELLOW_BLUE_TWICE	equ YELLOW_BLUE| (YELLOW_BLUE<<16)
   677                              <1> LEFT_ALT_PRESSED	equ 2
   678                              <1> CTRL_PRESSED		equ 12
   679                              <1> VK_SPACE		equ 0x0020
   680                              <1> VK_PRIOR		equ 0x0021
   681                              <1> VK_DELETE		equ 0x002E
   682                              <1> CF_OEMTEXT		equ 7
   683                              <1> 
   684                              <1> extern MessageBoxA,MessageBeep,ExitProcess
   685                              <1> extern GetStdHandle,GetCommandLineA,GetLastError,SetConsoleTextAttribute
   686                              <1> extern SetConsoleMode,GetConsoleScreenBufferInfo,SetConsoleCursorPosition
   687                              <1> extern WriteFile,ReadFile,CreateFileA,CloseHandle,SetFilePointer,MoveFileA,DeleteFileA
   688                              <1> extern FillConsoleOutputAttribute,WaitForSingleObject,ReadConsoleA,ReadConsoleInputA
   689                              <1> extern FlushConsoleInputBuffer,WriteConsoleOutputCharacterA,WriteConsoleOutputAttribute
   690                              <1> extern HeapCreate,HeapAlloc,HeapFree,HeapDestroy,OpenClipboard,EmptyClipboard
   691                              <1> extern SetClipboardData,GetClipboardData,IsClipboardFormatAvailable,CloseClipboard
   692                              <1> 	%define W32_EXTENDED_IO
   693                              <1> 	%undef USE_PIPE
   694                              <1> 
   695                              <1> MAXERRNO	equ 32
   696                              <1> ERRNOMEM	equ 8
   697                              <1> ERRNOIO		equ 7
   698                              <1> 
   699                              <1> 	%macro errortext 0
   700                              <1> db "invalid function",10		;1
   701                              <1> db "file not found",10			;2
   702                              <1> db "path not found",10			;3
   703                              <1> db "too many open files",10		;4
   704                              <1> db "access denied",10			;5
   705                              <1> db "invalid handle",10			;6
   706                              <1> db "I/O error",10			;7
   707                              <1> db "not enough memory",10		;8
   708                              <1> db 10					;9
   709                              <1> db 10					;10
   710                              <1> db 10					;11
   711                              <1> db 10					;12
   712                              <1> db 10					;13
   713                              <1> db 10					;14
   714                              <1> db 10					;15
   715                              <1> db 10					;16
   716                              <1> db 10					;17
   717                              <1> db 10					;18
   718                              <1> db 10					;19
   719                              <1> db 10					;20
   720                              <1> db 10					;21
   721                              <1> db 10					;22
   722                              <1> db 10					;23
   723                              <1> db 10					;24
   724                              <1> db 10					;25
   725                              <1> db 10					;26
   726                              <1> db 10					;27
   727                              <1> db 10					;28
   728                              <1> db 10					;29
   729                              <1> db 10					;30
   730                              <1> db 10					;31
   731                              <1> db "sharing violation",10  		;32
   732                              <1> 	%endmacro
   733                              <1> 
   734                              <1> %else		;----------------------- END OS -----------------------
   735                              <1> %error no OS defined
   736                              <1> %endif
   737                              <1> %endif
   738                              <1> %endif
   739                              <1> %endif
   740                              <1> %endif
   741                              <1> %endif
   742                              <1> 
   743                              <1> 
   744                              <1> %ifdef TERMIOS_SET
   745                              <1> %ifdef ARMCPU
   746                              <1>  	struc termios_struc
   747                              <1> .c_iflag:	resd 1
   748                              <1> .c_oflag:	resd 1
   749                              <1> .c_cflag:	resd 1
   750                              <1> .c_lflag:	resd 1
   751                              <1> .c_line:	resb 1
   752                              <1> .c_cc:		resb NCCS
   753                              <1> 	endstruc
   754                              <1> %else
   755                              <1> %define tcflag_t	resd
   756                              <1> %define cc_t		resb
   757                              <1>  	struc termios_struc
   758 00000000 <res 00000004>      <1> .c_iflag:	tcflag_t 1
   759 00000004 <res 00000004>      <1> .c_oflag:	tcflag_t 1
   760 00000008 <res 00000004>      <1> .c_cflag:	tcflag_t 1
   761 0000000C <res 00000004>      <1> .c_lflag:	tcflag_t 1
   762 00000010 <res 00000001>      <1> .c_line:	cc_t 1
   763                              <1> %ifdef speed_t1
   764                              <1> c_ixxxxx:	speed_t1 1
   765                              <1> c_oxxxxx:	speed_t1 1
   766                              <1> %endif
   767 00000011 <res 00000013>      <1> .c_cc:		cc_t NCCS
   768                              <1> %ifdef speed_t2
   769                              <1> res:		resd 3
   770                              <1> c_ixxxxx:	speed_t2 1
   771                              <1> c_oxxxxx:	speed_t2 1
   772                              <1> %endif
   773                              <1> %ifdef speed_t3
   774                              <1> c_ispeed speed_t3 1
   775                              <1> c_ospeed speed_t3 1
   776                              <1> %endif
   777                              <1> 	endstruc
   778                              <1> %endif
   779                              <1> 	struc winsize_struc
   780 00000000 <res 00000002>      <1> .ws_row:resw 1
   781 00000002 <res 00000002>      <1> .ws_col:resw 1
   782 00000004 <res 00000002>      <1> .ws_xpixel:resw 1
   783 00000006 <res 00000002>      <1> .ws_ypixel:resw 1
   784                              <1> 	endstruc
   785                              <1> 
   786                              <1> %ifndef IXON				;all except *BSD
   787                              <1> %define ICRNL	0000400q
   788                              <1> %define IXON	0002000q
   789                              <1> %define ICANON	0000002q
   790                              <1> %define ISIG	0000001q
   791                              <1> %define ECHO	0000010q
   792                              <1> %define TSize   byte
   793                              <1> %endif
   794                              <1> %endif
   795                              <1> 
   796                              <1> ;-------
   797                              <1> %ifndef LINUX
   798                              <1>  %undef CRIPLED_ELF
   799                              <1>  %undef UTF8
   800                              <1> %endif
   801                              <1> ;--------
   802                              <1> ;
   803                              <1> stdtxtlen	equ 10			;do not move this to EOF: code size would increase
   804                              <1> 
   805                              <1> %ifdef FREEBSD
   806                              <1> SIGCONT		equ 19
   807                              <1> SIGSTOP		equ 17
   808                              <1> O_WRONLY_CREAT_TRUNC equ 601h		;see fcntl.h
   809                              <1> %else
   810                              <1> %ifdef QNX
   811                              <1> O_WRONLY_CREAT_TRUNC equ 1401q
   812                              <1> %else
   813                              <1> O_WRONLY_CREAT_TRUNC equ 1101q
   814                              <1> %endif
   815                              <1> %endif
   816                              <1> 
   817                              <1> O_RDONLY	equ 0
   818                              <1> PERMS		equ 644q
   819                              <1> stdin		equ 0
   820                              <1> stdout 		equ 1
   821                              <1> optslen		equ 124
   822                              <1> TAB		equ 8
   823                              <1> TABCHAR		equ 09h
   824                              <1> SPACECHAR	equ ' '
   825                              <1> CHANGED		equ '*'
   826                              <1> UNCHANGED	equ SPACECHAR
   827                              <1> LINEFEED	equ 0ah
   828                              <1> NEWLINE		equ LINEFEED
   829                              <1> RETURN		equ 0dh
   830                              <1> SEDBLOCK	equ 4096
   831                              <1> 
   832                              <1> 
   833                              <1> 
   834                              <1> 
   835                              <1> ;--------------------------------------------------------------------------
   836                              <1> %ifdef CRIPLED_ELF
   837                              <1> ;
   838                              <1> ; building e3 via "nasm -f bin ...."  using an idea from
   839                              <1> ;"A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux"
   840                              <1> ;
   841                              <1>        %macro ELFheader 0
   842                              <1> ehdr:	db 0x7F, "ELF", 1, 1, 1, 0	;Elf32_Ehdr starts here
   843                              <1> 	dd 0,0
   844                              <1> 	dw 2				;e_type
   845                              <1> 	dw 3				;e_machine
   846                              <1> 	dd 1				;e_version
   847                              <1> 	dd _start			;e_entry
   848                              <1> 	dd phdr1- $$			;e_phoff
   849                              <1> 	dd 0				;e_shoff
   850                              <1> 	dd 0				;e_flags
   851                              <1> 	dw ehdrsize			;e_ehsize
   852                              <1> 	dw phdrsize			;e_phentsize
   853                              <1> 	dw 2				;e_phnum
   854                              <1> phdr1:					;Elf32_Phdr starts here
   855                              <1> 	dd 1				;both p_type and e_shentsize,e_shnum
   856                              <1> 	dw 0				;both p_offset and e_shstrndx
   857                              <1> ehdrsize equ $ - ehdr
   858                              <1> 	dw 0
   859                              <1> 	dd $$				;p_vaddr
   860                              <1> 	dd $$				;p_paddr
   861                              <1> 	dd filesize			;p_filesz
   862                              <1> 	dd filesize			;p_memsz
   863                              <1> 	dd 5				;p_flags i.e. READ/EXECUTE
   864                              <1> 	dd 0;  0x1000			;p_align
   865                              <1> phdrsize equ $ - phdr1
   866                              <1> phdr2:					;another Elf32_Phdr starts here
   867                              <1> 	dd 1				;p_type
   868                              <1> 	dd filesize
   869                              <1> 	dd $$+filesize
   870                              <1> 	dd $$+filesize
   871                              <1> 	dd 0				;p_filesz
   872                              <1> 	dd bsssize			;p_memsz
   873                              <1> 	dd 6				;p_flags i.e. READ/WRITE
   874                              <1> 	dd 0;  0x1000			;p_align
   875                              <1> 	%endmacro
   876                              <1> %endif
   877                              <1> ;-------
   878                              <1> %ifndef ARMCPU
   879                              <1> 	%macro ORGheader 0
   880                              <1> %ifdef USE_SPECIAL_HEADER
   881                              <1> %ifdef TINLINK
   882                              <1> 	org 0x800004A			;see file contrib/README.tinlink624
   883                              <1> %else
   884                              <1> 	org 0x8048000
   885                              <1> 	ELFheader
   886                              <1> %endif
   887                              <1> %else
   888                              <1> 	;nothing
   889                              <1> %endif
   890                              <1> 	%endmacro
   891                              <1> %endif
   892                              <1> ;-------
   893                              <1> %ifdef DYN				;DYN == "libc dynamic linked"
   894                              <1>  %define _start main			;call it "main", libc startup code expects this name
   895                              <1> %endif
   896                              <1> 
   897                              <1> ;-------
   898                              <1> %ifdef AMD64
   899                              <1>   %macro PUSH_ALL 0
   900                              <1>   	push rax
   901                              <1> 	push rbx
   902                              <1> 	push rcx
   903                              <1> 	push rdx
   904                              <1> 	push rsi
   905                              <1> 	push rdi
   906                              <1> 	push rbp
   907                              <1>   %endmacro
   908                              <1>   %macro POP_ALL 0
   909                              <1> 	pop  rbp
   910                              <1> 	pop  rdi
   911                              <1> 	pop  rsi
   912                              <1> 	pop  rdx
   913                              <1> 	pop  rcx
   914                              <1> 	pop  rbx
   915                              <1> 	pop  rax
   916                              <1>   %endmacro
   917                              <1> %else
   918                              <1>   %macro PUSH_ALL 0
   919                              <1> 	pusha
   920                              <1>   %endmacro
   921                              <1>   %macro POP_ALL 0
   922                              <1> 	popa
   923                              <1>   %endmacro
   924                              <1> %endif
   925                              <1> ;--------------------------------------------------------------------------
   926                                  ;
   927                                  section .text
   928                                  bits 32
   929                                  	ORGheader
   930                              <1> %ifdef USE_SPECIAL_HEADER
   931                              <1> %ifdef TINLINK
   932                              <1>  org 0x800004A
   933                              <1> %else
   934                              <1>  org 0x8048000
   935                              <1>  ELFheader
   936 00000000 7F454C4601010100    <2> ehdr: db 0x7F, "ELF", 1, 1, 1, 0
   937 00000008 0000000000000000    <2>  dd 0,0
   938 00000010 0200                <2>  dw 2
   939 00000012 0300                <2>  dw 3
   940 00000014 01000000            <2>  dd 1
   941 00000018 [6E000000]          <2>  dd _start
   942 0000001C 2E000000            <2>  dd phdr1- $$
   943 00000020 00000000            <2>  dd 0
   944 00000024 00000000            <2>  dd 0
   945 00000028 3400                <2>  dw ehdrsize
   946 0000002A 2000                <2>  dw phdrsize
   947 0000002C 0200                <2>  dw 2
   948                              <2> phdr1:
   949 0000002E 01000000            <2>  dd 1
   950 00000032 0000                <2>  dw 0
   951                              <2> ehdrsize equ $ - ehdr
   952 00000034 0000                <2>  dw 0
   953 00000036 [00000000]          <2>  dd $$
   954 0000003A [00000000]          <2>  dd $$
   955 0000003E 3B330000            <2>  dd filesize
   956 00000042 3B330000            <2>  dd filesize
   957 00000046 05000000            <2>  dd 5
   958 0000004A 00000000            <2>  dd 0
   959                              <2> phdrsize equ $ - phdr1
   960                              <2> phdr2:
   961 0000004E 01000000            <2>  dd 1
   962 00000052 3B330000            <2>  dd filesize
   963 00000056 [3B330000]          <2>  dd $$+filesize
   964 0000005A [3B330000]          <2>  dd $$+filesize
   965 0000005E 00000000            <2>  dd 0
   966 00000062 ECDC1000            <2>  dd bsssize
   967 00000066 06000000            <2>  dd 6
   968 0000006A 00000000            <2>  dd 0
   969                              <1> %endif
   970                              <1> %else
   971                              <1> 
   972                              <1> %endif
   973                                  global _start
   974                                  ;
   975                                  ; start with OUTER editor loop
   976                                  ;
   977 0000006E E8061B0000              _start:	call SetTermStruc
   978                                  %ifdef SELFTEST
   979                                  	mov eax,mode
   980                                  	mov byte [eax],WS		;store current editor mode:  WS only..
   981                                  	mov esi,pipein			;...because the test file expects WS "syntax"
   982                                  %else
   983                                  %ifdef W32
   984                                  	push byte 0
   985                                  	push dword 8192			;initial size (to be extended)
   986                                  	push byte 0
   987                                  	call HeapCreate
   988                                  	mov [heap],eax
   989                                  ;------
   990                                  	mov eax,mode
   991                                  	mov byte [eax],DEFAULT_MODE	;store default editor mode
   992                                  	call GetCommandLineA		;eax points to  either	D:\PATH\E3.EXE args1 args2 args3...
   993                                  	xchg eax,esi			;               or	"d:\path\e3.exe"
   994                                  	;-- for debug only --		;		or	e3.exe "args"
   995                                  	;PUSH_ALL
   996                                  	;push dword 0			;single OK button
   997                                  	;push dword esi
   998                                  	;push dword esi
   999                                  	;push dword 0
  1000                                  	;call MessageBoxA		;show cmd line
  1001                                  	;POP_ALL
  1002                                  	;--------------------
  1003                                  	cld
  1004                                  	xor ebx,ebx
  1005                                  	cmp byte [esi],'"'		;due above mentined 2 different cmd line ways
  1006                                  	jnz prog
  1007                                  	dec ebx				;ebx -1 due pending '"'
  1008                                  prog:	lodsb
  1009                                  	or al,al
  1010                                  	jz prog9
  1011                                  	cmp al,SPACECHAR		;TODO chk TABs
  1012                                  	ja prog
  1013                                  	inc esi
  1014                                  prog9:	dec esi
  1015                                  prog0:	push esi
  1016                                  	lea esi,[esi+ebx-4-5]		;-4 due suffix ".exe"
  1017                                  	call SetEditMode
  1018                                  	jz prog1
  1019                                  	mov byte [eax],DEFAULT_MODE	;store current editor mode
  1020                                  prog1:	pop esi
  1021                                  	xor edx,edx			;no args
  1022                                  prog2:	lodsb
  1023                                  	or al,al
  1024                                  	jz prog3
  1025                                  	cmp al,SPACECHAR
  1026                                  	jbe prog2
  1027                                  	dec esi
  1028                                  	jmp short prog5
  1029                                  prog3:	mov esi,edx
  1030                                  prog5:
  1031                                  %else
  1032                                  %ifdef BEOS ;-----------------------------------------------------------
  1033                                  	pop eax
  1034                                  	pop ebx				;args counter (1....x)
  1035                                  	pop esi
  1036                                  	mov esi,[esi]			;points to our_name0[args]0env.....
  1037                                  	cld
  1038                                  prog:	lodsb
  1039                                  	or al,al
  1040                                  	jne prog
  1041                                  	mov edx,esi			;store arg ptr
  1042                                  	lea esi,[esi-5]
  1043                                  	call SetEditMode
  1044                                  	jz prog1
  1045                                  	mov byte [eax],DEFAULT_MODE	;store current editor mode
  1046                                  prog1:	xor esi,esi			;init for 'no args'
  1047                                  	dec ebx
  1048                                  	jz noarg
  1049                                  	mov esi,edx
  1050                                  noarg:
  1051                                  %else
  1052                                  %ifdef DYN ;------------------------------------------------------------
  1053                                  ; This is to be called from dynamic linked libc startup code 
  1054                                  ; just like you would expect:  int main(int argc,char**argv)
  1055                                  ; (for experimental purpose only)
  1056                                  ;
  1057                                  	xor esi,esi			;init to "no args"
  1058                                  	mov ecx,[esp+4]			;"int argc"
  1059                                  	cmp ecx,1
  1060                                  	je NoArg
  1061                                  	mov esi,[esp+8]			;"char**argv"
  1062                                  	mov esi,[esi]
  1063                                  	cld
  1064                                  Argl:	lodsb
  1065                                  	or al,al
  1066                                  	jne Argl
  1067                                  NoArg:	mov eax,mode
  1068                                  	mov byte [eax],DEFAULT_MODE	;store current editor mode (WS only)
  1069                                  %undef CURSORMGNT
  1070                                  %else	;-------------- i.e. Linux, FreeBSD, QNX, Ath ------------------
  1071                                  %ifdef SYS_rt_sigaction
  1072 00000073 E8ED1B0000              	call SetSigHandler
  1073                                  %else
  1074                                  %ifdef SYS_sigaction
  1075                                  	call SetSigHandler
  1076                                  %endif
  1077                                  %endif
  1078                                  ;-------
  1079                                  %ifdef ATHEOS
  1080                                  	pop edx
  1081                                  	pop edx
  1082                                  	pop edx
  1083                                  %endif
  1084 00000078 5A                      	pop edx				;Linux: arguments #
  1085 00000079 5E                      	pop esi				;Linux: argv[0]
  1086 0000007A FC                      	cld
  1087 0000007B AC                      prog:	lodsb
  1088 0000007C 08C0                    	or al,al
  1089 0000007E 75FB                    	jne prog			;get program name
  1090                                  %ifdef AMD64
  1091                                  	lea rsi,[rsi-5]
  1092                                  %else
  1093 00000080 8D76FB                  	lea esi,[esi-5]
  1094                                  %endif
  1095 00000083 E89C1A0000              	call SetEditMode
  1096 00000088 7403                    	jz prog1
  1097 0000008A C60008                  	mov byte [eax],DEFAULT_MODE	;store current editor mode
  1098                                  prog1:
  1099                                  ;-------
  1100 0000008D 5E                      	pop esi				;Linux: esi points to first arg (filename)
  1101                                  %ifdef NEW_CURSOR_MGNT
  1102 0000008E E81C1B0000              	call SetCursorBlock
  1103                                  %endif
  1104                                  %endif
  1105                                  %endif
  1106                                  %endif
  1107                                  %endif
  1108                                  ;-------
  1109                                  %ifdef CURSORMGNT
  1110                                  	or esi,esi
  1111                                  	jz moreenv
  1112                                  morearg:pop ecx				;arguments until NULL
  1113                                  	or ecx,ecx
  1114                                          jnz morearg
  1115                                  ;-------
  1116                                  moreenv:pop ecx
  1117                                  	jecxz ReStart
  1118                                  %ifndef ARMCPU
  1119                                  	cmp dword[ecx],'TERM'		;a short test for "TERM=linux"
  1120                                  	jnz moreenv
  1121                                  	cmp dword[ecx+5],'linu'
  1122                                  %else
  1123                                  	cmp byte[ecx],'T'
  1124                                  	jnz moreenv
  1125                                  	cmp byte[ecx+1],'E'
  1126                                  	jnz moreenv
  1127                                  	cmp byte[ecx+2],'R'
  1128                                  	jnz moreenv
  1129                                  	cmp byte[ecx+3],'M'
  1130                                  	jnz moreenv
  1131                                  	cmp byte[ecx+5],'l'
  1132                                  	jnz ReStart
  1133                                  	cmp byte[ecx+6],'i'
  1134                                  	jnz ReStart
  1135                                  	cmp byte[ecx+7],'n'
  1136                                  	jnz ReStart
  1137                                  	cmp byte[ecx+8],'u'
  1138                                  %endif
  1139                                  	jnz ReStart
  1140                                  	add byte[revvoff],boldlen	;special inverse cursor on linux terminals
  1141                                  %endif
  1142                                  %ifdef UTF8RTS
  1143                                  	mov ecx,getPos 			;second argument: pointer to message to write
  1144                                  	push byte gPlen			;third argument: message length
  1145                                  	pop edx
  1146                                  	call WriteFile0
  1147                                  	mov ecx,screenbuffer		;pointer to buf
  1148                                  	push byte 10
  1149                                  	pop edx
  1150                                  	call ReadFile0			;get cursor pos
  1151                                  	mov al,[ecx+eax-2]		;al == '2' @ UTF8 terminal,  else al == '3'
  1152                                  	sub al,'3'
  1153                                  	mov byte [isUTF8],al
  1154                                  %endif
  1155                                  ;-------
  1156 00000093 E815150000              ReStart:call NewFile
  1157 00000098 7248                    	jc E3exit
  1158 0000009A E8421D0000              MainCharLoop:call ChkCursPos
  1159 0000009F E84A0A0000              	call IsViMode
  1160 000000A4 751C                    	jnz MCL
  1161 000000A6 8B0D[182F0100]          	mov ecx,[blockbegin]
  1162 000000AC E314                    	jecxz MCL
  1163 000000AE 57                      	push edi
  1164 000000AF 89CF                    	mov edi,ecx			;for vi only: keep Begin/End-line marker together
  1165 000000B1 E8EC090000              	call KeyEnd
  1166                                  	; <------prev line------------>
  1167                                  	; BegM......marker line........EndM
  1168                                  	; <-------next line----------->
  1169 000000B6 893D[1C2F0100]          	mov [blockende],edi		;set WS's "blockende" to one after EOL for VI marker
  1170 000000BC 5F                      	pop edi
  1171 000000BD E80A070000              	call ShowBl1			;i.e. "mov byte [showblock],1"
  1172                                  ;-------
  1173 000000C2 E8370A0000              MCL:	call DispNewScreen
  1174 000000C7 E8E1160000              	call RestoreStatusLine
  1175 000000CC E83E000000              	call HandleChar
  1176                                  %ifdef W32LF
  1177                                  	cmp byte [edi],RETURN		;never stay at character 0dh
  1178                                  	jnz MCL2
  1179                                  	inc edi				;(rather stay at following 0ah)
  1180                                  MCL2:
  1181                                  %endif
  1182 000000D1 BB[202F0100]            	mov ebx,endeedit
  1183 000000D6 803B00                  	cmp byte [ebx],0
  1184 000000D9 74BF                    	je MainCharLoop
  1185 000000DB 31F6                    	xor esi,esi			;just like if no arg is present
  1186 000000DD 803B02                  	cmp byte [ebx],2
  1187 000000E0 74B1                    	je ReStart			;^KD repeat edit using another file
  1188 000000E2 E8EC110000              E3exit:	call KursorStatusLine
  1189                                  %ifdef W32
  1190                                  	push dword w32result		;reset all to standard colors
  1191                                  	push byte 0
  1192                                  	mov eax,[lines]
  1193                                  	inc eax
  1194                                  	mov ebx,[columns]
  1195                                  	mul bl
  1196                                  	push eax
  1197                                  	push byte DARKWHITE		;equ 7
  1198                                  	push dword [hout]
  1199                                  	call FillConsoleOutputAttribute
  1200                                  %endif
  1201 000000E7 B9[EC3C0100]            	mov ecx,text			;enter next line on terminal NEWLINE is @ byte [text]
  1202 000000EC E8E21A0000              	call WriteFile00
  1203                                  %ifdef NEW_CURSOR_MGNT
  1204 000000F1 E8AF1A0000              	call SetCursorNormal
  1205                                  %endif
  1206                                  ;-------
  1207 000000F6 BB[79220000]            	mov ebx,tempfile2		;undo info (if exist)
  1208 000000FB E8531B0000              	call Unlink
  1209                                  %ifdef W32
  1210                                  	push dword [heap]
  1211                                  	call HeapDestroy
  1212                                  	push byte 0			;return code
  1213                                  	call ExitProcess		;Ready&Exit
  1214                                  %else
  1215 00000100 B902540000              	mov ecx,TERMIOS_SET 
  1216 00000105 E8B51A0000              	call IOctlTerminal0		;restore termios settings
  1217 0000010A E9F51A0000              	jmp Exit
  1218                                  %endif
  1219                                  ;----------------------------------------------------------------------
  1220                                  ;
  1221                                  ; MAIN function for processing keys
  1222                                  ;
  1223 0000010F E82F0E0000              HandleChar:call ReadChar
  1224 00000114 80FCFF                  	cmp ah,0xFF			;normal chars get 0xFF in ah
  1225 00000117 0F8527010000            	jne near ExtAscii		;go handling Cursor-Keys
  1226 0000011D BE[A0380100]            	mov esi,mode
  1227 00000122 F60606                  	test byte [esi], EM | PI
  1228 00000125 741A                    	jz NO_EM01
  1229 00000127 3C0B                    	cmp al,11
  1230 00000129 7407                    	je IsCtrlK
  1231 0000012B C605[78380100]00        	mov byte [EmaCtrlK],0
  1232 00000132 3C13                    IsCtrlK:cmp al,13h			;^S
  1233 00000134 740B                    	je IsCtrlS
  1234 00000136 3C12                    	cmp al,12h			;^R
  1235 00000138 7407                    	je IsCtrlS
  1236 0000013A C605[79380100]00        	mov byte [EmaCtrlS],0
  1237                                  IsCtrlS:
  1238 00000141 803E08                  NO_EM01:cmp byte [esi],VI
  1239 00000144 7426                    	jz ISVI1
  1240 00000146 3C20                    	cmp al,32			;in WS,EM,PI,NE: handle control chars
  1241 00000148 733A                    	jae NormChar
  1242 0000014A 88C3                    	mov bl,al
  1243 0000014C 80C355                  	add bl,jumps1
  1244 0000014F 803E01                  	cmp byte [esi],WS
  1245 00000152 7413                    	je CJump
  1246 00000154 80C320                  	add bl,32
  1247 00000157 803E02                  	cmp byte [esi],EM
  1248 0000015A 740B                    	je CJump
  1249 0000015C 80C320                  	add bl,32
  1250 0000015F 803E04                  	cmp byte [esi],PI
  1251 00000162 7403                    	je CJump
  1252 00000164 80C320                  	add bl,32
  1253 00000167 E9E6000000              CJump:	jmp CompJump2
  1254                                  ISVI1:					;in VI: most control is done in command mode...
  1255 0000016C 3C07                    	cmp al,7			;... so maintaining another table for <Return>...
  1256 0000016E 0F848E020000            	je near KeyDel			;... <Del> and <DelLeft> is useless
  1257 00000174 3C08                    	cmp al,8
  1258 00000176 0F847F020000            	je near KeyDell
  1259 0000017C 3C0D                    	cmp al,RETURN
  1260 0000017E 0F8414010000            	je near KeyRet
  1261                                  ;-------
  1262 00000184 F605[A0380100]06        NormChar:test byte [mode], EM | PI
  1263 0000018B 7405                    	jz NOEM0
  1264 0000018D E842060000              	call ShowBl0			;i.e. "mov byte [showblock],0"
  1265                                  NOEM0:	
  1266                                  %ifdef UTF8
  1267                                  %ifdef UTF8RTSx_wont			;won't overwrite more than one single ASCII byte at once...
  1268                                  	cmp byte [isUTF8],0		;...with a 2- or 3-byte UTF-8 character entered from keyboard.
  1269                                  	je noUTF_A			;So @ non-UTF8 consoles byte 2,3,... are always inserted.
  1270                                  %endif
  1271 00000192 88C3                    	mov bl,al
  1272 00000194 80E3C0                  	and bl,0C0h
  1273 00000197 80FB80                  	cmp bl,080h			;byte 2,3,4.. always insert
  1274 0000019A 740E                    	je NormCh2
  1275                                  noUTF_A:
  1276                                  %endif
  1277 0000019C E8EE0F0000              	call CheckMode
  1278                                  %ifdef USE_UNDO
  1279 000001A1 7407                    	jz NormCh2
  1280 000001A3 E8B01F0000              	call DataForUndoOverwrite
  1281 000001A8 EB09                    	jmp short OverWriteChar
  1282                                  %else
  1283                                  	jnz OverWriteChar
  1284                                  %endif	
  1285 000001AA 50                      NormCh2:push eax
  1286                                  %ifdef W32LF
  1287                                  	call CheckEof
  1288                                  	jz noEOL
  1289                                  	cmp word [edi-1],RETURN|(NEWLINE<<8)
  1290                                  	jnz noEOL
  1291                                  	dec edi				;move back to 0Dh
  1292                                  noEOL:
  1293                                  %endif
  1294 000001AB E8F0110000              	call Insert1Byte
  1295 000001B0 58                      	pop eax
  1296 000001B1 721D                    	jc InsWriteEnd			;error: text buffer full
  1297 000001B3 FC                      OverWriteChar:cld
  1298 000001B4 AA                      	stosb
  1299                                  %ifdef UTF8
  1300                                  %ifdef UTF8RTSx_wont			;won't produce incomplete UTF8 characters: ....
  1301                                  	cmp byte [isUTF8],0		;...so one single ASCII will overwrite a complete...
  1302                                  	je noUTF_B			;...UTF8 byte sequence at once.
  1303                                  %endif
  1304 000001B5 31C0                    	xor eax,eax
  1305 000001B7 48                      	dec eax
  1306 000001B8 40                      OWCloopUTF8:inc eax
  1307 000001B9 8A1C07                  	mov bl,byte [edi+eax]
  1308 000001BC 80E3C0                  	and bl,0C0h
  1309 000001BF 80FB80                  	cmp bl,080h			;delete byte 2,3,4,....
  1310 000001C2 74F4                    	je OWCloopUTF8
  1311 000001C4 E8AD110000              	call DeleteByte
  1312                                  noUTF_B:
  1313                                  %endif
  1314 000001C9 C605[0C2F0100]2A        SetChg:	mov byte [changed],CHANGED
  1315 000001D0 C3                      InsWriteEnd:ret
  1316                                  ;-------
  1317 000001D1 E87A0E0000              KeyVICmdr:call ReadOneChar		;repl one char (except newline)
  1318 000001D6 803F0A                  	cmp byte [edi],NEWLINE
  1319 000001D9 74F5                    	je InsWriteEnd
  1320 000001DB 3C0D                    	cmp al,RETURN
  1321 000001DD 7502                    	jnz KeyVICmdr1
  1322 000001DF B00A                    	mov al,NEWLINE
  1323                                  KeyVICmdr1:
  1324                                  %ifdef USE_UNDO
  1325 000001E1 E8721F0000              	call DataForUndoOverwrite
  1326                                  %endif	
  1327 000001E6 8807                    KeyVICmdr2:mov byte [edi],al
  1328 000001E8 EBDF                    	jmp short SetChg
  1329                                  ;-------
  1330 000001EA BE[08230000]            KeyEmaCtrlQ:mov esi,asknumber
  1331 000001EF E87F180000              	call GetOctalToInteger
  1332 000001F4 76DA                    	jbe InsWriteEnd
  1333 000001F6 91                      	xchg eax,ecx			;using decimal input for ASCII value
  1334 000001F7 3D00010000              	cmp eax,256
  1335 000001FC 72AC                    	jb NormCh2
  1336 000001FE C3                      	ret
  1337                                  ;-------
  1338                                  ;
  1339                                  ; helper for HandleChar
  1340                                  ;
  1341 000001FF BB[C7230000]            CtrlKMenu:mov ebx,Ktable
  1342 00000204 B04B                    	mov al,'K'
  1343 00000206 EB20                    	jmp short Menu
  1344 00000208 BB[E2230000]            CtrlQMenu:mov ebx,Qtable
  1345 0000020D EB0E                    	jmp short PicoQM
  1346 0000020F BB[18240000]            PicoJMenu:mov ebx,PicoJtable
  1347 00000214 B04A                    	mov al,'J'
  1348 00000216 EB10                    	jmp short Menu
  1349 00000218 BB[33240000]            PicoQMenu:mov ebx,PicoQtable
  1350 0000021D B051                    PicoQM:	mov al,'Q'
  1351 0000021F EB07                    	jmp short Menu
  1352 00000221 BB[FD230000]            CtrlXMenu:mov ebx,Xtable
  1353 00000226 B058                    	mov al,'X'
  1354 00000228 B95E202020              Menu:	mov ecx,2020205eh
  1355 0000022D 88C5                    	mov ch,al
  1356                                  ;-------
  1357 0000022F E8BE0A0000              MakeScanCode:call WriteTwo		;ebx expects xlat-table
  1358 00000234 53                      	push ebx
  1359 00000235 E8160D0000              	call GetChar
  1360 0000023A 5B                      	pop ebx
  1361 0000023B 241F                    	and al,01fh
  1362 0000023D 3C1B                    	cmp al,Ktable_size
  1363 0000023F 738F                    	jnb InsWriteEnd			;if no valid scancode
  1364 00000241 D7                      	xlatb
  1365 00000242 88C4                    	mov ah,al			;=pseudo "scancode"
  1366                                  ;------- cont
  1367 00000244 88E3                    ExtAscii:mov bl,ah			;don't use al (carries char e.g. TAB)
  1368 00000246 80FB55                  	cmp bl,jumps1
  1369 00000249 7385                    	jae InsWriteEnd
  1370 0000024B 31C0                    	xor eax,eax
  1371 0000024D A3[78380100]            	mov [EmaCtrl],eax
  1372 00000252 B700                    CompJump2:mov bh,0
  1373                                  %ifdef YASM
  1374                                  	and ebx,0ffh
  1375                                  %else
  1376 00000254 678D1F                  	lea ebx,[bx]			;1 byte shorter than 'and ebx,0ffh'
  1377                                  %endif
  1378 00000257 0FB79C1B[4E240000]      	movzx ebx,word [2*ebx+jumptab1] ;2*ebx is due 2 byte per entry
  1379                                  ;;;%ifdef YASM
  1380                                  ;;;%ifdef AMD64
  1381                                  ;;;	add rbx,0x400000b0
  1382                                  ;;;%else
  1383                                  ;;;	add ebx,0x08048080		;most ugly work around ever written
  1384                                  ;;;%endif
  1385                                  ;;;%else
  1386 0000025F 81C3[6E000000]          	add ebx,_start			;offset inside code
  1387                                  ;;;%endif
  1388                                  ;-------
  1389 00000265 FFD3                    	call ebx			;the general code jump dispatcher
  1390                                  ;-------
  1391 00000267 803D[482F0100]01        	cmp byte [numeriere],1		;after return from functions...
  1392 0000026E 7523                    	jnz BZNret			;...decide whether count current line number
  1393 00000270 57                      	push edi
  1394 00000271 BE[ED3C0100]            	mov esi,sot
  1395 00000276 87F7                    	xchg esi,edi
  1396 00000278 31D2                    	xor edx,edx
  1397 0000027A 42                      BZNLoop:inc edx				;edx=linenr counter
  1398 0000027B E8220E0000              	call LookForward
  1399 00000280 47                      	inc edi				;point to start of next line
  1400 00000281 39F7                    	cmp edi,esi
  1401 00000283 76F5                    	jbe BZNLoop
  1402 00000285 8915[2C2F0100]          	mov [linenr],edx
  1403 0000028B 5F                      	pop edi
  1404 0000028C C605[482F0100]00        	mov byte [numeriere],0
  1405 00000293 C3                      BZNret:	ret
  1406                                  ;----------------------------------------------------------------------
  1407                                  ;
  1408                                  ; processing special keys: cursor, ins, del
  1409                                  ;
  1410 00000294 31C0                    KeyRetNoInd:xor eax,eax
  1411 00000296 EB28                    	jmp short KeyRetNInd
  1412                                  KeyRet:	
  1413                                  ;;; %define NO_AUTO_INDENT		;for Izzy
  1414                                  %ifndef NO_AUTO_INDENT
  1415                                  %ifdef SELFTEST
  1416                                  	xor eax,eax
  1417                                  %else
  1418 00000298 E8F20E0000              	call CheckMode
  1419 0000029D 7542                    	jnz  OvrRet
  1420 0000029F E8420F0000              	call CountToLineBegin		;set esi / returns eax
  1421 000002A4 46                      	inc esi
  1422 000002A5 46                      	inc esi
  1423 000002A6 09C0                    	or eax,eax
  1424 000002A8 7416                    	jz KeyRetNInd
  1425 000002AA 89C3                    	mov ebx,eax	
  1426 000002AC 31C0                    	xor eax,eax
  1427 000002AE 48                      	dec eax
  1428 000002AF 40                      KeyRetSrch:inc eax			;search non (SPACE or TABCHAR)
  1429 000002B0 39D8                    	cmp eax,ebx
  1430 000002B2 730C                    	jae KeyRetNInd
  1431 000002B4 803C0620                	cmp byte [esi+eax],SPACECHAR
  1432 000002B8 74F5                    	je KeyRetSrch
  1433 000002BA 803C0609                	cmp byte [esi+eax],TABCHAR
  1434 000002BE 74EF                    	je KeyRetSrch
  1435                                  %endif
  1436                                  %else
  1437                                  	xor eax,eax
  1438                                  %endif
  1439 000002C0 56                      KeyRetNInd:push esi
  1440 000002C1 50                      	push eax			;eax is 0 or =indented chars
  1441 000002C2 E8B30F0000              	call GoDown
  1442 000002C7 58                      	pop eax
  1443 000002C8 50                      	push eax
  1444                                  %ifdef W32LF
  1445                                  	inc eax				;1 extra for RETURN
  1446                                  	call CheckEof
  1447                                  	jz noEOL2
  1448                                  	cmp word [edi-1],RETURN|(NEWLINE<<8)
  1449                                  	jnz noEOL2
  1450                                  	dec edi				;move back to 0Dh
  1451                                  noEOL2:
  1452                                  %endif
  1453 000002C9 E8D4100000              	call InsertByte0		;1 extra for NEWLINE
  1454 000002CE 59                      	pop ecx				;# blanks
  1455 000002CF 5E                      	pop esi				;where to copy
  1456 000002D0 720E                    	jc SimpleRet
  1457 000002D2 FF05[2C2F0100]          	inc dword [linenr]
  1458 000002D8 FC                      	cld
  1459                                  %ifdef W32LF
  1460                                  	mov ax,RETURN|(NEWLINE<<8)	;insert 0d0ah combination
  1461                                  	stosw
  1462                                  %else
  1463 000002D9 B00A                    	mov al,NEWLINE
  1464 000002DB AA                      	stosb
  1465                                  %endif
  1466 000002DC E302                    	jecxz SimpleRet
  1467 000002DE F3A4                    	rep movsb			;copy upper line i.e. SPACES,TABS into next
  1468 000002E0 C3                      SimpleRet:ret
  1469 000002E1 31C0                    OvrRet:	xor eax,eax
  1470 000002E3 A3[442F0100]            	mov [ch2linebeg],eax
  1471 000002E8 EB05                    	jmp short DownRet
  1472                                  ;-------
  1473 000002EA E8C00E0000              KeyDown:call CountColToLineBeginVis
  1474 000002EF E8860F0000              DownRet:call GoDown
  1475 000002F4 E8FA0D0000              	call LookLineDown
  1476 000002F9 EB4B                    	jmp short JmpSC
  1477                                  ;-------
  1478 000002FB E8760F0000              KeyUp:	call GoUp
  1479 00000300 E8AA0E0000              	call CountColToLineBeginVis
  1480 00000305 E8DE0D0000              	call LookLineUp
  1481 0000030A EB3A                    	jmp short JmpSC
  1482                                  ;-------
  1483 0000030C E89E0E0000              KeyHalfPgUp:call CountColToLineBeginVis
  1484 00000311 E80C0E0000              	call LookHalfPgUp
  1485 00000316 EB3A                    	jmp short SetColumn
  1486                                  ;-------
  1487 00000318 E8920E0000              KeyHalfPgDn:call CountColToLineBeginVis
  1488 0000031D E80B0E0000              	call LookHalfPgDn
  1489 00000322 EB2E                    	jmp short SetColumn
  1490                                  ;-------
  1491 00000324 E8860E0000              KeyScrollUp:call CountColToLineBeginVis
  1492 00000329 E8EF0D0000              	call LookScrUp
  1493 0000032E EB22                    	jmp short SetColumn
  1494 00000330 E87A0E0000              KeyScrollDn:call CountColToLineBeginVis
  1495 00000335 E8DE0D0000              	call LookScrDn
  1496 0000033A EB16                    	jmp short SetColumn
  1497                                  ;-------
  1498 0000033C E86E0E0000              KeyPgUp:call CountColToLineBeginVis
  1499 00000341 E8B80D0000              	call LookPageUp
  1500 00000346 EB0A                    JmpSC:	jmp short SetColumn
  1501                                  ;-------
  1502 00000348 E8620E0000              KeyPgDn:call CountColToLineBeginVis
  1503 0000034D E8E60D0000              	call LookPgDown			;1st char last line
  1504 00000352 8B0D[442F0100]          SetColumn:mov ecx,[ch2linebeg]		;=maximal columns
  1505 00000358 31D2                    	xor edx,edx			;counts visible columns i.e. expand TABs
  1506 0000035A 4F                      	dec edi
  1507 0000035B 47                      SCloop:	inc edi
  1508                                  %ifdef UTF8
  1509                                  %ifdef UTF8RTS
  1510                                  	cmp byte [isUTF8],0		;if the tty can't handle UTF8..
  1511                                  	je noUTF_C			;..each byte is one column
  1512                                  %endif
  1513 0000035C 8A1F                    	mov bl,byte [edi]
  1514 0000035E 80E3C0                  	and bl,0C0h
  1515 00000361 80FB80                  	cmp bl,080h			;do not count byte 2,3,4,.. for columns in UTF8 chars
  1516 00000364 74F5                    	jz SCloop
  1517                                  noUTF_C:
  1518                                  %endif
  1519 00000366 39CA                    	cmp edx,ecx			;from CountColToLineBeginVis
  1520 00000368 7318                    	jae SCret
  1521 0000036A 803F0A                  	cmp byte [edi],NEWLINE		;don't go beyond line earlier line end
  1522 0000036D 7413                    	jz SCret
  1523 0000036F 803F09                  	cmp byte [edi],TABCHAR
  1524 00000372 7403                    	jz SCtab
  1525 00000374 42                      	inc edx				;count columns
  1526 00000375 EBE4                    	jmp short SCloop
  1527 00000377 E835170000              SCtab:	call SpacesForTab
  1528 0000037C 00E2                    	add dl,ah
  1529 0000037E 39CA                    	cmp edx,ecx			;this tab to far away right?
  1530 00000380 76D9                    	jna SCloop			;no
  1531 00000382 C3                      SCret:	ret
  1532                                  ;----------------------------------------------------------------------
  1533                                  ;
  1534                                  ; a helper for d'a and y'a vi commands
  1535                                  ; have to differ whether cursor is below or above the marked line
  1536                                  ; (at all this line based concept does not fit very well into e3)
  1537                                  ; expects:
  1538                                  ;	ecx valid begin of marked line
  1539                                  ;	edi cursor
  1540 00000383 39CF                    VIsetMarker:cmp edi,ecx
  1541 00000385 771A                    	ja Marker_above_cursor
  1542                                  	; X........cursor line.......
  1543                                  	; ...........................
  1544                                  	; .........marker line.......
  1545                                  	; Y
  1546 00000387 8B0D[1C2F0100]          	mov ecx,[blockende]
  1547 0000038D 41                      	inc ecx
  1548 0000038E 39E9                    	cmp ecx,ebp
  1549 00000390 7201                    	jb Mbel
  1550 00000392 49                      	dec ecx
  1551 00000393 890D[74380100]          Mbel:	mov dword [EmaMark],ecx		;i.e. store point Y
  1552                                  ;------- cont
  1553 00000399 E8480E0000              KeyHome:call CountToLineBegin		;i.e. goto point X
  1554 0000039E 29C7                    	sub edi,eax
  1555 000003A0 C3                      	ret
  1556                                  ;-------
  1557                                  Marker_above_cursor:
  1558                                  	; Y.......marker line .......	
  1559                                  	; ...........................
  1560                                  	; ........cursor line........
  1561                                  	; X				;								
  1562 000003A1 890D[74380100]          	mov dword [EmaMark],ecx		;i.e. store point Y
  1563 000003A7 E8F6060000              	call KeyEnd
  1564 000003AC 47                      	inc edi				;i.e. goto point X
  1565 000003AD 39EF                    	cmp edi,ebp
  1566 000003AF 7201                    	jb Mret
  1567 000003B1 4F                      	dec edi
  1568 000003B2 C3                      Mret:	ret
  1569                                  ;----------------------------------------------------------------------
  1570 000003B3 F615[582F0100]          KeyIns:	not byte [insstat]
  1571 000003B9 31C0                    	xor eax,eax
  1572 000003BB E82E070000              	call IsViMode
  1573 000003C0 7513                    	jnz KeyIns2
  1574 000003C2 40                      	inc eax
  1575 000003C3 3805[80380100]          	cmp byte [VICmdMode],al
  1576 000003C9 750A                    	jne KeyIns2
  1577 000003CB A2[582F0100]            	mov byte [insstat],al
  1578 000003D0 E880060000              	call KeyVImode0
  1579 000003D5 E81C070000              KeyIns2:call IsEmMode
  1580 000003DA 7505                    	jnz KeyIns3
  1581 000003DC A2[302F0100]            	mov byte [showblock],al
  1582                                  KeyIns3:
  1583                                  %ifdef NEW_CURSOR_MGNT
  1584 000003E1 803D[582F0100]01        	cmp byte [insstat],1
  1585 000003E8 0F85B7170000            	jne near SetCursorNormal
  1586 000003EE E9BC170000              	jmp SetCursorBlock
  1587                                  %endif
  1588 000003F3 C3                      	ret
  1589                                  ;-------
  1590 000003F4 E8A9060000              KeyVICmdJ:call KeyEnd
  1591 000003F9 EB07                    	jmp short KeyDel
  1592                                  ;-------
  1593 000003FB E877060000              KeyDell:call KeyLeft
  1594 00000400 7430                    	jz KeyDell2
  1595 00000402 39EF                    KeyDel:	cmp edi,ebp
  1596 00000404 73DB                    	jnb KeyIns3
  1597 00000406 31C0                    	xor eax,eax			;delete one @ cursor
  1598 00000408 40                      KDloopUTF8:inc eax
  1599                                  %ifdef UTF8
  1600                                  %ifdef UTF8RTSx_wont			;won't produce incomplete UTF8 characters: ....
  1601                                  	cmp byte [isUTF8],0		;...so pressing DEL single will delete a complete..
  1602                                  	je noUTF_D			...UTF8 byte sequence at once.
  1603                                  %endif
  1604 00000409 8A1C07                  	mov bl,byte [edi+eax]
  1605 0000040C 80E3C0                  	and bl,0C0h
  1606 0000040F 80FB80                  	cmp bl,080h
  1607 00000412 74F4                    	je KDloopUTF8			;delete one more at UTF-8 byte 2,3,4,....
  1608                                  noUTF_D:
  1609                                  %endif
  1610                                  %ifdef W32LF
  1611                                  	cmp byte [edi-1],RETURN
  1612                                  	jnz KD2
  1613                                  	dec edi				;delete one more
  1614                                  	inc eax
  1615                                  KD2:
  1616                                  %endif
  1617                                  ;-------
  1618 00000414 E8D5060000              	call IsViMode
  1619 00000419 0F85570F0000            	jne near DeleteByte
  1620 0000041F 89FE                    	mov esi,edi			;make vi's x and X pasteable
  1621 00000421 C605[88380100]01        	mov byte [VInolinebased],1
  1622 00000428 E8B9100000              	call KeyEmaAltW2
  1623 0000042D E9440F0000              	jmp DeleteByte
  1624                                  ;-------	
  1625 00000432 81FF[ED3C0100]          KeyDell2:cmp edi,sot			;delete newline char
  1626 00000438 76A7                    	jbe KeyIns3
  1627 0000043A FF0D[2C2F0100]          	dec dword [linenr]
  1628 00000440 4F                      	dec edi
  1629 00000441 E9A4020000              	jmp KeyCtrlT1
  1630                                  ;-------
  1631                                  KeyEmaCtrlT:
  1632                                  %ifdef UTF8
  1633 00000446 C3                      	ret				;FIXME!!
  1634                                  %else
  1635                                  	cmp edi,sot			;xchg 2 chars
  1636                                  	jbe KeyRightEnd
  1637                                  	cmp byte [edi],NEWLINE
  1638                                  	jnz KECT
  1639                                  	dec edi
  1640                                  KECT:	
  1641                                  %ifdef USE_UNDO
  1642                                  	call DataForUndoXchange
  1643                                  %endif	
  1644                                  	mov al,byte [edi]
  1645                                  	xchg al,byte [edi-1]
  1646                                  	call KeyVICmdr2			;mov byte [edi],al / mov byte [changed],CHANGED
  1647                                  %endif
  1648                                  ;-------
  1649                                  KeyRight:
  1650                                  %ifdef UTF8
  1651                                  %ifdef UTF8RTSx_wont			;try to keep UTF8 bytes together..
  1652                                  	cmp byte [isUTF8],0		;...also if the console can not display the UTF8 character
  1653                                  	je noUTF_E
  1654                                  %endif
  1655 00000447 47                      	inc edi
  1656 00000448 8A07                    	mov al,byte [edi]		;check for UTF byte 2,3,4,..
  1657 0000044A 24C0                    	and al,0c0h
  1658 0000044C 3C80                    	cmp al,080h
  1659 0000044E 74F7                    	je KeyRight
  1660 00000450 4F                      	dec edi				;due inc edi above
  1661                                  noUTF_E:
  1662                                  %endif
  1663 00000451 803F0A                  	cmp byte [edi],NEWLINE
  1664 00000454 7518                    	jnz KeyRNoMargin
  1665 00000456 E85B0C0000              	call CheckEof
  1666 0000045B 7312                    	jae KeyRightEnd
  1667 0000045D E88C060000              	call IsViMode
  1668 00000462 740B                    	je KeyRightEnd			;no more line wrap around in vi mode
  1669 00000464 E85B0C0000              	call CheckENum			;Sun Feb 20 2005
  1670 00000469 E80C0E0000              	call GoDown
  1671 0000046E 47                      KeyRNoMargin:inc edi
  1672 0000046F C3                      KeyRightEnd:ret
  1673                                  ;-------
  1674 00000470 81FF[ED3C0100]          KeyCLeft3:cmp edi,sot
  1675 00000476 7618                    	jbe KeyCLEnd
  1676 00000478 E8470C0000              	call CheckENum			;Sun Feb 20 2005
  1677 0000047D 4F                      	dec edi
  1678 0000047E 807FFF0A                KeyCtrlQW:cmp byte [edi-1],NEWLINE
  1679 00000482 74EC                    	jz KeyCLeft3
  1680 00000484 4F                      	dec edi
  1681 00000485 803F2F                  	cmp byte [edi],2fh
  1682 00000488 76F4                    	jbe KeyCtrlQW
  1683 0000048A 807FFF2F                	cmp byte [edi-1],2fh
  1684 0000048E 77EE                    	ja KeyCtrlQW
  1685 00000490 C3                      KeyCLEnd:ret
  1686                                  ;-------
  1687 00000491 E8200C0000              KeyCRight3:call CheckEof
  1688 00000496 7328                    	jae KeyCREnd
  1689 00000498 E8270C0000              	call CheckENum			;Sun Feb 20 2005
  1690 0000049D EB07                    	jmp short KQZ1
  1691 0000049F B02F                    KeyCtrlQZ:mov al,2fh
  1692 000004A1 803F0A                  	cmp byte [edi],NEWLINE
  1693 000004A4 74EB                    	jz KeyCRight3
  1694 000004A6 47                      KQZ1:	inc edi
  1695 000004A7 E84A060000              	call IsEmMode
  1696 000004AC 7409                    	jz ISEM2
  1697 000004AE 3807                    	cmp byte [edi],al		;ws stops at word begin
  1698 000004B0 76ED                    	jbe KeyCtrlQZ
  1699 000004B2 3847FF                  	cmp byte [edi-1],al
  1700 000004B5 EB07                    	jmp short ISEM22
  1701 000004B7 3847FF                  ISEM2:	cmp byte [edi-1],al		;em stops after end
  1702 000004BA 76E3                    	jbe KeyCtrlQZ
  1703 000004BC 3807                    	cmp byte [edi],al
  1704 000004BE 77DF                    ISEM22:	ja KeyCtrlQZ
  1705 000004C0 C3                      KeyCREnd:ret
  1706                                  ;-------
  1707 000004C1 E8F00B0000              KeyVIcmde3:call CheckEof		;end of word (vi only)
  1708 000004C6 73F8                    	jae KeyCREnd
  1709 000004C8 47                      	inc edi
  1710 000004C9 803F0A                  KeyVIcmde:cmp byte [edi],NEWLINE
  1711 000004CC 74F3                    	jz KeyVIcmde3
  1712 000004CE 47                      	inc edi
  1713 000004CF 803F2F                  	cmp byte [edi],2fh
  1714 000004D2 76F5                    	jbe KeyVIcmde
  1715 000004D4 807F012F                	cmp byte [edi+1],2fh
  1716 000004D8 77EF                    	ja KeyVIcmde
  1717 000004DA C3                      	ret
  1718                                  ;-------
  1719 000004DB E8C00E0000              KeyEmaCtrlO:call Insert1Byte
  1720 000004E0 728D                    	jc KeyRightEnd
  1721 000004E2 B00A                    	mov al,NEWLINE
  1722 000004E4 8807                    	mov byte [edi],al
  1723 000004E6 C3                      	ret
  1724                                  ;----------------------------------------------------------------------
  1725                                  ;
  1726                                  ; processing special keys from the WS's Ctrl-Q menu
  1727                                  ;
  1728 000004E7 E8E00B0000              KeyCtrlQE:call LookPgBegin		;goto top left on screen
  1729 000004EC E8D20D0000              	call KursorFirstLine
  1730 000004F1 EB20                    	jmp short KCtKV1
  1731                                  ;-------
  1732 000004F3 E8E00B0000              KeyCtrlQX:call LookPgEnd		;1st goto last line on screen
  1733 000004F8 E8A5050000              	call KeyEnd			;2nd goto line end
  1734 000004FD E8C50D0000              	call KursorLastLine
  1735 00000502 EB0F                    	jmp short KCtKV1
  1736                                  ;-------
  1737 00000504 803D[142F0100]00        KeyCtrlQV:cmp byte [bereitsges],0	;goto last ^QA,^QF pos
  1738 0000050B 74B3                    	jz KeyCREnd
  1739 0000050D 8B3D[102F0100]          	mov edi,[oldQFpos]
  1740 00000513 E9E1000000              KCtKV1:	jmp CQFNum
  1741                                  ;-------
  1742 00000518 6AFF                    KeyVIbsearch:push byte -1
  1743 0000051A EB02                    	jmp short KVIf
  1744 0000051C 6A01                    KeyVIfsearch:push byte 1
  1745 0000051E C605[402F0100]FF        KVIf:	mov byte[grossklein],0ffh
  1746 00000525 EB64                    	jmp short KeyECtS1
  1747                                  ;-------
  1748 00000527 893D[8C380100]          PicoCtrlTpico:mov [PicoSearch],edi	;store begin of search (because wrap around EOF)
  1749 0000052D 6A01                    KeyEmaAltPer:push byte 1		;s&repl
  1750 0000052F 8F05[3C2F0100]          	pop dword[vorwarts]
  1751 00000535 C605[402F0100]DF        	mov byte[grossklein],0dfh
  1752                                  ;-------
  1753 0000053C C605[142F0100]02        KeyCtrlQA:mov byte [bereitsges],2
  1754 00000543 E829140000              	call AskForReplace
  1755 00000548 7209                    	jc SimpleRet9
  1756 0000054A 57                      CQACtrlL:push edi
  1757 0000054B E8CF140000              	call FindText
  1758 00000550 7302                    	jnc CQACL2
  1759 00000552 5F                      	pop edi
  1760 00000553 C3                      SimpleRet9:ret
  1761 00000554 A1[342F0100]            CQACL2:	mov eax,[suchlaenge]
  1762 00000559 E8180E0000              	call DeleteByte
  1763 0000055E A1[382F0100]            	mov eax,[repllaenge]
  1764 00000563 E83B0E0000              	call InsertByte
  1765 00000568 BE[C8320100]            	mov esi,replacetext
  1766 0000056D E8EE0E0000              	call MoveBlock
  1767 00000572 EB7E                    	jmp short CQFFound
  1768                                  ;-------
  1769 00000574 803D[142F0100]02        KeyPiCtrlJT:cmp byte [bereitsges],2
  1770 0000057B 74CD                    	jz CQACtrlL
  1771 0000057D C3                      	ret
  1772                                  ;-------
  1773 0000057E 6AFF                    KeyEmaCtrlR:push byte -1
  1774 00000580 EB02                    	jmp short KECS
  1775                                  ;-------
  1776 00000582 6A01                    KeyEmaCtrlS:push byte 1
  1777 00000584 C605[402F0100]DF        KECS:	mov byte[grossklein],0dfh
  1778 0000058B 8F05[3C2F0100]          KeyECtS1:pop dword[vorwarts]
  1779 00000591 893D[74380100]          	mov [EmaMark],edi
  1780 00000597 E838020000              	call ShowBl0			;i.e. "mov byte [showblock],0"
  1781                                  ;------- cont
  1782 0000059C E855050000              KeyCtrlQF:call IsEmMode
  1783 000005A1 7509                    	jnz NO_EM04
  1784 000005A3 803D[79380100]01        	cmp byte [EmaCtrlS],1
  1785 000005AA 7454                    	jz KeyCtrlL
  1786 000005AC FF35[C8330100]          NO_EM04:push dword [suchtext]		;store begin of old find_text
  1787 000005B2 C605[142F0100]01        	mov byte [bereitsges],1
  1788 000005B9 E8D5130000              	call AskForFind
  1789 000005BE 5B                      	pop ebx
  1790 000005BF 9C                      	pushf
  1791 000005C0 F605[A0380100]0C        	test byte [mode], VI | PI
  1792 000005C7 7417                    	jz NO_VIPI01
  1793 000005C9 9D                      	popf
  1794 000005CA 09C0                    	or eax,eax			;jmp if user entered a new find_text
  1795 000005CC 750A                    	jnz QFpico
  1796 000005CE 08DB                    	or bl,bl			;jmp if no old find text available
  1797 000005D0 742D                    	jz CtrlQFEnd
  1798 000005D2 881D[C8330100]          	mov byte [suchtext],bl		;restore last find_text
  1799 000005D8 893D[8C380100]          QFpico:	mov [PicoSearch],edi		;store begin of search (because wrap around EOF)
  1800 000005DE EB03                    	jmp short CQFCtrlL
  1801                                  ;-------
  1802 000005E0 9D                      NO_VIPI01:popf
  1803 000005E1 721C                    	jc CtrlQFEnd
  1804 000005E3 57                      CQFCtrlL:push edi
  1805 000005E4 E836140000              	call FindText
  1806 000005E9 C605[79380100]01        	mov byte [EmaCtrlS],1
  1807 000005F0 720C                    	jc CtrlQFNotFound
  1808 000005F2 893D[102F0100]          CQFFound:mov [oldQFpos],edi
  1809 000005F8 5E                      	pop esi				;dummy
  1810 000005F9 E9C60A0000              CQFNum:	jmp CheckENum			;i.e. "mov byte [numeriere],1   ret"
  1811 000005FE 5F                      CtrlQFNotFound:pop edi
  1812 000005FF C3                      CtrlQFEnd:ret
  1813                                  ;-------
  1814 00000600 A1[142F0100]            KeyCtrlL:mov eax,[bereitsges]		;2^QA   1^QF   0else
  1815 00000605 48                      	dec eax
  1816 00000606 74DB                    	jz CQFCtrlL
  1817 00000608 F605[A0380100]15        	test byte[mode],WS | NE | PI
  1818 0000060F 7407                    	jz SimpleRet4
  1819 00000611 48                      	dec eax
  1820 00000612 0F8432FFFFFF            	jz near CQACtrlL
  1821 00000618 C3                      SimpleRet4:ret
  1822                                  ;-------
  1823 00000619 E8320A0000              KeyVIcmd1:call ReadOneChar
  1824 0000061E 3C47                    	cmp al,'G'
  1825 00000620 7410                    	je KeyCtrlQR
  1826 00000622 C3                      	ret
  1827 00000623 E30D                    ViSpecial:jecxz KeyCtrlQR
  1828 00000625 EB42                    	jmp short KCQI
  1829 00000627 892D[74380100]          KeyNedCtrlA:mov [EmaMark],ebp
  1830 0000062D E89A010000              	call ShowBl1			;i.e.  "mov byte [showblock],1"   but shorter
  1831 00000632 BF[ED3C0100]            KeyCtrlQR:mov edi,sot
  1832 00000637 EBC0                    	jmp short CQFNum
  1833                                  ;-------
  1834 00000639 8B0D[282F0100]          KeyCtrlQP:mov ecx,[veryold]
  1835 0000063F 39E9                    	cmp ecx,ebp
  1836 00000641 77D5                    	ja SimpleRet4
  1837 00000643 89CF                    	mov edi,ecx
  1838 00000645 EBB2                    JmpCQFN3:jmp short CQFNum
  1839                                  ;-------
  1840 00000647 97                      KeyCtrlQB:xchg eax,edi
  1841 00000648 8B3D[182F0100]          	mov edi,[blockbegin]
  1842 0000064E 09FF                    CtrlQB2:or edi,edi			;exit if no marker set
  1843 00000650 75A7                    	jnz CQFNum
  1844 00000652 97                      	xchg edi,eax
  1845 00000653 C3                      	ret
  1846                                  ;-------
  1847 00000654 97                      KeyCtrlQK:xchg eax,edi
  1848 00000655 8B3D[1C2F0100]          	mov edi,[blockende]
  1849 0000065B EBF1                    	jmp short CtrlQB2
  1850                                  ;-------
  1851 0000065D BE[F6220000]            KeyCtrlQI:mov esi,asklineno
  1852 00000662 E810140000              	call GetAsciiToInteger
  1853 00000667 7696                    	jbe CtrlQFEnd			;CY or ZR set
  1854 00000669 BF[ED3C0100]            KCQI:	mov edi,sot
  1855 0000066E E8D30A0000              	call LookPD2
  1856 00000673 EBD0                    JmpCQFN:jmp short JmpCQFN3
  1857                                  ;-------
  1858 00000675 E8FD030000              KeyCtrlQDel:call KeyLeft		;delete all left of cursor
  1859 0000067A E8670B0000              	call CountToLineBegin
  1860 0000067F 29C7                    	sub edi,eax
  1861 00000681 EB37                    	jmp short KCY
  1862                                  ;-------
  1863 00000683 C605[88380100]01        KeyVICmdD:mov byte [VInolinebased],1
  1864 0000068A E8180B0000              KeyCtrlQY:call CountToLineEnd
  1865                                  %ifdef W32LF
  1866                                  	or eax,eax
  1867                                  	jz KCQY
  1868                                  	cmp byte [edi+eax-1],0dh
  1869                                  	jnz KCQY
  1870                                  	dec eax				;keep RETURN 0dh char if exist
  1871                                  KCQY:
  1872                                  %endif
  1873 0000068F E85A040000              	call IsViMode
  1874 00000694 7557                    	jnz CtrlTEnd1
  1875 00000696 E852000000              	call CtrlTEnd1
  1876 0000069B E9D7030000              	jmp KeyLeft
  1877                                  ;-------
  1878 000006A0 E84B0B0000              KeyCmddw:call CountToWordBeginVIstyle
  1879 000006A5 EB3E                    	jmp short NO_EM05
  1880                                  ;-------
  1881 000006A7 E8EDFCFFFF              KeyCtrlY:call KeyHome			;edi at begin
  1882 000006AC E8F60A0000              	call CountToLineEnd
  1883 000006B1 803D[A0380100]01        	cmp byte[mode],WS
  1884 000006B8 7507                    	jnz NO_WS01
  1885 000006BA E8890C0000              KCY:	call DeleteByteCheckMarker
  1886 000006BF EB29                    	jmp short KeyCtrlT1
  1887 000006C1 F605[A0380100]0C        NO_WS01:test byte [mode], VI | PI
  1888 000006C8 740A                    	jz KeyCtrlT
  1889 000006CA 8D0C07                  	lea ecx,[edi+eax]
  1890 000006CD 39E9                    	cmp ecx,ebp
  1891 000006CF 741C                    	jz CtrlTEnd1			;do not delete pending LINEFEED (0Ah)
  1892 000006D1 40                      	inc eax
  1893 000006D2 EB19                    	jmp short CtrlTEnd1
  1894                                  ;-------
  1895 000006D4 E81E0B0000              KeyCtrlT:call CountToWordBegin
  1896 000006D9 E818040000              	call IsEmMode
  1897 000006DE 7505                    	jnz NO_EM05
  1898 000006E0 E8C20A0000              KeyEmaCtrlK:call CountToLineEnd
  1899 000006E5 803F0A                  NO_EM05:cmp byte [edi],NEWLINE
  1900 000006E8 7503                    	jnz CtrlTEnd1
  1901 000006EA 31C0                    KeyCtrlT1:xor eax,eax
  1902 000006EC 40                      	inc eax				;1 for LINEFEED (0ah)
  1903                                  %ifdef W32LF
  1904                                  	cmp byte[edi-1],RETURN
  1905                                  	jnz KCT2
  1906                                  	dec edi				;0dh is expected "left" of 0ah
  1907                                  	inc eax				;1 for RETURN   (0dh)
  1908                                  KCT2:
  1909                                  %endif
  1910 000006ED E8C4090000              CtrlTEnd1:call CheckEof
  1911 000006F2 7477                    	jz SimpleRet3
  1912 000006F4 803D[A0380100]01        	cmp byte[mode],WS
  1913 000006FB 0F84470C0000            	jz near DeleteByteCheckMarker
  1914 00000701 89FE                    	mov esi,edi
  1915 00000703 E8DE0D0000              	call KeyEmaAltW2
  1916 00000708 EB35                    	jmp short DelBjmp
  1917                                  ;-------
  1918 0000070A 8B0D[302F0100]          KeyEmaCtrlW:mov ecx,[showblock]
  1919 00000710 803D[A0380100]04        	cmp byte[mode],PI
  1920 00000717 750C                    	jne NOPI1
  1921                                  KECW:	
  1922                                  %ifndef YASM
  1923 00000719 E38C                    	jecxz KeyCtrlY
  1924                                  %else
  1925                                  	or ecx,ecx
  1926                                  	jz near KeyCtrlY
  1927                                  %endif
  1928 0000071B 8B0D[74380100]          	mov ecx,[EmaMark]
  1929 00000721 E3F6                    	jecxz KECW
  1930 00000723 EB0A                    	jmp short NOPI2
  1931 00000725 E344                    NOPI1:	jecxz SimpleRet3
  1932 00000727 8B0D[74380100]          	mov ecx,[EmaMark]
  1933 0000072D E33C                    	jecxz SimpleRet3
  1934 0000072F E8F20D0000              NOPI2:	call KeyEmaAltW
  1935 00000734 8B3D[70380100]          	mov edi,[EmaKiSrc]
  1936 0000073A A1[6C380100]            	mov eax,[EmaKiSize]
  1937 0000073F E9320C0000              DelBjmp:jmp DeleteByte
  1938                                  ;----------------------------------------------------------------------
  1939                                  ;
  1940                                  ; processing special Keys from WS's Ctrl-K menu
  1941                                  ;
  1942 00000744 E80B0A0000              KeyCtrlKY:call CheckBlock
  1943 00000749 7220                    	jc SimpleRet3			;no block: no action
  1944 0000074B A1[1C2F0100]            	mov eax,[blockende]
  1945 00000750 89F7                    	mov edi,esi			;esi is blockbegin (side effect in CheckBlock)
  1946 00000752 29F0                    	sub eax,esi			;block length
  1947 00000754 E81D0C0000              	call DeleteByte			;out ecx:=0
  1948 00000759 91                      	xchg eax,ecx
  1949 0000075A E8F2110000              	call InitSV2			;block no longer valid
  1950 0000075F E90FFFFFFF              JmpCQFN2:jmp JmpCQFN
  1951                                  ;-------
  1952 00000764 8035[302F0100]01        KeyCtrlKH:xor byte [showblock],1 	;flip flop
  1953 0000076B C3                      SimpleRet3:ret
  1954                                  KeyCtrlKK:				;UTF-8 :no special handling needed, because block end...
  1955 0000076C 893D[1C2F0100]          	mov [blockende],edi		;... points to first byte _after_ block
  1956 00000772 EB58                    	jmp short ShowBl1
  1957                                  ;-------
  1958 00000774 E8C50C0000              KeyCtrlKC:call CopyBlock
  1959 00000779 7258                    	jc SimpleRet2
  1960 0000077B 893D[182F0100]          CtrlKC2:mov [blockbegin],edi
  1961 00000781 01F8                    	add eax,edi
  1962 00000783 E9CE110000              	jmp InitSV3			;mov [blockende],eax - ret
  1963                                  ;-------
  1964 00000788 8B0D[74380100]          KeyCtrlXX:mov ecx,[EmaMark]
  1965 0000078E E3DB                    	jecxz SimpleRet3
  1966 00000790 E873000000              	call KeyEmaMark
  1967 00000795 89CF                    	mov edi,ecx
  1968 00000797 E8160B0000              	call KeyEmaCtrlL
  1969 0000079C EBC1                    KeyCXX:	jmp short JmpCQFN2
  1970                                  ;-------
  1971 0000079E E89B0C0000              KeyCtrlKV:call CopyBlock
  1972 000007A3 722E                    	jc SimpleRet2
  1973 000007A5 57                      	push edi
  1974 000007A6 3B3D[182F0100]          	cmp edi,[blockbegin]
  1975 000007AC 9C                      	pushf
  1976 000007AD 8B3D[182F0100]          	mov edi,[blockbegin]
  1977 000007B3 E8BE0B0000              	call DeleteByte
  1978 000007B8 F7D8                    	neg eax				;(for optimizing eax is negated there)
  1979 000007BA 9D                      	popf
  1980 000007BB 5F                      	pop edi
  1981 000007BC 72BD                    	jb CtrlKC2
  1982 000007BE 893D[1C2F0100]          	mov [blockende],edi
  1983 000007C4 29C7                    	sub edi,eax
  1984 000007C6 893D[182F0100]          KeyCtrlKB:mov [blockbegin],edi		;UTF-8: no special handling needed, because block begin...
  1985 000007CC C605[302F0100]01        ShowBl1:mov byte [showblock],1		;...points to _first_ byte in block
  1986 000007D3 C3                      SimpleRet2:ret
  1987 000007D4 C605[302F0100]00        ShowBl0:mov byte [showblock],0
  1988 000007DB C3                      	ret
  1989                                  ;-------
  1990 000007DC E86F080000              KeyVICmdm:call ReadOneChar
  1991 000007E1 3C61                    	cmp al,'a'			;ma (marker a)
  1992 000007E3 75EE                    	jne SimpleRet2
  1993 000007E5 57                      	push edi
  1994 000007E6 E8AEFBFFFF              	call KeyHome			;setting WS's "blockbegin" to BOL
  1995 000007EB 893D[182F0100]          	mov [blockbegin],edi
  1996 000007F1 5F                      	pop edi
  1997 000007F2 C3                      	ret
  1998                                  ;-------
  1999 000007F3 E858080000              KeyVICmdJmpM:call ReadOneChar
  2000 000007F8 3C61                    	cmp al,'a'
  2001 000007FA 75D7                    	jne SimpleRet2
  2002 000007FC 8B0D[182F0100]          	mov ecx,[blockbegin]		;like WStar's Ctrl-QB  [also Sun Oct  7 17:01:37 2001]
  2003 00000802 E3CF                    	jecxz SimpleRet2
  2004 00000804 89CF                    	mov edi,ecx
  2005 00000806 EB94                    	jmp short KeyCXX
  2006                                  ;-------
  2007 00000808 893D[74380100]          KeyEmaMark:mov [EmaMark],edi
  2008 0000080E EBBC                    	jmp short ShowBl1
  2009                                  ;-------
  2010 00000810 E8080F0000              KeyCtrlKR:call ReadBlock
  2011 00000815 722C                    	jc CtrlKREnd
  2012 00000817 E8AAFFFFFF              	call KeyCtrlKB
  2013 0000081C 01F9                    	add ecx,edi
  2014 0000081E 890D[1C2F0100]          	mov [blockende],ecx
  2015 00000824 F605[A0380100]12        	test byte [mode],EM | NE
  2016 0000082B 740B                    	jz NO_EM03
  2017 0000082D 890D[74380100]          	mov [EmaMark],ecx
  2018 00000833 E89CFFFFFF              	call ShowBl0			;i.e. "mov byte [showblock],0"
  2019 00000838 803D[A0380100]04        NO_EM03:cmp byte [mode],PI
  2020 0000083F 7502                    	jnz CtrlKREnd
  2021 00000841 89CF                    	mov edi,ecx			;in PI: cursor at end of read file
  2022 00000843 E9950A0000              CtrlKREnd:jmp RestKursPos
  2023                                  ;-------
  2024 00000848 E807090000              KeyCtrlKW:call CheckBlock
  2025 0000084D 7263                    	jc CtrlKSEnd	   		;no action
  2026 0000084F E8A10E0000              	call SaveBlock
  2027 00000854 EBED                    	jmp short CtrlKREnd
  2028                                  ;-------
  2029 00000856 803D[0C2F0100]20        KeyEmaCtrlXF:cmp byte [changed],UNCHANGED
  2030 0000085D 741A                    	jz KECF
  2031 0000085F BE[DB220000]            	mov esi,asksave2
  2032 00000864 E83A0F0000              	call DE1
  2033 00000869 E86F0A0000              	call RestKursPos
  2034 0000086E E880120000              	call CheckUserAbort
  2035 00000873 743D                    	jz CtrlKSEnd
  2036 00000875 24DF                    	and al,0dfh
  2037 00000877 3C4E                    	cmp al,'N'			;N for request NOT SAVE changes
  2038 00000879 743F                    KECF:	jz KCKD2
  2039 0000087B EB36                    	jmp short KeyCtrlKD
  2040                                  ;-------
  2041 0000087D E82D100000              KeyEmaCtrlXW:call GetBlockName
  2042 00000882 722E                    	jc CtrlKSEnd
  2043 00000884 BE[C8310100]            	mov esi,blockpath
  2044 00000889 FC                      XW1:	cld
  2045                                  	PUSH_ALL
  2046 0000088A 60                  <1>  pusha
  2047 0000088B BF[C82F0100]            	mov edi,filepath
  2048 00000890 AC                      XW0:	lodsb
  2049 00000891 AA                      	stosb				;copy to blockpath to filepath
  2050 00000892 08C0                    	or al,al
  2051 00000894 75FA                    	jne XW0
  2052 00000896 AA                      	stosb
  2053                                  	POP_ALL
  2054 00000897 61                  <1>  popa
  2055 00000898 E82CF9FFFF              KeyCtrlKS0:call SetChg			;i.e. "mov byte [changed],CHANGED"  to save it really
  2056                                  ;-------
  2057 0000089D E89C0D0000              KeyCtrlKS:call SaveFile
  2058 000008A2 9C                      	pushf				;(called by ^kd)
  2059 000008A3 E8350A0000              	call RestKursPos
  2060 000008A8 9D                      	popf
  2061 000008A9 7207                    	jc CtrlKSEnd
  2062 000008AB C605[0C2F0100]20        Unchg:	mov byte [changed],UNCHANGED
  2063 000008B2 C3                      CtrlKSEnd:ret
  2064                                  ;-------
  2065 000008B3 E8E5FFFFFF              KeyCtrlKD:call KeyCtrlKS
  2066 000008B8 7243                    	jc KeyKXend
  2067 000008BA C605[202F0100]02        KCKD2:	mov byte [endeedit],2
  2068 000008C1 C3                      	ret
  2069                                  ;-------
  2070 000008C2 803D[0C2F0100]20        KeyCtrlKQ:cmp byte [changed],UNCHANGED
  2071 000008C9 742C                    	jz KCKXend
  2072 000008CB BE[D1220000]            	mov esi,asksave
  2073 000008D0 E8CE0E0000              	call DE1
  2074 000008D5 E8030A0000              	call RestKursPos
  2075 000008DA E814120000              	call CheckUserAbort
  2076 000008DF 74D1                    	jz CtrlKSEnd
  2077 000008E1 24DF                    	and al,0dfh
  2078 000008E3 3C4E                    	cmp al,'N'			;N for request NOT SAVE changes
  2079 000008E5 7410                    	jz KCKXend
  2080 000008E7 3C4C                    	cmp al,'L'			;L for SAVE and LOAD a new file
  2081 000008E9 7505                    	jnz KeyCtrlKX
  2082 000008EB E807000000              	call KCKXend
  2083 000008F0 E8A8FFFFFF              KeyCtrlKX:call KeyCtrlKS
  2084 000008F5 72BB                    	jc CtrlKSEnd
  2085 000008F7 FE05[202F0100]          KCKXend:inc byte [endeedit]
  2086 000008FD C3                      KeyKXend:ret
  2087                                  ;----------------------------------------------------------------------
  2088                                  ;
  2089                                  ; some minimal limited vi specials in command mode
  2090                                  ;
  2091 000008FE 8D7102                  KeyVICmdW:lea esi,[ecx+2]
  2092 00000901 803E20                  	cmp byte [esi],SPACECHAR
  2093 00000904 7783                    	ja XW1
  2094 00000906 C3                      	ret
  2095                                  ;-------
  2096 00000907 8B01                    VINoLineCmd:mov eax,[ecx]
  2097 00000909 663D7721                	cmp ax,'w!'			;save
  2098 0000090D 7489                    	je KeyCtrlKS0
  2099 0000090F 6683F877                	cmp ax,'w'			;save
  2100 00000913 7488                    	je KeyCtrlKS
  2101 00000915 6683F878                	cmp ax,'x'                      ;save and exit
  2102 00000919 74D5                    	je KeyCtrlKX
  2103 0000091B 6683F824                	cmp ax,'$'			;No line number, but EOF
  2104 0000091F 7507                    	jne KVI_KX0
  2105                                  ;-------
  2106 00000921 89EF                    KeyCtrlQC:mov edi,ebp
  2107 00000923 E9D1FCFFFF              	jmp CQFNum
  2108                                  ;-------
  2109 00000928 663D7771                KVI_KX0:cmp ax,'wq'
  2110 0000092C 74C2                    KVI_KX:	je KeyCtrlKX
  2111 0000092E 663D7720                	cmp ax,'w '			;save as ... and continue
  2112 00000932 74CA                    	je KeyVICmdW
  2113 00000934 6683F871                	cmp ax,'q'
  2114 00000938 7488                    	je KeyCtrlKQ
  2115 0000093A 663D7121                	cmp ax,'q!'
  2116 0000093E 74B7                    	je KCKXend
  2117 00000940 663D6520                	cmp ax,'e '			;edit another ..
  2118 00000944 0F84540C0000            	je near KeyVICmdE
  2119 0000094A 6683F868                	cmp ax,'h'
  2120 0000094E 0F84CC080000            	je near KeyHelp
  2121                                  %ifdef UTF8RTS
  2122                                  	cmp ax,'u'
  2123                                  	je near KeyUTF8switch
  2124                                  %endif
  2125                                  %ifndef USE_PIPE
  2126                                  	ret
  2127                                  %else
  2128 00000954 E92E130000              	jmp KeyVICmdtemp
  2129                                  %endif
  2130                                  ;-------
  2131 00000959 E8F2060000              KeyVICmdZ:call ReadOneChar
  2132 0000095E 3C5A                    	cmp al,'Z'
  2133 00000960 74CA                    	je KVI_KX
  2134 00000962 C3                      	ret
  2135                                  ;-------
  2136 00000963 E831FAFFFF              KeyVI1Char:call KeyHome
  2137 00000968 803F20                  	cmp byte [edi],SPACECHAR
  2138 0000096B 7711                    	ja KFC2
  2139 0000096D 803F0A                  KFC1:	cmp byte [edi],NEWLINE
  2140 00000970 740C                    	jz KFC2
  2141 00000972 47                      	inc edi
  2142 00000973 803F20                  	cmp byte [edi],SPACECHAR
  2143 00000976 76F5                    	jbe KFC1
  2144 00000978 807FFF20                	cmp byte [edi-1],SPACECHAR
  2145 0000097C 77EF                    	ja KFC1
  2146 0000097E C3                      KFC2:	ret
  2147                                  ;-------
  2148 0000097F E815FAFFFF              KeyVICmdS:call KeyHome
  2149 00000984 E857FDFFFF              	call KeyEmaCtrlK		;not quite ok in 'P'/'p' commands
  2150 00000989 C605[88380100]01        	mov byte [VInolinebased],1
  2151 00000990 EB4B                    	jmp short KeyVICmdI
  2152 00000992 E8B9060000              KeyVICmdd:call ReadOneChar
  2153 00000997 3C77                    	cmp al,'w'			;word (greetings to ma_ko)
  2154 00000999 C605[88380100]01        	mov byte [VInolinebased],1
  2155 000009A0 0F84FAFCFFFF            	je near KeyCmddw
  2156 000009A6 3C64                    	cmp al,'d'			;"delete"
  2157 000009A8 C605[88380100]00        	mov byte [VInolinebased],0
  2158 000009AF 0F84F2FCFFFF            	je near KeyCtrlY
  2159 000009B5 3C27                    	cmp al,"'"			;only line based mode supported
  2160 000009B7 75C5                    	jne KFC2
  2161 000009B9 E892060000              	call ReadOneChar
  2162 000009BE 3C61                    	cmp al,'a'			;" d'a "    (only marker "a" supported)
  2163 000009C0 75BC                    	jne KFC2
  2164 000009C2 8B0D[182F0100]          	mov ecx,[blockbegin]		;don't go further if no mark set
  2165 000009C8 E3B4                    	jecxz KFC2
  2166 000009CA E8B4F9FFFF              	call VIsetMarker		;an helper for adjusting begin/end marker line
  2167 000009CF E836FDFFFF              callKECW:call KeyEmaCtrlW
  2168 000009D4 31C0                    	xor eax,eax
  2169 000009D6 A3[182F0100]            	mov [blockbegin],eax		;after delete mark is no more set
  2170 000009DB EB3A                    	jmp short JmpCQFn
  2171                                  ;-------
  2172 000009DD E881FFFFFF              KeyVICmdI:call KeyVI1Char
  2173 000009E2 EB71                    	jmp short KeyVImode0
  2174                                  ;-------
  2175 000009E4 8B0D[6C380100]          KeyVICmdp:mov ecx,[EmaKiSize]		;check this before call KeyEmaCtrlY
  2176                                  jmpKFC2:
  2177                                  %ifdef YASM
  2178                                  	or ecx,ecx
  2179                                  	jz KFC2
  2180                                  %else
  2181 000009EA E392                    	jecxz KFC2
  2182                                  %endif
  2183 000009EC 803D[88380100]01        	cmp byte [VInolinebased],1
  2184 000009F3 7472                    	jz KeyVICmdpnLB
  2185 000009F5 E8E7F8FFFF              	call OvrRet			;ugly
  2186 000009FA 8B0D[6C380100]          KeyVICmdP:mov ecx,[EmaKiSize]		;check this before call KeyEmaCtrlY
  2187 00000A00 E3E8                    	jecxz jmpKFC2
  2188 00000A02 803D[88380100]01        	cmp byte [VInolinebased],1
  2189 00000A09 7461                    	jz KeyVICmdPnLB
  2190 00000A0B E889F9FFFF              	call KeyHome
  2191 00000A10 57                      KeyVICP2:push edi
  2192 00000A11 E89C0A0000              	call KeyEmaCtrlY
  2193 00000A16 5F                      	pop edi
  2194 00000A17 E9DDFBFFFF              JmpCQFn:jmp CQFNum
  2195                                  ;-------
  2196 00000A1C C605[582F0100]FE        KeyVICmdR:mov byte [insstat],254	;i.e "not 1"
  2197 00000A23 EB30                    	jmp short KeyVImode0
  2198 00000A25 E86FF9FFFF              KeyVICmdO:call KeyHome
  2199 00000A2A E869F8FFFF              	call KeyRet
  2200 00000A2F E8C7F8FFFF              	call KeyUp
  2201 00000A34 EB1F                    	jmp short KeyVImode0
  2202 00000A36 E867000000              KeyVICmdo:call KeyEnd
  2203 00000A3B E858F8FFFF              	call KeyRet
  2204 00000A40 EB13                    	jmp short KeyVImode0
  2205 00000A42 E85B000000              KeyVICmdA:call KeyEnd
  2206 00000A47 EB0C                    	jmp short KeyVImode0
  2207 00000A49 E8F9F9FFFF              KeyVIcmda:call KeyRight
  2208 00000A4E C605[582F0100]01        KeyVIcmdi:mov byte [insstat],1
  2209 00000A55 6A00                    KeyVImode0:push byte 0
  2210 00000A57 EB53                    	jmp short KVim1
  2211 00000A59 E882FCFFFF              KeyVICmdC:call KeyEmaCtrlK
  2212 00000A5E C605[88380100]01        	mov byte [VInolinebased],1
  2213 00000A65 EBEE                    	jmp short KeyVImode0
  2214                                  ;-------
  2215 00000A67 E8DBF9FFFF              KeyVICmdpnLB:call KeyRight		;not_Line_Based mode
  2216 00000A6C E89FFFFFFF              KeyVICmdPnLB:call KeyVICP2
  2217 00000A71 033D[6C380100]          	add edi,[EmaKiSize]		;Wed Apr 10 18:11:42 MEST 2002
  2218                                  ;------- cont
  2219                                  KeyLeft:
  2220                                  %ifdef UTF8
  2221                                  %ifdef UTF8RTSx_wont			;see KeyRight comment
  2222                                  	cmp byte [isUTF8],0
  2223                                  	je noUTF_F
  2224                                  %endif
  2225 00000A77 4F                      	dec edi
  2226 00000A78 8A07                    	mov al,byte [edi]		;check for UTF byte 2,3,4,..
  2227 00000A7A 24C0                    	and al,0c0h
  2228 00000A7C 3C80                    	cmp al,080h
  2229 00000A7E 74F7                    	je KeyLeft
  2230 00000A80 47                      	inc edi
  2231                                  noUTF_F:
  2232                                  %endif
  2233 00000A81 807FFF0A                	cmp byte [edi-1],NEWLINE
  2234 00000A85 7519                    	jnz KeyLNoMargin
  2235 00000A87 81FF[ED3C0100]          	cmp edi,sot			;i.e. CheckBof
  2236 00000A8D 7412                    	je KeyLeftEnd
  2237 00000A8F E85A000000              	call IsViMode
  2238 00000A94 740B                    	je KeyLeftEnd			;no more line wrap around in vi mode
  2239 00000A96 E829060000              	call CheckENum			;Sun Feb 20 2005
  2240 00000A9B E8D6070000              	call GoUp
  2241 00000AA0 4F                      KeyLNoMargin:dec edi
  2242                                  %ifdef W32LF
  2243                                  	cmp byte [edi],RETURN		;do not stay at 0dh
  2244                                  	jnz KeyLeftEnd
  2245                                  	dec edi
  2246                                  %endif
  2247 00000AA1 C3                      KeyLeftEnd:ret
  2248                                  ;-------
  2249 00000AA2 E800070000              KeyEnd:	call CountToLineEnd
  2250 00000AA7 01C7                    	add edi,eax			;points to a LINEFEED (0ah) char
  2251 00000AA9 C3                      	ret
  2252                                  ;-------
  2253 00000AAA 6A01                    KeyVImode1:push byte 1
  2254 00000AAC 58                      KVim1:	pop eax
  2255 00000AAD A2[80380100]            	mov byte [VICmdMode],al
  2256 00000AB2 C3                      	ret
  2257                                  ;-------
  2258 00000AB3 E8C3020000              KeyVIex:call InputStringWithMessage0
  2259 00000AB8 9C                      	pushf
  2260 00000AB9 E81F080000              	call RestKursPos
  2261 00000ABE 9D                      	popf
  2262 00000ABF 723C                    	jc Kviex
  2263 00000AC1 BE[C8350100]            	mov esi,optbuffer
  2264 00000AC6 31D2                    	xor edx,edx
  2265 00000AC8 89C1                    	mov ecx,eax			;do not use xchg here
  2266 00000ACA E331                    	jecxz Kviex
  2267                                  ;-------
  2268 00000ACC 56                      	push esi			;save optbuffer
  2269 00000ACD FC                      	cld
  2270 00000ACE AC                      CheckDig:lodsb				;check for line number entered
  2271 00000ACF 3C30                    	cmp al,'0'
  2272 00000AD1 7301                    	jnb CD1
  2273 00000AD3 42                      	inc edx
  2274 00000AD4 3C3A                    CD1:	cmp al,':'
  2275 00000AD6 7201                    	jb CD2
  2276 00000AD8 42                      	inc edx
  2277 00000AD9 E2F3                    CD2:	loop CheckDig
  2278 00000ADB 59                      	pop ecx				;rest optbuffer
  2279                                  ;-------
  2280 00000ADC 09D2                    	or edx,edx
  2281 00000ADE 0F8523FEFFFF            	jnz near VINoLineCmd
  2282 00000AE4 E88E0F0000              	call GetAsciiToInteger
  2283 00000AE9 E935FBFFFF              	jmp ViSpecial			;due short jumps there
  2284                                  ;-------
  2285 00000AEE 803D[A0380100]08        IsViMode:cmp byte [mode],VI
  2286 00000AF5 C3                      	ret
  2287 00000AF6 803D[A0380100]02        IsEmMode:cmp byte [mode],EM
  2288 00000AFD C3                      Kviex:	ret
  2289                                  ;---------------------------------------------------------------------
  2290                                  ;
  2291                                  ; the general PAGE DISPLAY function: called after any pressed key
  2292                                  ;
  2293                                  ; side effect: sets 'columne' for RestoreStatusLine function (displays column)
  2294                                  ; variable kurspos: for placing the cursor at new position
  2295                                  ; register bh counts lines
  2296                                  ; register bl counts columns visible on screen (w/o left scrolled)
  2297                                  ; register edx counts columns in text lines
  2298                                  ; register ecx screen line counter and helper for rep stos
  2299                                  ; register esi text index
  2300                                  ; register edi screen line buffer index
  2301                                  ;
  2302 00000AFE F605[A0380100]16        DispNewScreen:test byte [mode], EM | PI | NE
  2303 00000B05 7422                    	jz NoEmBlock
  2304 00000B07 8B0D[302F0100]          	mov ecx,[showblock]		;transfering Emacs's mark/point into....
  2305 00000B0D E31A                    	jecxz NoEmBlock			;....WS's block display system
  2306 00000B0F 8B0D[74380100]          	mov ecx,[EmaMark]
  2307 00000B15 E312                    	jecxz NoEmBlock
  2308 00000B17 89F8                    	mov eax,edi
  2309 00000B19 39C1                    	cmp ecx,eax
  2310 00000B1B 7201                    	jb EmBlock
  2311 00000B1D 91                      	xchg eax,ecx
  2312 00000B1E 890D[182F0100]          EmBlock:mov [blockbegin],ecx
  2313 00000B24 A3[1C2F0100]            	mov [blockende ],eax
  2314                                  ;-------
  2315 00000B29 E894010000              NoEmBlock:call GetEditScreenSize	;check changed tty size
  2316 00000B2E 31C0                    	xor eax,eax
  2317 00000B30 A2[502F0100]            	mov byte[isbold],al
  2318 00000B35 A2[542F0100]            	mov byte[inverse],al
  2319 00000B3A A3[F82E0100]            	mov [zloffst],eax
  2320 00000B3F A3[F42E0100]            	mov [columne],eax
  2321 00000B44 893D[FC2E0100]          	mov [fileptr],edi		;for seeking current cursor pos
  2322 00000B4A 57                      	push edi			;&&**##
  2323 00000B4B E85F060000              	call CountColToLineBeginVis	;i.e. expanding TABs
  2324 00000B50 8B1D[F02E0100]          	mov ebx,[columns]
  2325 00000B56 8D5BFC                  	lea ebx,[ebx-4]			;03 Jun 2001
  2326 00000B59 39D8                    	cmp eax,ebx
  2327 00000B5B 7208                    	jb short DispShortLine
  2328 00000B5D 29D8                    	sub eax,ebx
  2329 00000B5F 40                      	inc eax
  2330 00000B60 A3[F82E0100]            	mov [zloffst],eax
  2331 00000B65 E862050000              DispShortLine:call LookPgBegin 		;go on 1st char upper left on screen
  2332 00000B6A 89FE                    	mov esi,edi			;esi for reading chars from text
  2333 00000B6C 8B0D[EC2E0100]          	mov ecx,[lines]
  2334                                  %ifndef YASM
  2335 00000B72 E389                    	jecxz Kviex
  2336                                  %else
  2337                                  	or ecx,ecx
  2338                                  	jz near Kviex
  2339                                  %endif
  2340 00000B74 FC                      	cld
  2341 00000B75 B7FF                    	mov bh,-1			;first line
  2342 00000B77 FEC7                    DispNewLine:inc bh			;new line
  2343 00000B79 BF[34370100]            	mov edi,screenline		;line display buffer
  2344 00000B7E 31D2                    	xor edx,edx			;reset char counter
  2345 00000B80 B300                    	mov bl,0 			;reset screen column to 0
  2346                                  %ifdef LESSWRITEOPS
  2347 00000B82 E80C010000              	call SetColor2			;set initial character color per each line
  2348                                  %endif
  2349                                  DispCharLoop:
  2350 00000B87 3B35[FC2E0100]          	cmp esi,[fileptr]		;display char @ cursor postion ?
  2351 00000B8D 751C                    	jnz DispCharL1
  2352 00000B8F 803D[082F0100]00        	cmp byte[tabcnt],0
  2353 00000B96 7513                    	jnz DispCharL1
  2354 00000B98 891D[002F0100]          	mov [kurspos],ebx
  2355 00000B9E A1[F82E0100]            	mov eax,[zloffst]		;chars scrolled left hidden
  2356 00000BA3 00D8                    	add al,bl
  2357 00000BA5 0105[F42E0100]          	add [columne],eax
  2358                                  %ifdef CURSORMGNT
  2359                                  	stc
  2360                                  	call SetInverseStatus
  2361                                  	jnc DispEndLine
  2362                                  %endif
  2363 00000BAB E8B8000000              DispCharL1:call SetColor		;set color if neccessary
  2364                                  ;-------
  2365 00000BB0 39EE                    DispEndLine:cmp esi,ebp
  2366 00000BB2 776D                    	ja FillLine			;we have passed EOF, so now fill rest of screen
  2367 00000BB4 803D[082F0100]00        	cmp byte[tabcnt],0
  2368 00000BBB 7408                    	jz ELZ
  2369 00000BBD FE0D[082F0100]          	dec byte[tabcnt]
  2370 00000BC3 EB19                    	jmp short ELZ2
  2371 00000BC5 39EE                    ELZ:	cmp esi,ebp
  2372 00000BC7 7503                    	jnz ELZ6
  2373 00000BC9 46                      	inc esi				;set esi>ebp will later trigger  "ja FillLine"
  2374 00000BCA EB12                    	jmp short ELZ2
  2375 00000BCC AC                      ELZ6:	lodsb
  2376 00000BCD 3C09                    	cmp al,TABCHAR
  2377 00000BCF 750F                    	jnz ELZ3
  2378 00000BD1 E8DB0E0000              	call SpacesForTab		;ah = space_up_to_next_tab location
  2379 00000BD6 FECC                    	dec ah				;count out the tab char itself
  2380 00000BD8 8825[082F0100]          	mov byte[tabcnt],ah
  2381 00000BDE B020                    ELZ2:	mov al,SPACECHAR
  2382 00000BE0 3C0A                    ELZ3:	cmp al,NEWLINE
  2383 00000BE2 743D                    	jz FillLine
  2384                                  %ifdef W32LF
  2385                                  	cmp al,RETURN
  2386                                  	jz ELZ5				;keep 0dh "invisible"
  2387                                  %endif
  2388 00000BE4 3C20                    	cmp al,SPACECHAR
  2389 00000BE6 7302                    	jae ELZ9			;simply ignore chars like carriage_return etc.
  2390 00000BE8 B02E                    ELZ99:	mov al,'.'
  2391                                  ELZ9:	
  2392                                  %ifndef W32
  2393 00000BEA 3C7F                    	cmp al,7fh
  2394 00000BEC 7202                    	jb ELZ7
  2395 00000BEE 74F8                    	je ELZ99
  2396                                  %ifndef UTF8
  2397                                  	mov al,'.'
  2398                                  %else
  2399                                  %ifdef UTF8RTS
  2400                                  	cmp byte [isUTF8],0
  2401                                  	jne YXCVB
  2402                                  	mov al,'.'
  2403                                  YXCVB:
  2404                                  %endif
  2405                                  %endif
  2406                                  ELZ7:	
  2407                                  %endif
  2408 00000BF0 3A1D[F02E0100]          	cmp bl,byte [columns]		;screen width
  2409 00000BF6 73B8                    	jae DispEndLine			;continue reading line until end
  2410                                  ;-------
  2411                                  %ifdef UTF8
  2412 00000BF8 B400                    	mov ah,0
  2413                                  %ifdef UTF8RTS
  2414                                  	cmp byte [isUTF8],0
  2415                                  	je CountByte
  2416                                  %endif
  2417 00000BFA 50                      	push eax
  2418 00000BFB 24C0                    	and al,0c0h
  2419 00000BFD 3C80                    	cmp al,080h
  2420 00000BFF 58                      	pop eax
  2421 00000C00 740F                    	jz UByte234			;MSB 10...... =do not count 
  2422 00000C02 720A                    	jb CountByte			;MSB 01...... 00...... count valid 7bit ASCII
  2423 00000C04 50                      	push eax
  2424 00000C05 8A06                    	mov al,byte [esi]		;check next byte for vaild UTF8 follower byte
  2425 00000C07 24C0                    	and al,0C0h
  2426 00000C09 3C80                    	cmp al,80h			;is UTF8 byte 2,3,4,..  ?
  2427 00000C0B 58                      	pop eax
  2428 00000C0C 7503                    	jnz UByte234			;no do not count wrong UTF8 starter byte
  2429 00000C0E 42                      CountByte:inc edx
  2430 00000C0F FEC4                    	inc ah				;1
  2431 00000C11 3B15[F82E0100]          UByte234:cmp edx,[zloffst]
  2432 00000C17 7603                    	jbe ELZ5			;loaded new char (but won't display)
  2433 00000C19 AA                      	stosB
  2434 00000C1A 00E3                    	add bl,ah			;i.e. add 0 or 1 to curser column position counter
  2435                                  %else
  2436                                  	inc edx
  2437                                  	cmp edx,[zloffst]
  2438                                  	jbe ELZ5			;loaded new char (but won't display)
  2439                                  	stosB
  2440                                  	inc bl
  2441                                  %endif
  2442                                  ;-------
  2443                                  %ifdef CURSORMGNT
  2444                                  	clc
  2445                                  	call SetInverseStatus
  2446                                  %endif
  2447 00000C1C E966FFFFFF              ELZ5:	jmp DispCharLoop
  2448                                  ;-------
  2449 00000C21 51                      FillLine:push ecx			;continue rest of line
  2450 00000C22 8B0D[F02E0100]          	mov ecx,[columns]		;width
  2451 00000C28 28D9                    	sub cl,bl
  2452 00000C2A B020                    	mov al,SPACECHAR		;fill with blanks
  2453 00000C2C E30F                    	jecxz FillLine2
  2454 00000C2E 803D[542F0100]01        	cmp byte[inverse],1		;special cursor attribute?
  2455 00000C35 7504                    	jnz FillLine1
  2456 00000C37 AA                      	stosB				;only 1st char with special attribute
  2457                                  %ifdef CURSORMGNT
  2458                                  	clc
  2459                                  	call SetInverseStatus
  2460                                  %endif
  2461 00000C38 49                      	dec ecx				;one char less
  2462 00000C39 7402                    	jz FillLine2
  2463                                  FillLine1:
  2464 00000C3B F3AA                    	rep stosB			;store the rest blanks
  2465 00000C3D 59                      FillLine2:pop ecx
  2466 00000C3E C60700                  	mov byte[edi],0
  2467 00000C41 E8B4000000              	call ScreenLineShow
  2468 00000C46 49                      	dec ecx
  2469 00000C47 0F852AFFFFFF            	jnz near DispNewLine
  2470 00000C4D 5F                      	pop edi				;&&**##	;OLD: mov edi,[fileptr]	;=restore text pointer
  2471 00000C4E E98A060000              	jmp RestKursPos
  2472                                  ;----------------------------------------------------------------------
  2473                                  ; three helper subroutines called by DispNewScreen
  2474                                  ; dealing ESC sequences for character attributes
  2475                                  ; 
  2476                                  %ifdef CURSORMGNT
  2477                                  SetInverseStatus:
  2478                                  	push ecx		;returns zero flag
  2479                                  	push esi
  2480                                  	jnc SIS1
  2481                                  	cmp byte [insstat],1
  2482                                  	stc
  2483                                  	jnz SIS4
  2484                                  	mov byte[inverse],1
  2485                                  	mov esi,reversevideoX
  2486                                  	add esi,[revvoff]		;switch between esc seq for linux or Xterm
  2487                                  	jmp short SIS2
  2488                                  SIS1:	cmp byte[inverse],1
  2489                                  	jnz SIS3
  2490                                  	mov byte[inverse],0
  2491                                  ;-------continued...
  2492                                  %endif
  2493                                  ;------
  2494                                  ; next presented in 2 versions: one for Win32, one for Terminals
  2495                                  ;
  2496                                  %ifdef W32 ;------------- this can't be done via ESC seq ----------------
  2497                                  SIS6:	mov byte[isbold],0
  2498                                  SIS5:	mov eax,DARKWHITE
  2499                                  SIS2:	mov ecx,edi
  2500                                  	sub ecx,screenline
  2501                                  	mov edx,ecx			;current pos in columne
  2502                                  	shl ecx,1
  2503                                  	mov edi,attribline
  2504                                  	add edi,ecx
  2505                                  	mov ecx,[columns]
  2506                                  	sub ecx,edx			;only current pos up to line end
  2507                                  	rep stosw
  2508                                  SIS3:	clc
  2509                                  SIS4:	POP_ALL
  2510                                  	ret
  2511                                  SetColor:				;expects cy flag:bold /  nc:normal
  2512                                  	PUSH_ALL
  2513                                  	call IsShowBlock
  2514                                  	jnc SCEsc1
  2515                                  	cmp byte [isbold],1		;never set bold if it is already bold
  2516                                  	jz SIS4
  2517                                  	mov byte [isbold],1
  2518                                  SCEsc2:	mov eax,WHITE
  2519                                  	jmp short SIS2
  2520                                  SCEsc1:	cmp byte [isbold],0		;ditto
  2521                                  	jz SIS4
  2522                                  	jmp short SIS6
  2523                                  ;-------
  2524                                  SetColor2:PUSH_ALL
  2525                                  	call IsShowBlock
  2526                                  	jnc SIS5
  2527                                  	jmp short SCEsc2
  2528                                  %else ;---------------------- TERMINAL part -----------------------------
  2529 00000C53 C605[502F0100]00        SIS6:	mov byte[isbold],0
  2530 00000C5A BE[03260000]            SIS5:	mov esi,bold0
  2531 00000C5F 6A04                    SIS2:	push byte boldlen
  2532 00000C61 59                      	pop ecx
  2533 00000C62 F3A4                    	rep movsb
  2534 00000C64 F8                      SIS3:	clc
  2535 00000C65 5E                      SIS4:	pop esi
  2536 00000C66 59                      	pop ecx
  2537 00000C67 C3                      	ret
  2538                                  ;-------
  2539 00000C68 51                      SetColor:push ecx			;expects cy flag:bold /  nc:normal
  2540 00000C69 56                      	push esi
  2541 00000C6A E82F000000              	call IsShowBlock
  2542 00000C6F 7317                    	jnc SCEsc1
  2543 00000C71 803D[502F0100]01        	cmp byte [isbold],1		;never set bold if it is already bold
  2544 00000C78 74EB                    	jz SIS4
  2545 00000C7A C605[502F0100]01        	mov byte [isbold],1
  2546 00000C81 BE[11260000]            SCEsc2:	mov esi,bold1
  2547 00000C86 EBD7                    	jmp short SIS2
  2548 00000C88 803D[502F0100]00        SCEsc1:	cmp byte [isbold],0		;ditto
  2549 00000C8F 74D4                    	jz SIS4
  2550 00000C91 EBC0                    	jmp short SIS6
  2551                                  ;-------
  2552                                  %ifdef LESSWRITEOPS
  2553                                  SetColor2:
  2554 00000C93 51                      	push ecx
  2555 00000C94 56                      	push esi
  2556 00000C95 E804000000              	call IsShowBlock
  2557 00000C9A 73BE                    	jnc SIS5
  2558 00000C9C EBE3                    	jmp short SCEsc2
  2559                                  %endif
  2560                                  %endif ;----------------- end of double part -----------------------------
  2561                                  ;
  2562                                  ;-------
  2563                                  ; a little helper for SetColor* functions
  2564                                  ;
  2565 00000C9E 803D[302F0100]00        IsShowBlock:cmp byte [showblock],0
  2566 00000CA5 7419                    	je SBlock
  2567 00000CA7 833D[182F0100]00        	cmp dword [blockbegin],0
  2568 00000CAE 7410                    	je SBlock
  2569 00000CB0 3935[182F0100]          	cmp [blockbegin],esi
  2570 00000CB6 7708                    	ja SBlock
  2571 00000CB8 3B35[1C2F0100]          	cmp esi,[blockende]
  2572 00000CBE 7201                    	jb SB_ret
  2573 00000CC0 F8                      SBlock:	clc
  2574 00000CC1 C3                      SB_ret:	ret
  2575                                  ;-------
  2576                                  ; this helper for DispNewScreen checks screen size before writing on screen
  2577                                  ; FIXME: adjusting edit screen resize works with xterm, but not with SVGATextMode
  2578                                  ;
  2579                                  GetEditScreenSize:
  2580                                  %ifdef W32
  2581                                  	push dword csbi
  2582                                  	push dword [hout]
  2583                                  	call GetConsoleScreenBufferInfo
  2584                                  	or eax,eax
  2585                                  	mov eax,[csbi]
  2586                                  	jnz noerr
  2587                                  	mov eax,0x00190050		;i.e. (80<<16)+24  (assume 80x25)
  2588                                  noerr:	mov byte [columns],al
  2589                                  	shr eax,16
  2590                                  	dec eax
  2591                                  	mov byte [lines],al		;columns > 255 are ignored...
  2592                                  	ret
  2593                                  %else
  2594 00000CC2 B913540000              	mov ecx,TERMIOS_WSIZE
  2595 00000CC7 BA[C82E0000]            	mov edx,winsize
  2596 00000CCC E8F30E0000              	call IOctlTerminal
  2597 00000CD1 8B02                    	mov eax,[edx]			;each 16 bit lines,columns
  2598 00000CD3 3DFFFF0000              	cmp eax,0x0000FFFF		;some give no columns info..?
  2599 00000CD8 7204                    	jb iserr
  2600 00000CDA 09C0                     	or eax,eax
  2601 00000CDC 7505                     	jnz noerr
  2602 00000CDE B818005000              iserr: 	mov eax,0x00500018		;i.e. (80<<16)+24  (assume 80x24)
  2603 00000CE3 48                      noerr:	dec eax				;without status line ('dec al' are 2 byte!)
  2604 00000CE4 A2[EC2E0100]            	mov byte [lines],al
  2605 00000CE9 C1E810                  	shr eax,16
  2606 00000CEC A2[F02E0100]            	mov byte [columns],al		;columns > 255 are ignored...
  2607 00000CF1 C3                      	ret
  2608                                  %endif
  2609                                  ;----------------------------------------------------------------------
  2610                                  ;
  2611                                  ; LOWER LEVEL screen acces function (main +2 helpers)
  2612                                  ; this function does write the line buffer to screen i.e. terminal
  2613                                  ;
  2614                                  ; at first 2 special entry points:
  2615 00000CF2 890D[34370100]          WriteTwo:mov [screenline],ecx
  2616                                  StatusLineShow:
  2617                                  %ifdef W32
  2618                                  	push edi
  2619                                  	mov ecx,[columns]
  2620                                  	shr ecx,1
  2621                                  	mov eax,YELLOW_BLUE_TWICE
  2622                                  	mov edi,attribline
  2623                                  	rep stosd
  2624                                  	pop edi
  2625                                  	mov edx,[kurspos2]
  2626                                  	call sys_writeKP		;set cursor pos before reading chars
  2627                                  %endif
  2628 00000CF8 31C9                    	xor ecx,ecx			;0 for bottom line
  2629                                  ;-------
  2630                                  ScreenLineShow:PUSH_ALL			;expecting in ecx screen line counted from 0
  2631                              <1> ScreenLineShow:
  2632 00000CFA 60                  <1>  pusha
  2633                                  %ifdef LESSWRITEOPS
  2634                                  %ifdef W32				;screen attrib caching
  2635                                  	mov eax,[columns]
  2636                                  	mul ecx				;setting edx to 0
  2637                                  	mov ebx,edx			;flag
  2638                                  	lea edi,[eax+attribbuffer]
  2639                                  	cld
  2640                                  	mov esi,attribline
  2641                                  Xsl3:	lodsw
  2642                                  	cmp edi,attribbuffer_end	;never read/write beyond buffer
  2643                                  	jnb Xsl5
  2644                                  	cmp ax,[edi]
  2645                                  	jz Xsl4
  2646                                  	mov [edi],ax
  2647                                  Xsl5:	inc ebx				;set flag whether line need redrawing
  2648                                  Xsl4:	inc edi
  2649                                  	inc edi
  2650                                  	or al,al
  2651                                  	jnz Xsl3
  2652                                  %else
  2653 00000CFB 31DB                    	xor ebx,ebx			;flag
  2654                                  %endif
  2655                                  ;-------
  2656 00000CFD A1[F02E0100]            	mov eax,[columns]
  2657 00000D02 8D4020                  	lea eax,[eax+32]		;estimated max ESC sequences extra bytes (i.e. boldlen*X) (BTW add eax,32 islonger)
  2658 00000D05 F7E1                    	mul ecx				;setting edx to 0
  2659 00000D07 8DB8[00000000]          	lea edi,[eax+screenbuffer]
  2660                                  %else
  2661                                  	xor edx,edx			;counter
  2662                                  %endif
  2663 00000D0D FC                      	cld
  2664 00000D0E BE[34370100]            	mov esi,screenline
  2665 00000D13 AC                      sl3:	lodsb
  2666 00000D14 42                      	inc edx				;count message length to write
  2667                                  %ifdef LESSWRITEOPS
  2668 00000D15 81FF[802E0000]          	cmp edi,screenbuffer_end	;never read/write beyond buffer
  2669 00000D1B 7306                    	jnb sl5
  2670 00000D1D 3A07                    	cmp al,[edi]
  2671 00000D1F 7403                    	jz sl4
  2672 00000D21 8807                    	mov [edi],al
  2673 00000D23 43                      sl5:	inc ebx				;set flag whether line need redrawing
  2674 00000D24 47                      sl4:	inc edi
  2675                                  %endif
  2676 00000D25 08C0                    	or al,al
  2677 00000D27 75EA                    	jnz sl3
  2678 00000D29 4A                      	dec edx				;one too much
  2679                                  %ifdef LESSWRITEOPS
  2680 00000D2A 09DB                    	or ebx,ebx			;redraw ?
  2681 00000D2C 743C                    	jz NoWrite
  2682                                  %endif
  2683 00000D2E 52                      	push edx
  2684 00000D2F 31D2                    	xor edx,edx
  2685 00000D31 8A35[EC2E0100]          	mov dh,byte [lines]
  2686 00000D37 28CE                    	sub dh,cl
  2687                                  %ifdef W32_EXTENDED_IO
  2688                                  	pop ebx				;len
  2689                                  	shl edx,8
  2690                                  	and edx,00ff0000h		;only line# (column is always 0)
  2691                                  	push edx			;cursor data
  2692                                  ;-------
  2693                                  	push dword w32result
  2694                                  	push edx			;cursor
  2695                                  	push ebx			;length
  2696                                  	push dword screenline
  2697                                  	push dword [hout]
  2698                                  	call WriteConsoleOutputCharacterA
  2699                                  ;-------
  2700                                  	pop edx
  2701                                  	push dword w32result
  2702                                  	push edx			;cursor
  2703                                  	push ebx			;length
  2704                                  	push dword attribline
  2705                                  	push dword [hout]
  2706                                  	call WriteConsoleOutputAttribute
  2707                                  %else
  2708                                  	;this works on both Terminal and W32, ...
  2709                                  	;...but is suboptimal and slow on W32
  2710 00000D39 E8AB050000              	call sys_writeKP		;set cursor pos before writing the line
  2711 00000D3E 5A                      	pop edx
  2712 00000D3F 51                      	push ecx
  2713 00000D40 B8[07260000]            	mov eax,screencolors1		;set bold yellow on blue
  2714 00000D45 E822000000              	call sys_writeSLColors		;special for status line (ecx==0)
  2715 00000D4A B9[34370100]            	mov ecx,screenline		;second argument: pointer to message to write
  2716 00000D4F E8820E0000              	call WriteFile0
  2717                                  ;-------
  2718 00000D54 59                      	pop ecx
  2719 00000D55 B8[F9250000]            	mov eax,screencolors0		;reset to b/w
  2720 00000D5A E80D000000              	call sys_writeSLColors		;special for status line (ecx==0)
  2721 00000D5F 8B15[042F0100]          	mov edx,[kurspos2]
  2722 00000D65 E87F050000              	call sys_writeKP		;restore old cursor pos
  2723                                  %endif
  2724                                  NoWrite:POP_ALL
  2725                              <1> NoWrite:
  2726 00000D6A 61                  <1>  popa
  2727 00000D6B C3                      	ret
  2728                                  ;-------
  2729                                  ; a helper for ScreenLineShow
  2730                                  ;
  2731                                  sys_writeSLColors:
  2732                                  %ifndef W32
  2733 00000D6C E301                    	jecxz syswSL			;do nothing if not in status line
  2734 00000D6E C3                      	ret
  2735                                  syswSL:	PUSH_ALL
  2736                              <1> syswSL: 
  2737 00000D6F 60                  <1>  pusha
  2738 00000D70 91                      	xchg eax,ecx			;parameter points to ESC-xxx color string
  2739 00000D71 6A0E                    	push byte scolorslen
  2740 00000D73 5A                      	pop edx
  2741 00000D74 E85D0E0000              	call WriteFile0
  2742                                  	POP_ALL
  2743 00000D79 61                  <1>  popa
  2744                                  %endif
  2745 00000D7A C3                      	ret
  2746                                  ;----------------------------------------------------------------------
  2747                                  ;
  2748                                  ; getting line INPUT from terminal / UNDER CONSTRUCTION
  2749                                  ;
  2750                                  ; expecting pointer to message text in esi
  2751                                  ;
  2752 00000D7B BE[12230000]            InputStringWithMessage0:mov esi,extext
  2753 00000D80 E8F50A0000              InputStringWithMessage:call WriteMess9MakeLine
  2754 00000D85 B9[C8350100]            	mov ecx,optbuffer
  2755 00000D8A 6A7C                    	push byte optslen
  2756 00000D8C 5A                      	pop edx
  2757 00000D8D EB0F                    	jmp short InputString
  2758                                  ;-------
  2759 00000D8F B9[C8330100]            InputString00:mov ecx,suchtext
  2760 00000D94 E8E10A0000              InputString0:call WriteMess9MakeLine
  2761 00000D99 BAFF000000              	mov edx,maxfilenamelen
  2762                                  ; expecting input line buffer in ecx
  2763                                  ; expecting max count byte in edx
  2764                                  ; return length in eax, CY for empty string (or user abort)
  2765                                  ;
  2766 00000D9E 51                      InputString:push ecx
  2767 00000D9F 57                      	push edi
  2768 00000DA0 6A02                    	push byte 2
  2769 00000DA2 58                      	pop eax
  2770 00000DA3 8705[80380100]          	xchg eax, [VICmdMode]
  2771 00000DA9 50                      	push eax			;LONGER: push dword [VICmdMode], mov byte [VICmdMode],2
  2772 00000DAA FF35[042F0100]          	push dword [kurspos2]
  2773 00000DB0 8B1D[F02E0100]          	mov ebx,[columns]
  2774                                  %ifndef LINUX
  2775                                  	dec ebx				;*BSD do not use lower right screen place...
  2776                                  %endif					;...due some unwanted vertical scrolling
  2777 00000DB6 8D5BF6                  	lea ebx,[ebx-stdtxtlen]
  2778 00000DB9 39DA                    	cmp edx,ebx			;TODO should enable some scrolling:
  2779 00000DBB 7202                    	jb IS8				;not yet ready, so truncate at end of line
  2780 00000DBD 89DA                    	mov edx,ebx			;edx == max chars
  2781 00000DBF 31DB                    IS8:	xor ebx,ebx			;ebx == chars in buffer
  2782 00000DC1 89CF                    	mov edi,ecx			;edi == pointer on current char
  2783                                  ;-------				;ecx == pointer to begin of readline text
  2784                                  ;
  2785 00000DC3 53                      IS0:	push ebx			;local loop starts here
  2786 00000DC4 52                      	push edx
  2787 00000DC5 51                      	push ecx
  2788                                  	PUSH_ALL
  2789 00000DC6 60                  <1>  pusha
  2790 00000DC7 89CE                    	mov esi,ecx
  2791 00000DC9 8D3D[3E370100]          	lea edi,[screenline+stdtxtlen]
  2792 00000DCF 89D9                    	mov ecx,ebx
  2793 00000DD1 FC                      	cld
  2794 00000DD2 F3A4                    	rep movsb			;copy line buffer into screen display buffer
  2795 00000DD4 89D1                    	mov ecx,edx
  2796 00000DD6 29D9                    	sub ecx,ebx
  2797 00000DD8 B020                    	mov al,32			;fill up with blanks
  2798 00000DDA F3AA                    	rep stosb
  2799                                  	POP_ALL
  2800 00000DDC 61                  <1>  popa
  2801                                  ;-------
  2802 00000DDD 89FB                    	mov ebx,edi			;next lines for setting cursor position
  2803 00000DDF 29CB                    	sub ebx,ecx
  2804 00000DE1 80C30A                  	add bl,stdtxtlen		;offset+column
  2805                                  %ifdef UTF8
  2806                                  %ifdef UTF8RTS
  2807                                  	cmp byte [isUTF8],0
  2808                                  	je noUTF_I
  2809                                  %endif
  2810 00000DE4 89CE                    	mov esi,ecx
  2811 00000DE6 AC                      ISloopUTF8:lodsb
  2812 00000DE7 24C0                    	and al,0C0h
  2813 00000DE9 3C80                    	cmp al,080h
  2814 00000DEB 7502                    	jne ISdncUTF8
  2815 00000DED FECB                    	dec bl				;do not count byte 2,3,4,....
  2816 00000DEF 39FE                    ISdncUTF8:cmp esi,edi
  2817 00000DF1 72F3                    	jb ISloopUTF8
  2818                                  noUTF_I:
  2819                                  %endif
  2820 00000DF3 8A3D[EC2E0100]          	mov bh,byte[lines]		;line#
  2821 00000DF9 891D[042F0100]          	mov [kurspos2],ebx
  2822                                  ;-------
  2823                                  %ifdef LESSWRITEOPS
  2824 00000DFF C605[00000000]00        	mov byte [screenbuffer],0	;switching off usage of buffer v0.7
  2825                                  %endif
  2826 00000E06 E8EDFEFFFF              	call StatusLineShow		;show input
  2827 00000E0B E840010000              	call GetChar			;read next
  2828 00000E10 59                      	pop ecx
  2829 00000E11 5A                      	pop edx
  2830 00000E12 5B                      	pop ebx
  2831 00000E13 FC                      	cld
  2832                                  ;-------
  2833 00000E14 E8D5FCFFFF              	call IsViMode
  2834 00000E19 7504                    	jnz NO_VI01
  2835 00000E1B 3C00                    	cmp al,0
  2836 00000E1D 7407                    	je ISA
  2837 00000E1F E8CF0C0000              NO_VI01:call CheckUserAbort
  2838 00000E24 7507                    	jne IS9
  2839 00000E26 31DB                    ISA:	xor ebx,ebx			;length 0 triggers CY flag
  2840 00000E28 E9FF000000              IS1j:	jmp IS1
  2841 00000E2D 3C0D                    IS9:	cmp al,RETURN
  2842 00000E2F 74F7                    	je IS1j
  2843 00000E31 3C08                    	cmp al,8			;^H (translated DEL)
  2844 00000E33 750F                    	jne IS2
  2845                                  DNHloopUTF8:
  2846 00000E35 39CF                    	cmp edi,ecx			;@left border?
  2847 00000E37 748A                    	je IS0
  2848                                  ;-------
  2849 00000E39 4F                      	dec edi				;go 1 left
  2850                                  %ifdef UTF8
  2851                                  %ifdef UTF8RTSx_wont			;Keep UTF8 bytes together even in deleting
  2852                                  	cmp byte [isUTF8],0
  2853                                  	je noUTF_J
  2854                                  %endif
  2855 00000E3A 8A07                    	mov al,byte [edi]		;check for UTF byte 2,3,4,..
  2856 00000E3C 24C0                    	and al,0c0h
  2857 00000E3E 3C80                    	cmp al,080h
  2858 00000E40 74F3                    	je DNHloopUTF8
  2859                                  noUTF_J:
  2860 00000E42 EB70                    	jmp Delete1
  2861                                  %else
  2862                                  	jmp short Delete1		;and continue at delete key
  2863                                  %endif
  2864                                  ;-------
  2865 00000E44 3C00                    IS2:	cmp al,0			;marker of cursor keys etc.
  2866 00000E46 0F858C000000            	jne NoSpecialKey
  2867 00000E4C 80FC05                  	cmp ah,5			;end
  2868 00000E4F 7508                    	jne NotEnd
  2869 00000E51 8D3C19                  	lea edi,[ecx+ebx]
  2870                                  IS0j:	
  2871                                  %ifdef UTF8
  2872 00000E54 E96AFFFFFF              	jmp IS0
  2873                                  %else
  2874                                  	jmp short IS0
  2875                                  %endif
  2876 00000E59 80FC00                  NotEnd:	cmp ah,0			;home
  2877 00000E5C 7504                    	jne NotHome
  2878 00000E5E 89CF                    	mov edi,ecx
  2879 00000E60 EBF2                    	jmp short IS0j
  2880 00000E62 80FC03                  NotHome	cmp ah,3			;left <-
  2881 00000E65 750F                    	jne NotLeft
  2882                                  NHloopUTF8:
  2883 00000E67 39CF                    	cmp edi,ecx
  2884 00000E69 74E9                    	je IS0j
  2885 00000E6B 4F                      	dec edi
  2886                                  %ifdef UTF8
  2887                                  %ifdef UTF8RTSx_wont			;see KeyLeft comment
  2888                                  	cmp byte [isUTF8],0
  2889                                  	je noUTF_K
  2890                                  %endif
  2891 00000E6C 8A07                    	mov al,byte [edi]
  2892 00000E6E 24C0                    	and al,0c0h
  2893 00000E70 3C80                    	cmp al,080h
  2894 00000E72 74F3                    	je NHloopUTF8
  2895                                  noUTF_K:
  2896                                  %endif
  2897 00000E74 EBDE                    	jmp short IS0j
  2898 00000E76 80FC04                  NotLeft:cmp ah,4			;right ->
  2899 00000E79 7512                    	jne NotRight
  2900 00000E7B 8D3419                  	lea esi,[ecx+ebx]
  2901                                  NLloopUTF8:
  2902 00000E7E 39F7                    	cmp edi,esi
  2903 00000E80 74D2                    	je IS0j
  2904 00000E82 47                      	inc edi
  2905                                  %ifdef UTF8
  2906                                  %ifdef UTF8RTSx_wont			;see KeyRight comment
  2907                                  	cmp byte [isUTF8],0
  2908                                  	je near IS0
  2909                                  %endif
  2910 00000E83 8A07                    	mov al,byte [edi]
  2911 00000E85 24C0                    	and al,0c0h
  2912 00000E87 3C80                    	cmp al,080h
  2913 00000E89 74F3                    	je NLloopUTF8
  2914                                  noUTF_L:
  2915                                  %endif
  2916 00000E8B EBC7                    IS0jj:	jmp short IS0j
  2917 00000E8D 80FC08                  NotRight:cmp ah,8			;Insert
  2918 00000E90 751D                    	jne NotIns
  2919 00000E92 F615[582F0100]          	not byte [insstat]
  2920                                  %ifdef NEW_CURSOR_MGNT
  2921 00000E98 803D[582F0100]01        	cmp byte [insstat],1
  2922 00000E9F 7507                    	jne short NCM
  2923 00000EA1 E8090D0000              	call SetCursorBlock
  2924 00000EA6 EBAC                    	jmp short IS0j
  2925 00000EA8 E8F80C0000              NCM:	call SetCursorNormal
  2926                                  %endif
  2927 00000EAD EBA5                    	jmp short IS0j
  2928 00000EAF 80FC09                  NotIns:	cmp ah,9			;Del
  2929 00000EB2 7524                    	jne NoSpecialKey
  2930 00000EB4 8D3419                  Delete1:lea esi,[ecx+ebx]		;do not delete at last character position
  2931 00000EB7 39F7                    	cmp edi,esi			;...or in empty buffer...
  2932 00000EB9 74D0                    	je IS0jj
  2933                                  %ifdef UTF8
  2934 00000EBB 51                      	push ecx
  2935 00000EBC 57                      	push edi
  2936 00000EBD 56                      	push esi
  2937 00000EBE 89D9                    	mov ecx,ebx			;TODO: check this
  2938 00000EC0 8D7701                  	lea esi,[edi+1]
  2939 00000EC3 4B                      	dec ebx				;decrease char count in buffer	
  2940                                  DeloopUTF8:
  2941                                  %ifdef UTF8RTSx_wont			;Keep UTF8 bytes together even in deleting
  2942                                  	cmp byte [isUTF8],0
  2943                                  	je noUTF_M
  2944                                  %endif
  2945 00000EC4 8A06                    	mov al,byte [esi]
  2946 00000EC6 24C0                    	and al,0C0h
  2947 00000EC8 3C80                    	cmp al,080h
  2948 00000ECA 7504                    	jne DeUTF8
  2949 00000ECC 46                      	inc esi				;delete one more at UTF-8 byte 2,3,4,....
  2950 00000ECD 4B                      	dec ebx				;decrease char count in buffer
  2951 00000ECE EBF4                    	jmp short DeloopUTF8
  2952                                  noUTF_M:
  2953 00000ED0 FC                      DeUTF8:	cld
  2954 00000ED1 F3A4                    	rep movsb			;move all in buffer 1 char to left
  2955 00000ED3 5E                      	pop esi
  2956 00000ED4 5F                      	pop edi
  2957 00000ED5 59                      	pop ecx
  2958                                  %else
  2959                                  	PUSH_ALL
  2960                                  	mov ecx,ebx			;TODO: check this
  2961                                  	lea esi,[edi+1]
  2962                                  	cld
  2963                                  	rep movsb			;move all in buffer 1 char to left
  2964                                  	POP_ALL
  2965                                  	dec ebx				;decrease char count in buffer
  2966                                  %endif
  2967 00000ED6 EBB3                    	jmp short IS0jj
  2968                                  ;-------
  2969                                  NoSpecialKey:
  2970 00000ED8 3C20                    	cmp al,SPACECHAR
  2971 00000EDA 72AF                    	jb short IS0jj
  2972                                  
  2973                                  %ifdef UTF8
  2974                                  %ifdef UTF8RTSx_wont			;Keep UTF8 bytes together
  2975                                  	cmp byte [isUTF8],0
  2976                                  	je noUTF_N
  2977                                  %endif
  2978 00000EDC 53                      	push ebx
  2979 00000EDD 88C3                    	mov bl,al
  2980 00000EDF 80E3C0                  	and bl,0C0h
  2981 00000EE2 80FB80                  	cmp bl,080h			;byte 2,3,4.. always insert
  2982 00000EE5 5B                      	pop ebx
  2983 00000EE6 7410                    	je INSrt
  2984                                  noUTF_N:
  2985                                  %endif
  2986 00000EE8 803D[582F0100]01        	cmp byte [insstat],1
  2987 00000EEF 7407                    	jz INSrt
  2988 00000EF1 8D3419                  	lea esi,[ecx+ebx]
  2989 00000EF4 39F7                    	cmp edi,esi
  2990 00000EF6 7513                    	jnz NO_INSERT
  2991                                  INSrt:	PUSH_ALL
  2992                              <1> INSrt: 
  2993 00000EF8 60                  <1>  pusha
  2994 00000EF9 89F8                    	mov eax,edi
  2995 00000EFB 8D7C1101                	lea edi,[ecx+edx+1]		;end of buffer space
  2996 00000EFF 8D77FF                  	lea esi,[edi-1]
  2997 00000F02 89F9                    	mov ecx,edi
  2998 00000F04 29C1                    	sub ecx,eax
  2999 00000F06 FD                      	std
  3000 00000F07 F3A4                    	rep movsb			;move all in buffer 1 char to right
  3001                                  	POP_ALL
  3002 00000F09 61                  <1>  popa
  3003 00000F0A 43                      	inc ebx
  3004 00000F0B FC                      NO_INSERT:cld
  3005 00000F0C AA                      	stosb
  3006                                  %ifdef UTF8
  3007                                  %ifdef UTF8RTSx_wont			;Keep UTF8 bytes together
  3008                                  	cmp byte [isUTF8],0
  3009                                  	je noUTF_O
  3010                                  %endif
  3011 00000F0D 89FE                    	mov esi,edi
  3012 00000F0F 4E                      	dec esi
  3013 00000F10 46                      NI_loopUTF8:inc esi
  3014 00000F11 8A06                    	mov al,byte [esi]
  3015 00000F13 24C0                    	and al,0C0h
  3016 00000F15 3C80                    	cmp al,080h			;delete byte 2,3,4,....
  3017 00000F17 74F7                    	je NI_loopUTF8
  3018                                  ;-------
  3019 00000F19 39FE                    	cmp esi,edi
  3020 00000F1B 7407                    	je NI_UTF8rdy
  3021                                  	PUSH_ALL
  3022 00000F1D 60                  <1>  pusha
  3023 00000F1E 89D9                    	mov ecx,ebx			;TODO: check this
  3024 00000F20 FC                      	cld
  3025 00000F21 F3A4                    	rep movsb			;move all in buffer 1 char to left
  3026                                  	POP_ALL
  3027 00000F23 61                  <1>  popa
  3028                                  noUTF_O:
  3029                                  NI_UTF8rdy:
  3030                                  %endif
  3031 00000F24 39D3                    	cmp ebx,edx
  3032 00000F26 0F8228FFFFFF            	jb IS0j
  3033                                  ;-------
  3034 00000F2C 31C0                    IS1:	xor eax,eax
  3035 00000F2E 880419                  	mov byte [ecx+ebx],al		;make asciz string
  3036 00000F31 8F05[042F0100]          	pop dword [kurspos2]
  3037 00000F37 8F05[80380100]          	pop dword [VICmdMode]		;restore original vi mode
  3038 00000F3D 5F                      	pop edi
  3039 00000F3E 59                      	pop ecx
  3040 00000F3F 93                      	xchg eax,ebx
  3041 00000F40 3C01                    	cmp al,1			;set cy flag if empty string (len always <256)
  3042 00000F42 C3                      ISready:ret				;eax length (but is < 255)
  3043                                  ;----------
  3044                                  ;
  3045                                  ; GetChar (main function for kbd input)
  3046                                  ;
  3047 00000F43 89F8                    ReadChar:mov eax,edi
  3048 00000F45 8705[242F0100]          	xchg eax,[old] 			;for ^QP
  3049 00000F4B A3[282F0100]            	mov [veryold],eax
  3050 00000F50 E8FB000000              GetChar:call ReadOneChar		;ah=0xFF for usual keys
  3051                                  %ifdef W32
  3052                                  	cmp ah,0FEh			;cursor key		
  3053                                  	jnz GC33
  3054                                  	shl eax,8
  3055                                  	ret
  3056                                  GC33:	cmp ah,0FDh			;ALT key
  3057                                  	jnz GC34
  3058                                  	and al,5fh			;toupper
  3059                                  	jmp short NOVI7
  3060                                  GC34:
  3061                                  %endif
  3062 00000F55 3C7F                    	cmp al,7Fh
  3063 00000F57 7502                    	jne short RC_No7F		;special case: remap DEL to Ctrl-H
  3064                                  %ifndef FREEBSD
  3065 00000F59 B008                    	mov al,8
  3066                                  %else
  3067                                  	mov al,7
  3068                                  %endif
  3069                                  RC_No7F:
  3070                                  ;-------
  3071                                  %define DoNo 10
  3072                                  ;-------
  3073                                  ;
  3074                                  ; vi needs special handling of the ESC key
  3075                                  ;
  3076 00000F5B E88EFBFFFF              	call IsViMode
  3077 00000F60 740B                    	jz short ISVI7
  3078 00000F62 3C1B                    	cmp al,27 			;ESC ?
  3079 00000F64 75DC                    	jnz ISready
  3080 00000F66 E8E5000000              	call ReadOneChar		;dont care whether '[' or 'O' (should be [ for vt220 family  O for vt100 family)
  3081 00000F6B EB5B                    	jmp short NOVI7
  3082                                  ;-------
  3083 00000F6D 803D[80380100]01        ISVI7:	cmp byte [VICmdMode],1
  3084 00000F74 7525                    	jne NoCMDmode
  3085 00000F76 3C1B                    	cmp al,27
  3086 00000F78 7412                    	je ESCpressed
  3087 00000F7A 3C7B                    	cmp al,VIsize
  3088 00000F7C 0F8799000000            	ja near Other
  3089 00000F82 BB[4C230000]            	mov ebx,VIcmdTable		;process command mode keys......
  3090 00000F87 E9BA000000              	jmp RCready_0			;....and ready
  3091                                  ;-------
  3092 00000F8C E8BF000000              ESCpressed:call ReadOneChar
  3093 00000F91 3C5B                    	cmp al,'['			;decide: it's a cursor key?
  3094 00000F93 0F8482000000            	je near Other			;yes, contine
  3095 00000F99 EB1B                    	jmp short NoCursorKey		;no push back char into buffer and exit
  3096 00000F9B 3C1B                    NoCMDmode:cmp al,27 			;ESC ?
  3097 00000F9D 75A3                    	jnz ISready
  3098 00000F9F E806FBFFFF              	call KeyVImode1			;ESC pressed in EDIT Mode
  3099                                  %ifdef BEOS
  3100                                  	call RestoreStatusLine
  3101                                  %else
  3102                                  %ifdef SYS_select
  3103                                  	PUSH_ALL
  3104 00000FA4 60                  <1>  pusha
  3105 00000FA5 E8730C0000              	call Select			;differ between ESC and ESC_cursor_keys
  3106                                  	POP_ALL
  3107 00000FAA 61                  <1>  popa
  3108 00000FAB 7412                    	jz isSingleEscape
  3109                                  %endif
  3110                                  %endif
  3111 00000FAD E89E000000              	call ReadOneChar
  3112 00000FB2 3C5B                    	cmp al,'['			;starting sequence of cursor key found?
  3113 00000FB4 740D                    	je IsCursorKey			;pressed ESC, but do _NOT_ switch init cmd mode
  3114 00000FB6 A2[84380100]            NoCursorKey:mov byte [VIbufch],al	;push char back into read buffer due it's not a cursor key
  3115 00000FBB B00A                    	mov al,DoNo			;do nothing
  3116 00000FBD EB2F                    	jmp short JmpRCready
  3117 00000FBF B003                    isSingleEscape:mov al,3			;3 is keyLeft (i.e. entry #3 jumptab1)
  3118 00000FC1 EB2B                    	jmp short JmpRCready		;keyLeft is what a real vi user expects here ;)
  3119                                  ;-------
  3120 00000FC3 E88DFAFFFF              IsCursorKey:call KeyVImode0		;reset mode to 'no_command' and continue
  3121                                  ;-------
  3122 00000FC8 803D[A0380100]10        NOVI7:	cmp byte [mode],NE		;ALT keys are currently used for nedit mode...
  3123 00000FCF 7510                    	jnz NONE7
  3124 00000FD1 3C69                    	cmp al,'i'
  3125 00000FD3 7504                    	jnz NOi
  3126 00000FD5 B010                    	mov al,0x10
  3127 00000FD7 EB15                    	jmp short JmpRCready
  3128 00000FD9 3C49                    NOi:	cmp al,'I'
  3129 00000FDB 7504                    	jnz NONE7
  3130 00000FDD B010                    	mov al,0x10
  3131 00000FDF EB0D                    	jmp short JmpRCready
  3132 00000FE1 E810FBFFFF              NONE7:	call IsEmMode
  3133 00000FE6 7529                    	jnz NOEM7			;ALT keys are currently used for Emacs mode...
  3134 00000FE8 3C25                    	cmp al,'%'			;...except altH for online Help
  3135 00000FEA 7504                    	jne NoAltPer
  3136 00000FEC B028                    	mov al,0x28
  3137 00000FEE EB57                    JmpRCready:jmp short RCready_1
  3138 00000FF0 3C3C                    NoAltPer:cmp al,'<'
  3139 00000FF2 7504                    	jne NoAltLt
  3140 00000FF4 B00E                    	mov al,0x0e
  3141 00000FF6 EB4F                    	jmp short RCready_1
  3142 00000FF8 3C3E                    NoAltLt:cmp al,'>'
  3143 00000FFA 7504                    	jne NoAltGt
  3144 00000FFC B00F                    	mov al,0x0f
  3145 00000FFE EB47                    	jmp short RCready_1
  3146 00001000 245F                    NoAltGt:and al,0x5F			;to upper case
  3147 00001002 2C42                    	sub al,'B'			;1at in table
  3148 00001004 7815                    	js Other
  3149 00001006 3C17                    	cmp al,ATsize
  3150 00001008 7711                    	ja Other
  3151 0000100A BB[35230000]            	mov ebx,EmaAltTable
  3152 0000100F EB35                    	jmp short RCready_0
  3153 00001011 245F                    NOEM7:	and al,0x5F
  3154 00001013 3C48                    	cmp al,'H'
  3155 00001015 7504                    	jnz Other
  3156 00001017 B03D                    	mov al,0x3D
  3157 00001019 EB2C                    	jmp short RCready_1
  3158                                  ;-------
  3159                                  Other:	
  3160                                  %ifdef W32
  3161                                  	ret
  3162                                  %else
  3163 0000101B E830000000              	call ReadOneChar
  3164 00001020 3C38                    	cmp al,'8'
  3165 00001022 770D                    	ja NoNumber
  3166 00001024 50                      	push eax			;0,1,2....8  (i.e. 9 keys)
  3167 00001025 E826000000              	call ReadOneChar
  3168 0000102A 93                      	xchg eax,ebx
  3169 0000102B 58                      	pop eax
  3170 0000102C 80FB7E                  	cmp bl,'~'			;if it's a number we expect following a '~'
  3171 0000102F 751A                    	jne GetCharJmp
  3172 00001031 2C30                    NoNumber:sub al,'0'
  3173 00001033 3C09                    	cmp al,9
  3174 00001035 720A                    	jb IsNumber
  3175                                  %ifdef QNX
  3176                                  	sub al,('@'-'0'-9)		;scantable starts with ESC[@
  3177                                  %else
  3178 00001037 2C08                    	sub al,('A'-'0'-9)
  3179                                  %endif
  3180 00001039 3C09                    	cmp al,9
  3181 0000103B 720E                    	jb GetCharJmp
  3182 0000103D 3C11                    	cmp al,STsize
  3183 0000103F 770A                    	ja GetCharJmp
  3184 00001041 BB[24230000]            IsNumber:mov ebx,ScanTable
  3185                                  %endif
  3186 00001046 D7                      RCready_0:xlatb
  3187 00001047 C1E008                  RCready_1:shl eax,8			;shift into ah (ah always != 0xFF)
  3188 0000104A C3                      	ret
  3189 0000104B E900FFFFFF              GetCharJmp:jmp near GetChar
  3190                                  ;-------
  3191                                  ; called by ReadChar/GetChar
  3192                                  ;
  3193 00001050 E899FAFFFF              ReadOneChar:call IsViMode
  3194 00001055 750C                    	jnz NOVI4
  3195 00001057 31C0                    	xor eax,eax
  3196 00001059 8705[84380100]          	xchg eax,[VIbufch]		;preread char in buf?
  3197 0000105F 09C0                    	or eax,eax
  3198 00001061 750F                    	jne RoneC
  3199 00001063 B9[4C2F0100]            NOVI4:	mov ecx,read_b			;pointer to buf
  3200 00001068 31D2                    	xor edx,edx
  3201 0000106A 42                      	inc edx				;mov edx,1  (length)
  3202 0000106B E85D0B0000              	call ReadFile0
  3203                                  %ifdef SELFTEST				;for NON_INTERACTIVE mode exit on EOF!
  3204                                  	jnz Cont
  3205                                  	jmp KeyCtrlKX
  3206                                  Cont:
  3207                                  %endif
  3208 00001070 8B01                    	mov eax,[ecx]			;[read_b]
  3209                                  %ifdef W32_EXTENDED_IO
  3210                                  	ret
  3211                                  %endif
  3212 00001072 B4FF                    RoneC:	mov ah,0xFF
  3213 00001074 C3                      	ret
  3214                                  ;----------------------------------------------------------------------
  3215                                  ;
  3216                                  ; L O O K functions
  3217                                  ; search special text locations and set register edi to
  3218                                  ;
  3219                                  LookBackward:				;set EDI to 1 before LINEFEED (0Ah) i.e., 2 before start of next line
  3220 00001075 51                      	push ecx
  3221 00001076 53                      	push ebx
  3222 00001077 31DB                    	xor ebx,ebx
  3223 00001079 807FFF0A                	cmp byte[edi-1],NEWLINE		;at BOL ?
  3224 0000107D 741D                    	jz LBa3
  3225 0000107F 803F0A                  	cmp byte[edi],NEWLINE		;at EOL ?
  3226 00001082 7502                    	jnz LBa1
  3227 00001084 4F                      	dec edi				;at EOL ? start search 1 char earlier
  3228 00001085 43                      	inc ebx				;increase counter
  3229                                  ;-------
  3230 00001086 B99F860100              LBa1:	mov ecx,99999
  3231 0000108B B00A                    	mov al,NEWLINE
  3232 0000108D FD                      	std
  3233 0000108E F2AE                    	repne scasb
  3234 00001090 8D839D860100            	lea eax,[ebx+99997]		;mov eax,99997 / add eax,ebx
  3235 00001096 29C8                    	sub eax,ecx
  3236 00001098 5B                      LBa5:	pop ebx
  3237 00001099 59                      	pop ecx
  3238 0000109A EB20                    	jmp short CheckBof
  3239                                  ;-------
  3240 0000109C 31C0                    LBa3:	xor eax,eax
  3241 0000109E 4F                      	dec edi
  3242 0000109F 4F                      	dec edi
  3243 000010A0 EBF6                    	jmp short LBa5
  3244                                  ;-------
  3245                                  LookForward:
  3246 000010A2 51                      	push ecx			;don't touch edx (if called by BZNLoop only)
  3247 000010A3 B99F860100              	mov ecx,99999
  3248 000010A8 B00A                    	mov al,NEWLINE
  3249 000010AA FC                      	cld
  3250 000010AB F2AE                    	repne scasb
  3251 000010AD B89E860100              	mov eax,99998
  3252 000010B2 29C8                    	sub eax,ecx
  3253 000010B4 59                      	pop ecx
  3254 000010B5 4F                      	dec edi
  3255 000010B6 39EF                    CheckEof:cmp edi,ebp			;ptr is eof-ptr?
  3256 000010B8 7511                    	jnz CheckEnd			;Z flag if eof
  3257 000010BA EB08                    	jmp short CheckENum
  3258 000010BC 81FF[EC3C0100]          CheckBof:cmp edi, sot-1
  3259 000010C2 7707                    	ja CheckEnd
  3260 000010C4 C605[482F0100]01        CheckENum:mov byte [numeriere],1	;if bof
  3261 000010CB C3                      CheckEnd:ret
  3262                                  ;-------
  3263 000010CC 8B15[042F0100]          LookPgBegin:mov edx,[kurspos2]		;called by DispNewScreen to get sync with 1st char on screen
  3264 000010D2 0FB6CE                  	movzx ecx,dh			;called by KeyCtrlQE  (go upper left)   OLD: xor ecx,ecx mov cl,dh
  3265 000010D5 41                      	inc ecx				;'inc cl' are 2 Bytes
  3266 000010D6 EB34                    	jmp short LookPU2
  3267                                  ;-------
  3268 000010D8 8B15[042F0100]          LookPgEnd:mov edx,[kurspos2]		;goes 1st char last line on screen
  3269 000010DE 8B0D[EC2E0100]          	mov ecx,[lines]
  3270 000010E4 28F1                    	sub cl,dh
  3271 000010E6 EB5E                            jmp short LookPD2
  3272                                  ;-------
  3273 000010E8 6A02                    LookLineUp:push byte 2			;2 lines: THIS line and line BEFORE
  3274 000010EA 59                      	pop ecx
  3275 000010EB FF0D[2C2F0100]          	dec dword [linenr]
  3276 000010F1 EB19                    	jmp short LookPU2
  3277                                  ;-------
  3278 000010F3 6A02                    LookLineDown:push byte 2		;2 lines: THIS and NEXT line
  3279 000010F5 59                      	pop ecx
  3280 000010F6 FF05[2C2F0100]          	inc dword [linenr]
  3281 000010FC EB48                    	jmp short LookPD2
  3282                                  ;-------
  3283 000010FE 8B0D[EC2E0100]          LookPageUp:mov ecx,[lines]
  3284 00001104 49                      	dec ecx				;PgUp,PgDown one line less
  3285 00001105 290D[2C2F0100]          LookPU1:sub [linenr],ecx
  3286 0000110B 41                      	inc ecx
  3287 0000110C E864FFFFFF              LookPU2:call LookBackward
  3288 00001111 47                      	inc edi				;inc keeps CY flag!
  3289 00001112 7202                    	jb LookPUEnd			;if BOF
  3290 00001114 E2F6                    	loop LookPU2			;after loop edi points to char left of LINEFEED (0ah)
  3291 00001116 47                      LookPUEnd:inc edi			;now points to 1st char on screen or line
  3292 00001117 C3                      	ret
  3293                                  ;-------
  3294 00001118 31C9                    LookScrDn:xor ecx,ecx
  3295 0000111A 41                      	inc ecx
  3296 0000111B EB22                    	jmp short LookPD1
  3297 0000111D 31C9                    LookScrUp:xor ecx,ecx
  3298 0000111F 41                      	inc ecx
  3299 00001120 EBE3                    	jmp short LookPU1
  3300 00001122 8B0D[EC2E0100]          LookHalfPgUp:mov ecx,[lines]		;vi special
  3301 00001128 49                      	dec ecx
  3302 00001129 D1E9                    	shr ecx,1
  3303 0000112B EBD8                    	jmp short LookPU1
  3304 0000112D 8B0D[EC2E0100]          LookHalfPgDn:mov ecx,[lines]
  3305 00001133 49                      	dec ecx
  3306 00001134 D1E9                    	shr ecx,1
  3307 00001136 EB07                    	jmp short LookPD1
  3308                                  ;-------
  3309 00001138 8B0D[EC2E0100]          LookPgDown:mov ecx,[lines]
  3310 0000113E 49                      	dec ecx				;PgUp,PgDown one line less
  3311 0000113F 010D[2C2F0100]          LookPD1:add [linenr],ecx
  3312 00001145 41                      	inc ecx
  3313 00001146 E857FFFFFF              LookPD2:call LookForward
  3314 0000114B 7404                    	jz LookPDEnd			;(jmp if EOF)
  3315 0000114D 47                      	inc edi				;1st char next line
  3316 0000114E E2F6                    	loop LookPD2
  3317 00001150 4F                      	dec edi				;last char last line
  3318 00001151 29C7                    LookPDEnd:sub edi,eax			;1st char last line
  3319 00001153 C3                      	ret
  3320                                  ;----------------------------------------------------------------------
  3321                                  ;
  3322                                  ; some more CHECK functions
  3323                                  ;
  3324 00001154 803D[302F0100]01        CheckBlock:cmp byte [showblock],1	;returns CY if error else ok: NC
  3325 0000115B 7222                    	jc CheckBlockEnd
  3326 0000115D 8B35[1C2F0100]          	mov esi,[blockende]
  3327 00001163 81FE[ED3C0100]          	cmp esi, sot
  3328 00001169 7214                    	jb CheckBlockEnd
  3329 0000116B 8B35[182F0100]          	mov esi,[blockbegin]		;side effect esi points to block begin
  3330 00001171 81FE[ED3C0100]          	cmp esi, sot
  3331 00001177 7206                    	jb CheckBlockEnd
  3332 00001179 3935[1C2F0100]          	cmp [blockende],esi     	;^KK > ^KB ..OK if above!
  3333 0000117F C3                      CheckBlockEnd:ret
  3334                                  ;-------
  3335 00001180 393D[182F0100]          CheckImBlock:cmp [blockbegin],edi	;^KB mark > edi ?
  3336 00001186 7706                    	ja CImBlockEnd			;OK
  3337 00001188 3B3D[1C2F0100]          	cmp edi,[blockende]		;edi > ^KK
  3338 0000118E C3                      CImBlockEnd:ret	          		;output:cy error / nc ok inside block
  3339                                  ;-------
  3340 0000118F 803F0A                  CheckMode:cmp byte [edi],NEWLINE	;checks for INSERT status
  3341 00001192 7407                    	jz ChModeEnd
  3342 00001194 803D[582F0100]01        	cmp byte [insstat],1
  3343 0000119B C3                      ChModeEnd:ret				;Z flag for ins-mode
  3344                                  ;-------
  3345                                  ; a special case called by DeleteByteCheckMarker
  3346                                  ;
  3347                                  CheckMarker:				;edx is blockbegin (^KB)
  3348                                  					;ebx is deleate area end --- edi delete area start
  3349 0000119C 39D7                    	cmp edi,edx			;delete area start < ^KB marker ?
  3350 0000119E 7706                    	ja CMEnd			;no
  3351 000011A0 39D3                    	cmp ebx,edx			;yes, but delete area end > ^KB ?
  3352 000011A2 7202                    	jb CMEnd			;no
  3353 000011A4 89FA                    	mov edx,edi			;yes so block start (^KB) to delete area start
  3354 000011A6 C3                      CMEnd:	ret
  3355                                  ;----------------------------------------------------------------------
  3356                                  ;
  3357                                  ; C O U N T  functions
  3358                                  ; to return number of chars up to some place
  3359                                  ; (all of them are wrappers of Look....functions anyway)
  3360                                  ;
  3361 000011A7 57                      CountToLineEnd:push edi
  3362 000011A8 E8F5FEFFFF              	call LookForward
  3363 000011AD 5F                      	pop edi
  3364 000011AE C3                      	ret				;eax=chars up to line end
  3365                                  ;-------
  3366                                  CountColToLineBeginVis:			;counts columns represented by chars in EAX
  3367 000011AF E832000000              	call CountToLineBegin		;i.e. EXPAND any TAB chars found
  3368 000011B4 56                      	push esi
  3369 000011B5 31D2                    	xor edx,edx
  3370 000011B7 89FE                    	mov esi,edi			;startpoint
  3371 000011B9 29C6                    	sub esi,eax			;to bol
  3372 000011BB 4E                      	dec esi
  3373 000011BC 46                      CCV1:	inc esi
  3374 000011BD 39FE                    	cmp esi,edi
  3375 000011BF 731B                    	jae CCVend
  3376                                  %ifdef UTF8
  3377                                  %ifdef UTF8RTS
  3378                                  	cmp byte [isUTF8],0
  3379                                  	je noUTF_P
  3380                                  %endif
  3381 000011C1 8A1E                    	mov bl,byte [esi]
  3382 000011C3 80E3C0                  	and bl,0C0h
  3383 000011C6 80FB80                  	cmp bl,080h			;do not count byte 2,3,4,.. in UTF8 chars
  3384 000011C9 74F1                    	jz CCV1
  3385                                  noUTF_P:
  3386                                  %endif
  3387 000011CB 803E09                  	cmp byte [esi],TABCHAR
  3388 000011CE 7403                    	jz CCVTab
  3389 000011D0 42                      	inc edx				;count visible chars
  3390 000011D1 EBE9                    	jmp short CCV1
  3391 000011D3 E8D9080000              CCVTab:	call SpacesForTab		;return space_up_to_next_tab in ah
  3392 000011D8 00E2                    	add dl,ah			;FIXME: now using 8 bits only
  3393 000011DA EBE0                    	jmp short CCV1
  3394 000011DC 8915[442F0100]          CCVend: mov [ch2linebeg],edx		;ch2linebeg: interface to Key... functions
  3395 000011E2 89D0                    	mov eax,edx			;eax: interface to DispNewScreen
  3396 000011E4 5E                      	pop esi
  3397                                  %ifdef W32LF
  3398                                  	cmp byte[edi-1],RETURN
  3399                                  	jnz CCV2
  3400                                  	dec byte [ch2linebeg]		;don't count in RETURN char
  3401                                  CCV2:	
  3402                                  %endif
  3403 000011E5 C3                      	ret
  3404                                  ;-------
  3405 000011E6 57                      CountToLineBegin:push edi		;output eax=chars up there
  3406 000011E7 E889FEFFFF              	call LookBackward
  3407 000011EC 89FE                    	mov esi,edi			;side effect: set edi to 1st char in line
  3408 000011EE 5F                      	pop edi
  3409 000011EF C3                      	ret
  3410                                  ;-------
  3411                                  CountToWordBeginVIstyle:		;output eax=chars up there
  3412 000011F0 89FE                    	mov esi,edi
  3413 000011F2 803E20                  	cmp byte [esi],SPACECHAR
  3414 000011F5 771C                    	ja CtWviStyle
  3415                                  CountToWordBegin:			;output eax=chars up there
  3416 000011F7 89FE                    	mov esi,edi
  3417 000011F9 39EE                    CountNLoop:cmp esi,ebp
  3418 000011FB 7411                    	jz CTWend
  3419 000011FD 46                      	inc esi
  3420                                  %ifdef W32LF
  3421                                  	cmp byte [esi],RETURN
  3422                                  %else
  3423 000011FE 803E0A                  	cmp byte [esi],NEWLINE
  3424                                  %endif
  3425 00001201 740B                    	jz CTWend
  3426 00001203 803E20                  	cmp byte [esi],SPACECHAR	;below SPACE includes tab chars
  3427 00001206 76F1                    	jbe CountNLoop
  3428 00001208 807EFF2F                	cmp byte [esi-1],2fh
  3429 0000120C 77EB                    	ja CountNLoop
  3430 0000120E 89F0                    CTWend:	mov eax,esi
  3431 00001210 29F8                    	sub eax,edi			;maybe =0
  3432 00001212 C3                      Goret:	ret
  3433                                  ;-------
  3434 00001213 46                      CtWviStyle:inc esi
  3435                                  %ifdef W32LF
  3436                                  	cmp byte [esi],RETURN
  3437                                  %else
  3438 00001214 803E0A                  	cmp byte [esi],NEWLINE
  3439                                  %endif
  3440 00001217 74F5                    	jz CTWend
  3441 00001219 803E2F                  	cmp byte [esi],2fh
  3442 0000121C 77F5                    	ja CtWviStyle
  3443 0000121E EBD9                    	jmp short CountNLoop
  3444                                  ;----------------------------------------------------------------------
  3445                                  ;
  3446                                  ; Online Help: show the message followed by common text
  3447                                  ;
  3448                                  KeyHelp:
  3449                                  %ifdef USE_BUILTINHELP
  3450 00001220 FF35[002F0100]          	push dword [kurspos]
  3451                                  	PUSH_ALL
  3452 00001226 60                  <1>  pusha
  3453 00001227 31C0                    	xor eax,eax
  3454 00001229 8705[302F0100]          	xchg eax,[showblock]		;hide an blockmarker
  3455 0000122F 50                      	push eax
  3456 00001230 FC                      	cld
  3457 00001231 BE[ED3C0100]            	mov esi,sot			;save "buffercopysize" of text
  3458 00001236 BF[B0380100]            	mov edi,buffercopy
  3459 0000123B B900040000              	mov ecx,buffercopysize
  3460 00001240 57                      	push edi
  3461 00001241 51                      	push ecx
  3462 00001242 56                      	push esi
  3463                                  ;-------
  3464 00001243 F3A4                    	rep movsb
  3465 00001245 E877080000              	call GetHelpText
  3466 0000124A 5F                      	pop edi
  3467 0000124B 57                      	push edi			;i.e. mov edi,sot
  3468                                  ;-------
  3469 0000124C 57                      	push edi
  3470 0000124D F3A4                    	rep movsb			;overwrite saved text with help message
  3471 0000124F BE[8C260000]            	mov esi,helpfoot
  3472 00001254 6A19                    	push byte helpfootsize
  3473 00001256 59                      	pop ecx
  3474 00001257 F3A4                    	rep movsb
  3475 00001259 89FD                    	mov ebp,edi			;set END_OF_HELP_TEXT pointer
  3476 0000125B 5F                      	pop edi
  3477 0000125C E89DF8FFFF              	call DispNewScreen
  3478 00001261 E8EAFDFFFF              	call ReadOneChar		;wait for a pressed char
  3479                                  ;-------
  3480 00001266 5F                      	pop edi
  3481 00001267 59                      	pop ecx
  3482 00001268 5E                      	pop esi				;former edi
  3483 00001269 FC                      	cld
  3484 0000126A F3A4                    	rep movsb			;restore textbuffer with saved patr
  3485 0000126C 8F05[302F0100]          	pop dword [showblock]
  3486                                  	POP_ALL
  3487 00001272 61                  <1>  popa
  3488 00001273 5A                      	pop edx				;cursor pos
  3489 00001274 EB6D                    	jmp short SetKursPos
  3490                                  %else
  3491                                  	ret
  3492                                  %endif
  3493                                  ;---------------------------------------------------------------------
  3494                                  ;
  3495                                  ; some CURSOR control functions
  3496                                  ;
  3497 00001276 31C0                    GoUp:	xor eax,eax
  3498 00001278 EB08                    	jmp short UpDown
  3499 0000127A A0[EC2E0100]            GoDown:	mov al,byte [lines]
  3500 0000127F 48                      	dec eax				;'dec al' are 2 byte!
  3501 00001280 B4FF                    	mov ah,-1
  3502 00001282 8B15[042F0100]          UpDown:	mov edx,[kurspos2]		;former was call getkurspos
  3503 00001288 38F0                    	cmp al,dh
  3504 0000128A 7486                    	jz Goret
  3505 0000128C 18E6                    	sbb dh,ah			;ONLY here we change curent line of cursor
  3506 0000128E EB53                    	jmp short SetKursPos
  3507                                  ;-------
  3508                                  ; set cursor to some desired places
  3509                                  ;
  3510 00001290 E8BBFDFFFF              KeyVICmdz:call ReadOneChar
  3511 00001295 3C2E                    	cmp al,'.'
  3512 00001297 7419                    	je KeyEmaCtrlL
  3513 00001299 C3                      	ret
  3514                                  ;-------
  3515 0000129A E82DFEFFFF              KeyVI_M:call LookPgBegin
  3516 0000129F E889FEFFFF              	call LookHalfPgDn
  3517 000012A4 F605[EC2E0100]01        	test byte[lines],1
  3518 000012AB 7505                    	jnz KeyEmaCtrlL
  3519 000012AD E841FEFFFF              	call LookLineDown
  3520                                  ;------- cont
  3521 000012B2 E82FFFFFFF              KeyEmaCtrlL:call CountToLineBegin
  3522 000012B7 8A35[EC2E0100]          	mov dh,byte [lines]		;move cursor to center line (and later redisplay)
  3523 000012BD D0EE                    	shr dh,1
  3524 000012BF 88C2                    	mov dl,al
  3525 000012C1 EB20                    	jmp short SetKursPos
  3526 000012C3 31D2                    KursorFirstLine:xor edx,edx
  3527 000012C5 EB1C                    	jmp short SetKursPos
  3528 000012C7 8A35[EC2E0100]          KursorLastLine:mov dh,byte [lines]
  3529 000012CD FECE                    	dec dh
  3530 000012CF B200                    	mov dl,0
  3531 000012D1 EB10                    	jmp short SetKursPos
  3532 000012D3 8A35[EC2E0100]          KursorStatusLine:mov dh,byte [lines]
  3533 000012D9 B20A                    	mov dl,stdtxtlen
  3534 000012DB EB06                    	jmp short SetKursPos
  3535 000012DD 8B15[002F0100]          RestKursPos:mov edx,[kurspos]
  3536 000012E3 8915[042F0100]          SetKursPos:mov [kurspos2],edx      	;saves reading cursor pos   (0,0)
  3537                                  sys_writeKP:PUSH_ALL
  3538                              <1> sys_writeKP:
  3539 000012E9 60                  <1>  pusha
  3540                                  %ifdef W32
  3541                                  	shl edx,8			;linux cursorpos in dh/dl   -   w32 in edx 2*16bit
  3542                                  	mov dl,dh
  3543                                  	and edx,0x00FF00FF
  3544                                  	push dword edx			;xxxxyyyy x=line y=column
  3545                                  	push dword [hout]
  3546                                  	call SetConsoleCursorPosition
  3547                                  %else
  3548 000012EA E80F000000              	call make_KPstr
  3549 000012EF B9[D02E0000]            	mov ecx,setkp 			;second argument: pointer to message to write
  3550 000012F4 6A0A                    	push byte setkplen		;third argument: message length
  3551 000012F6 5A                      	pop edx
  3552 000012F7 E8DA080000              	call WriteFile0
  3553                                  %endif
  3554                                  	POP_ALL
  3555 000012FC 61                  <1>  popa
  3556 000012FD C3                      	ret
  3557                                  ;-------
  3558                                  ; make ESC sequence appropriate to most important terminals
  3559                                  ;
  3560                                  %ifndef W32
  3561                                  ;	;expecting cursor pos in dh/dl (0,0)
  3562 000012FE FC                      make_KPstr:cld
  3563 000012FF BF[D02E0000]            	mov edi,setkp			;build cursor control esc string db 27,'[000;000H'
  3564 00001304 B01B                    	mov al,1Bh
  3565 00001306 AA                      	stosb				;init memory
  3566                                  %ifndef ARMCPU
  3567 00001307 B85B303030              	mov eax,'[000'
  3568 0000130C AB                      	stosd
  3569 0000130D B03B                    	mov al,';'			;i.e. load eax with ';000'
  3570 0000130F AB                      	stosd
  3571                                  %else
  3572                                  	mov al,'['
  3573                                  	stosb
  3574                                  	mov al,'0'
  3575                                  	stosb
  3576                                  	stosb
  3577                                  	stosb
  3578                                  	mov al,';'
  3579                                  	stosb
  3580                                  	mov al,'0'
  3581                                  	stosb
  3582                                  	stosb
  3583                                  	stosb
  3584                                  %endif
  3585 00001310 B048                    	mov al,'H'
  3586 00001312 AA                      	stosb				;now we have written 10 chars
  3587 00001313 8D7FFA                  	lea edi,[edi-6]			;old was "mov edi,setkp+1+3" now using 1+3 == 10-6
  3588 00001316 0FB6C6                  	movzx eax,dh			;DH=line
  3589 00001319 40                      	inc eax				;now counted from 1
  3590 0000131A 52                      	push edx
  3591 0000131B E80A000000              	call IntegerToAscii		;make number string
  3592 00001320 5A                      	pop edx
  3593 00001321 BF[D82E0000]            	mov edi,setkp+1+3+4		;column end
  3594 00001326 0FB6C2                  	movzx eax,dl			;DL=col
  3595 00001329 40                      	inc eax				;now counted from 1
  3596                                  %endif
  3597                                  ;-------continued...
  3598                                  ; a general helper
  3599                                  ;   expects integer# in eax
  3600                                  IntegerToAscii:
  3601 0000132A 09C0                    	or eax,eax
  3602 0000132C 7903                    	jns ItoA1
  3603                                  	;int 3				;Assertation
  3604 0000132E 31C0                    	xor eax,eax			;this should never be
  3605 00001330 40                      	inc eax
  3606 00001331 6A0A                    ItoA1:	push byte 10
  3607 00001333 59                      	pop ecx
  3608 00001334 FD                      	std
  3609 00001335 93                      	xchg eax,ebx			;ebx helper (xchg eax,.. is only 1 byte!)
  3610 00001336 93                      Connum1:xchg eax,ebx
  3611 00001337 99                      	cdq
  3612 00001338 F7F1                    	div ecx
  3613 0000133A 93                      	xchg eax,ebx			;save quotient (new low word)
  3614 0000133B 88D0                    	mov al,dl
  3615 0000133D 240F                    	and al,0fh
  3616 0000133F 0430                    	add al,'0'
  3617 00001341 AA                      	stosb
  3618 00001342 09DB                    	or ebx,ebx
  3619 00001344 75F0                    	jne Connum1
  3620 00001346 FC                      	cld
  3621 00001347 C3                      ITAret:	ret
  3622                                  ;----------------------------------------------------------------------
  3623                                  ;
  3624                                  ; functions for INSERTING, COPYING and DELETING chars in text
  3625                                  ;
  3626                                  DeleteByteCheckMarker:			;edi points to begin
  3627 00001348 F605[A0380100]09        	test byte [mode], WS | VI	;see above note at "jz NOWS8"
  3628 0000134F 7425                    	jz DeleteByte
  3629 00001351 8D1C07                  	lea ebx,[edi+eax]		;ebx points to end
  3630 00001354 8B15[182F0100]          	mov edx,[blockbegin]
  3631 0000135A E83DFEFFFF              	call CheckMarker
  3632 0000135F 8915[182F0100]          	mov [blockbegin],edx
  3633 00001365 8B15[1C2F0100]          	mov edx,[blockende]
  3634 0000136B E82CFEFFFF              	call CheckMarker
  3635 00001370 8915[1C2F0100]          	mov [blockende],edx
  3636 00001376 09C0                    DeleteByte:or eax,eax			;input in eax
  3637 00001378 74CD                    	jz ITAret
  3638                                  %ifdef USE_UNDO
  3639 0000137A E8580D0000              	call DataForUndoDelete
  3640                                  %endif
  3641 0000137F 57                      	push edi
  3642 00001380 89E9                    	mov ecx,ebp			;end
  3643 00001382 29F9                    	sub ecx,edi
  3644 00001384 8D3407                  	lea esi,[edi+eax]		;current + x chars
  3645 00001387 29C1                    	sub ecx,eax
  3646 00001389 803D[A0380100]01        	cmp byte [mode],WS
  3647 00001390 7406                    	jz No_WS8
  3648 00001392 030D[6C380100]          	add ecx,[EmaKiSize]
  3649 00001398 41                      No_WS8:	inc ecx
  3650 00001399 FC                      	cld
  3651 0000139A F3A4                    	rep movsb
  3652 0000139C F7D8                    	neg eax				;"neg eax" is for continuing @InsertByte
  3653 0000139E EB58                    	jmp short Ins0			;pending "pop edi"
  3654                                  ;-------
  3655 000013A0 31C0                    Insert1Byte:xor eax,eax
  3656 000013A2 40                      InsertByte0:inc eax
  3657                                  ;
  3658                                  ; do NOT destroy eax
  3659                                  ;
  3660 000013A3 09C0                    InsertByte:or eax,eax			;input: eax = # of bytes  edi = ptr where
  3661 000013A5 74A0                    	jz ITAret
  3662 000013A7 8B0D[C42F0100]          	mov ecx,[maxlen]		;max_len+offset-eofptr=freespace(ecx)
  3663 000013AD 81C1[ED3C0100]          	add ecx,sot
  3664 000013B3 29E9                    	sub ecx,ebp
  3665 000013B5 8B15[6C380100]          	mov edx,[EmaKiSize]
  3666 000013BB 29D1                    	sub ecx,edx			;sub size of kill buffer from free space
  3667 000013BD 39C1                    	cmp ecx,eax			;cmp freespace - newbytes  ;>= 0 ok/ NC  <0 bad / CY
  3668 000013BF 7314                    	jnc SpaceAva
  3669 000013C1 6A0C                    	push byte ERRNOMEM
  3670 000013C3 8F05[5C2F0100]          	pop dword [ErrNr]		;(mov dword[ErrNr],..  has 2 byte extra)
  3671 000013C9 E89C030000              	call OSerror
  3672 000013CE E80AFFFFFF              	call RestKursPos
  3673 000013D3 F9                      	stc
  3674 000013D4 C3                      	ret
  3675 000013D5 57                      SpaceAva:push edi
  3676                                  %ifdef USE_UNDO
  3677 000013D6 E89B0D0000              	call DataForUndoInsert
  3678                                  %endif
  3679 000013DB 89EE                    	mov esi,ebp			;end of text movsb-source
  3680 000013DD 8D4D01                  	lea ecx,[ebp+1]
  3681 000013E0 29F9                    	sub ecx,edi			;space count: distance between eof and current position
  3682 000013E2 8D7C0500                	lea edi,[ebp+eax]		;movsb-destination
  3683 000013E6 803D[A0380100]01        	cmp byte [mode],WS
  3684 000013ED 7406                    	jz ISWS8
  3685 000013EF 01D1                    	add ecx,edx			;add size of kill buffer to distance
  3686 000013F1 01D7                    	add edi,edx
  3687 000013F3 01D6                    	add esi,edx
  3688 000013F5 FD                      ISWS8:	std
  3689 000013F6 F3A4                    	rep movsB
  3690 000013F8 5F                      Ins0:	pop edi				;here is the jmp destination from DeleteByte
  3691                                  ;-------
  3692 000013F9 E8CBEDFFFF              	call SetChg			;i.e. mov byte [changed],CHANGED
  3693 000013FE 01C5                    	add ebp,eax
  3694 00001400 F605[A0380100]09        	test byte [mode], WS | VI	;for vi mode it would be enough to handle blockbegin
  3695 00001407 741C                    	jz NOWS8			;..because blockende is set at end of marker line..
  3696 00001409 3B3D[1C2F0100]          	cmp edi,[blockende]		;..at HandleVImarker procedure
  3697 0000140F 7306                    	jae Ins1
  3698 00001411 0105[1C2F0100]          	add [blockende],eax
  3699 00001417 3B3D[182F0100]          Ins1:	cmp edi,[blockbegin]
  3700 0000141D 731D                    	jae Ins2
  3701 0000141F 0105[182F0100]          	add [blockbegin],eax
  3702                                  NOWS8:
  3703 00001425 F605[A0380100]06        	test byte [mode], EM | PI
  3704 0000142C 740E                    	jz NO_EM02
  3705 0000142E 3B3D[74380100]          	cmp edi,[EmaMark]
  3706 00001434 7306                    	jae Ins2
  3707 00001436 0105[74380100]          	add [EmaMark],eax
  3708                                  NO_EM02:
  3709 0000143C F8                      Ins2:	clc
  3710 0000143D C3                      	ret				;output:nc=ok/cy=bad /ecx=0/ eax inserted / -eax deleted
  3711                                  ;-------
  3712 0000143E E811FDFFFF              CopyBlock:call CheckBlock		;copy block, called by ^KC, ^KV
  3713 00001443 7223                    	jc MoveBlEnd
  3714 00001445 E836FDFFFF              	call CheckImBlock
  3715 0000144A 721C                    	jc MoveBlEnd
  3716 0000144C A1[1C2F0100]            	mov eax,[blockende]
  3717 00001451 29F0                    	sub eax,esi			;block len
  3718 00001453 E84BFFFFFF              	call InsertByte
  3719 00001458 720E                    	jc MoveBlEnd
  3720 0000145A 8B35[182F0100]          	mov esi,[blockbegin]
  3721                                  ;-------
  3722 00001460 57                      MoveBlock:push edi			;input : esi=^KB edi=current
  3723 00001461 89C1                    	mov ecx,eax			;don't use xchg here
  3724 00001463 FC                      	cld
  3725 00001464 F3A4                    	rep movsb
  3726 00001466 5F                      	pop edi
  3727 00001467 F8                      	clc				;nocarry->ok
  3728 00001468 C3                      MoveBlEnd:ret				;return eax=size
  3729                                  ;----------------------------------------------------------------------
  3730 00001469 57                      KeyVICmdyy:push edi
  3731 0000146A E82AEFFFFF              	call KeyHome
  3732 0000146F 893D[74380100]          	mov [EmaMark],edi
  3733 00001475 E828F6FFFF              	call KeyEnd
  3734 0000147A 47                      	inc edi				;add a line delimiter
  3735 0000147B E8A6000000              	call KeyEmaAltW
  3736 00001480 5F                      	pop edi
  3737 00001481 C3                      KviRet:	ret
  3738                                  ;-------
  3739 00001482 E8C9FBFFFF              KeyVICmdy:call ReadOneChar
  3740 00001487 3C79                    	cmp al,'y'
  3741 00001489 74DE                    	je KeyVICmdyy
  3742 0000148B 3C27                    	cmp al,"'"
  3743 0000148D 75D9                    	jne MoveBlEnd
  3744 0000148F E8BCFBFFFF              	call ReadOneChar
  3745 00001494 3C61                    	cmp al,'a'			;" y'a "    only marker "a" supported
  3746 00001496 75D0                    	jne MoveBlEnd
  3747 00001498 8B0D[182F0100]          	mov ecx,[blockbegin]		;don't go further if no mark set
  3748 0000149E E3C8                    	jecxz MoveBlEnd
  3749 000014A0 E8DEEEFFFF              	call VIsetMarker
  3750 000014A5 E87C000000              	call KeyEmaAltW
  3751 000014AA 8B3D[182F0100]          	mov edi,[blockbegin]
  3752                                  %ifdef W32
  3753                                  	jmp ISVI9
  3754                                  %else
  3755 000014B0 EB2F                    	jmp short ISVI9
  3756                                  %endif
  3757                                  ;
  3758                                  ; some of the EM specials
  3759                                  ;
  3760                                  KeyEmaCtrlY:
  3761                                  %ifdef W32
  3762                                  	cmp byte[mode],NE		;Nedit ^V
  3763                                  	jnz KECY
  3764                                  	PUSH_ALL
  3765                                  	push byte 0
  3766                                  	call OpenClipboard
  3767                                  	or eax,eax
  3768                                  	jz KECY3
  3769                                  	push byte CF_OEMTEXT
  3770                                  	call IsClipboardFormatAvailable
  3771                                  	or eax,eax
  3772                                  	jz KECY0
  3773                                  	push byte CF_OEMTEXT
  3774                                  	call GetClipboardData
  3775                                  	or eax,eax
  3776                                  	jz KECY0
  3777                                  	mov edi,ebp
  3778                                  	inc edi				;one after eof
  3779                                  	mov ecx,[maxlen]
  3780                                  	add ecx,sot			;the last possible byte
  3781                                  	xor ebx,ebx
  3782                                  	dec ebx				;init counter -1
  3783                                  	xchg esi,eax
  3784                                  	cld
  3785                                  Kloop:	lodsb
  3786                                  	inc ebx
  3787                                  	cmp edi,ecx
  3788                                  	jnb KECY2
  3789                                  	stosb
  3790                                  	or al,al
  3791                                  	jnz Kloop
  3792                                  KECY2:  mov [EmaKiSize],ebx	
  3793                                  KECY0:	call CloseClipboard
  3794                                  KECY3:	POP_ALL
  3795                                  KECY:
  3796                                  %endif
  3797 000014B2 8B0D[6C380100]          	mov ecx,[EmaKiSize]
  3798                                  %ifdef YASM
  3799                                  	or ecx,ecx
  3800                                  	jmp KeawRet
  3801                                  %else
  3802 000014B8 E36B                    	jecxz KeawRet
  3803                                  %endif
  3804 000014BA 91                      	xchg eax,ecx			;OLD mov eax,ecx 1 byte longer
  3805 000014BB 50                      	push eax
  3806 000014BC E8E2FEFFFF              	call InsertByte
  3807 000014C1 59                      	pop ecx
  3808 000014C2 7261                    	jc KeawRet			;no_space_error is handled in InsertByte
  3809 000014C4 89EE                    	mov esi,ebp
  3810 000014C6 46                      	inc esi
  3811 000014C7 893D[74380100]          	mov [EmaMark],edi
  3812 000014CD FC                      	cld
  3813 000014CE F3A4                    	rep movsb
  3814 000014D0 E8FFF2FFFF              	call ShowBl0			;i.e. "mov byte [showblock],0"
  3815 000014D5 E814F6FFFF              	call IsViMode
  3816 000014DA 7405                    	jz ISVI9
  3817 000014DC E8D1FDFFFF              	call KeyEmaCtrlL
  3818 000014E1 E913F1FFFF              ISVI9:	jmp CQFNum
  3819                                  ;-------
  3820                                  KeyEmaAltW2:PUSH_ALL
  3821                              <1> KeyEmaAltW2:
  3822 000014E6 60                  <1>  pusha
  3823 000014E7 89EF                    	mov edi,ebp
  3824 000014E9 47                      	inc edi
  3825 000014EA E8FFF5FFFF              	call IsViMode
  3826 000014EF 7417                    	jz KEW
  3827                                  ;-------
  3828 000014F1 803D[78380100]01        	cmp byte [EmaCtrlK],1
  3829 000014F8 750E                    	jnz KEW
  3830 000014FA 033D[6C380100]          	add edi,[EmaKiSize]
  3831 00001500 0105[6C380100]          	add [EmaKiSize],eax
  3832 00001506 EB0B                    	jmp short KE2
  3833 00001508 A3[6C380100]            KEW:	mov [EmaKiSize],eax
  3834 0000150D 8935[70380100]          	mov [EmaKiSrc],esi
  3835 00001513 89C1                    KE2:	mov ecx,eax
  3836 00001515 FC                      	cld
  3837 00001516 F3A4                    	rep movsb
  3838 00001518 E8B7F2FFFF              	call ShowBl0			;i.e. "mov byte [showblock],0"
  3839 0000151D C605[78380100]01        Keaw2:	mov byte [EmaCtrlK],1
  3840                                  	POP_ALL
  3841 00001524 61                  <1>  popa
  3842 00001525 C3                      KeawRet:ret
  3843                                  ;-------
  3844 00001526 C605[88380100]00        KeyEmaAltW:mov byte [VInolinebased],0
  3845                                  	PUSH_ALL
  3846 0000152D 60                  <1>  pusha
  3847 0000152E 8B0D[302F0100]          	mov ecx,[showblock]
  3848 00001534 E3E7                    	jecxz Keaw2
  3849 00001536 8B0D[74380100]          	mov ecx,[EmaMark]
  3850 0000153C E3DF                    	jecxz Keaw2
  3851 0000153E 89F8                    	mov eax,edi
  3852 00001540 39C1                    	cmp ecx,eax
  3853 00001542 7201                    	jb KEAW
  3854 00001544 91                      	xchg eax,ecx
  3855 00001545 29C8                    KEAW:	sub eax,ecx			;eax end / ecx beg
  3856 00001547 89CE                    	mov esi,ecx
  3857 00001549 89EF                    	mov edi,ebp
  3858 0000154B 47                      	inc edi
  3859 0000154C A3[6C380100]            	mov [EmaKiSize],eax
  3860 00001551 8935[70380100]          	mov [EmaKiSrc],esi
  3861 00001557 91                      	xchg eax,ecx			;OLD mov ecx,eax 1 byte longer
  3862 00001558 FC                      	cld
  3863 00001559 F3A4                    	rep movsb
  3864 0000155B E88EF5FFFF              	call IsViMode
  3865 00001560 7405                    	jz KEAW3
  3866 00001562 E86DF2FFFF              	call ShowBl0			;i.e. "mov byte [showblock],0"
  3867                                  KEAW3:	
  3868                                  %ifdef W32
  3869                                  	cmp byte[mode],NE		;Nedit ^C
  3870                                  	jnz KEAW4
  3871                                  	push dword [EmaKiSize]
  3872                                  	push byte 0
  3873                                  	push dword [heap]
  3874                                  	call HeapAlloc
  3875                                  	or eax,eax
  3876                                  	jz KEAW4
  3877                                  	mov esi,[EmaKiSrc]
  3878                                  	mov edi,eax
  3879                                  	mov ecx,[EmaKiSize]
  3880                                  	cld
  3881                                  	rep movsb
  3882                                  	mov byte[edi],0			;ASCIIZ
  3883                                  ;-------
  3884                                  	push dword [heap]
  3885                                  	push byte 0
  3886                                  	push eax			;push for later usage in HeapFree
  3887                                  	push eax			;push clip handle for SetClipboardData
  3888                                  	push byte 0
  3889                                  	call OpenClipboard
  3890                                  	or eax,eax
  3891                                  	jz KEAW8
  3892                                  	call EmptyClipboard
  3893                                  	push byte CF_OEMTEXT
  3894                                  	call SetClipboardData
  3895                                  	call CloseClipboard
  3896                                  KEAW8:	call HeapFree
  3897                                  KEAW4:
  3898                                  %endif
  3899                                  	POP_ALL
  3900 00001567 61                  <1>  popa
  3901 00001568 C3                      KeaWRet:ret
  3902                                  ;----------------------------------------------------------------------
  3903                                  ;
  3904                                  ; functions reading/writing  text or blocks  from/into  files
  3905                                  ;
  3906 00001569 BE[39260000]            NFnoarg:mov esi,helptext		;initial part of help
  3907 0000156E BF[ED3C0100]            	mov edi,sot
  3908 00001573 6A53                    	push byte helptextsize
  3909 00001575 59                      	pop ecx
  3910 00001576 57                      	push edi
  3911 00001577 F3A4                    	rep movsb
  3912                                  ;-------
  3913 00001579 E843050000              	call GetHelpText		;second part of help
  3914 0000157E 8DA9[403D0100]          	lea ebp,[ecx+sot+helptextsize]	;set END_OF_HELP_TEXT pointer
  3915 00001584 F3A4                    	rep movsb
  3916 00001586 5F                      	pop edi
  3917 00001587 E872F5FFFF              	call DispNewScreen
  3918                                  ;-------
  3919 0000158C BE[AC220000]            	mov esi, filename
  3920 00001591 B9[C82F0100]            	mov ecx, filepath
  3921 00001596 E8F9F7FFFF              	call InputString0
  3922 0000159B 732A                    	jnc GetFile			;empty string not allowed here
  3923 0000159D C3                      	ret
  3924                                  ;-------
  3925 0000159E 8D7102                  KeyVICmdE:lea esi,[ecx+2]
  3926 000015A1 803E20                  	cmp byte [esi],SPACECHAR
  3927 000015A4 74C2                    	je KeaWRet
  3928                                  	PUSH_ALL			;save before load new
  3929 000015A6 60                  <1>  pusha
  3930 000015A7 E892000000              	call SaveFile
  3931                                  	POP_ALL
  3932 000015AC 61                  <1>  popa
  3933                                  ;-------continue
  3934 000015AD FC                      NewFile:cld
  3935 000015AE E815030000              	call InitVars
  3936                                  %ifdef AMD64
  3937                                  	or rsi,rsi
  3938                                  	jz NFnoarg
  3939                                  	cmp byte [rsi],0
  3940                                  %else
  3941 000015B3 09F6                    	or esi,esi
  3942 000015B5 74B2                    	jz NFnoarg
  3943 000015B7 803E00                  	cmp byte [esi],0
  3944                                  %endif
  3945 000015BA 74AD                    	jz NFnoarg
  3946 000015BC BF[C82F0100]            	mov edi,filepath
  3947                                  NF1:
  3948                                  %ifdef W32
  3949                                  	lodsb
  3950                                  	cmp al,'"'
  3951                                  	jz NF1
  3952                                  	stosb
  3953                                  	cmp al,SPACECHAR		;truncate after blanks
  3954                                  	jnz NF3
  3955                                  NF4:	mov byte [edi-1],0
  3956                                  	jmp short GetFile
  3957                                  NF3:	cmp al,TABCHAR
  3958                                  	jz NF4	
  3959                                  %else
  3960 000015C1 AC                      	lodsb
  3961 000015C2 AA                      	stosb
  3962                                  %endif
  3963 000015C3 08C0                    NF2:	or al,al
  3964 000015C5 75FA                    	jnz NF1
  3965                                  ;------- cont
  3966                                  GetFile:
  3967                                  %ifdef BEOS
  3968                                  	xor ebx,ebx
  3969                                  	mov edx,ebx
  3970                                  	dec ebx				;edx==0,ebx==-1
  3971                                  	mov ecx,filepath
  3972                                  %else
  3973 000015C7 BB[C82F0100]            	mov ebx,filepath
  3974                                  %endif
  3975 000015CC E80C060000              	call OpenFile0
  3976 000015D1 BF[ED3C0100]            	mov edi,sot
  3977 000015D6 89FD                    	mov ebp,edi
  3978 000015D8 785E                    	js NewFileEnd
  3979                                  %ifdef SYS_brk
  3980 000015DA E87D030000              	call Seek
  3981                                  	PUSH_ALL
  3982 000015DF 60                  <1>  pusha
  3983 000015E0 8D9C0000A00F00          	lea ebx,[eax+eax+max]		;twice filesize plus reserve = space for inserts
  3984 000015E7 891D[C42F0100]          	mov [maxlen],ebx
  3985 000015ED 81C3[EC3C0100]          	add ebx,text
  3986 000015F3 E808060000              	call SysBrk
  3987                                  	POP_ALL
  3988 000015F8 61                  <1>  popa
  3989 000015F9 7835                    	js OSejmp1			;OSerror
  3990                                  %else
  3991                                  	mov ebx,eax			;for FreeBSD memory is hard coded by maxlen
  3992                                  %endif
  3993                                  ;-------
  3994                                  %ifdef SYS_fstat			;not for W32,BEOS
  3995 000015FB E8EF050000              	call Fstat
  3996 00001600 782E                    	js OSejmp1			;OSerror
  3997 00001602 A1[F4360100]            	mov eax,[fstatbuf+stat_struc.st_mode]
  3998                                  %ifdef FREEBSD
  3999                                  	mov ecx,eax
  4000                                  	and ecx,0F000h			;see /usr/include/sys/stat.h
  4001                                  	cmp ecx,8000h			;not for special files
  4002                                  	jz regFile
  4003                                  	push byte ERRNOREGFILE
  4004                                  	pop dword [ErrNr]
  4005                                  	jmp OSerror
  4006                                  regFile:
  4007                                  %endif	
  4008 00001607 25FF010000              	and eax,777q
  4009 0000160C A3[E8360100]            	mov [perms],eax
  4010                                  %ifdef SYS_utime	
  4011 00001611 A1[14370100]            	mov eax,[fstatbuf+stat_struc.st_mtime]
  4012 00001616 A3[30370100]            	mov [accesstime+utimbuf_struc.modtime],eax
  4013                                  %endif
  4014                                  %endif					;end of code not for W32,BEOS
  4015                                  ;-------
  4016 0000161B 8B15[C42F0100]          OldFile1:mov edx,[maxlen]		;i.e. either 'max' or filesize twice
  4017 00001621 89F9                    	mov ecx,edi			;sot
  4018 00001623 E8A7050000              	call Read_File
  4019 00001628 92                      	xchg edx,eax			;mov edx,eax	bytes read
  4020 00001629 7877                    	js OSejmp0			;OSerror
  4021 0000162B E8B3050000              	call CloseFile
  4022 00001630 7870                    OSejmp1:js OSejmp0			;OSerror
  4023 00001632 8DAA[ED3C0100]          	lea ebp,[edx+sot]		;eof_ptr=filesize+start_of_text
  4024 00001638 C645000A                NewFileEnd:mov byte [ebp],NEWLINE	;eof-marker
  4025 0000163C F8                      	clc
  4026 0000163D C3                      NFEnd2:	ret
  4027                                  ;-------
  4028                                  ;  save file (called by ^KS,^KX)
  4029                                  ;
  4030 0000163E 803D[0C2F0100]20        SaveFile:cmp byte [changed],UNCHANGED
  4031 00001645 74F6                    	jz NFEnd2			;no changes: nothing to save
  4032 00001647 BE[C8220000]            	mov esi, filesave
  4033 0000164C E82E020000              	call WriteMess9
  4034                                  ;-------
  4035 00001651 BE[C82F0100]            	mov esi,filepath
  4036 00001656 57                      	push edi
  4037 00001657 BF[C8300100]            	mov edi,bakpath
  4038 0000165C 89F3                    	mov ebx,esi
  4039 0000165E 89F9                    	mov ecx,edi
  4040 00001660 FC                      	cld
  4041 00001661 AC                      SF0:	lodsb
  4042 00001662 AA                      	stosb				;copy to BAK file path
  4043 00001663 08C0                    	or al,al
  4044 00001665 75FA                    	jne SF0
  4045 00001667 4F                      	dec edi
  4046 00001668 6A7E                    	push byte '~'			;add BAK file extension
  4047 0000166A 58                      	pop eax
  4048                                  %ifdef ARMCPU
  4049                                  	stosb
  4050                                  	shr eax,8
  4051                                  	stosb	
  4052                                  	shr eax,8
  4053                                  	stosb
  4054                                  	shr eax,8
  4055                                  	stosb
  4056                                  %else
  4057 0000166B AB                      	stosd				;not stosb because ascii-ZERO
  4058                                  %endif
  4059 0000166C 5F                      	pop edi
  4060                                  %ifdef BEOS
  4061                                  	push edi
  4062                                  	mov ebx,0xFFFFFFFF
  4063                                  	mov edx,ebx
  4064                                  	mov ecx,filepath
  4065                                  	mov edi,bakpath
  4066                                  %endif
  4067                                  %ifdef MAKE_BACKUP
  4068 0000166D 81392F746D70            	cmp dword [ecx],'/tmp'
  4069 00001673 741D                    	je no_ren
  4070                                  %ifdef SYS_readlink
  4071                                  	PUSH_ALL
  4072 00001675 60                  <1>  pusha
  4073 00001676 B9[44360100]            	mov ecx,linkbuffer		;we are only interested whether symlink or not
  4074 0000167B 6A04                    	push byte linkbuffersize	;=4 byte dummy buffer
  4075 0000167D 5A                      	pop edx
  4076 0000167E E864050000              	call ReadLink
  4077                                  	POP_ALL
  4078 00001683 61                  <1>  popa
  4079 00001684 7907                    	jns CopyBAK			;no error means it's a symlink...
  4080 00001686 E871050000              	call RenameFile                 ;...but plain files are easy to rename (ecx is filepath)
  4081 0000168B EB05                    	jmp short no_ren		;...simlilar behave 'xemacs' and 'jed'
  4082 0000168D E86D070000              CopyBAK:call CopyToBackup		;we can't simply rename the link
  4083                                  %else
  4084                                  	call RenameFile                 ;ecx is filepath
  4085                                  %endif
  4086                                  no_ren:	;...continue here...
  4087                                  %endif
  4088                                  %ifdef BEOS
  4089                                  	pop edi
  4090                                  %endif
  4091                                  ;-------
  4092                                  %ifdef W32
  4093                                  	mov ecx,CREATE_ALWAYS
  4094                                  	mov ebx,filepath
  4095                                  	mov edx,GENERIC_WRITE
  4096                                  %else
  4097                                  %ifdef BEOS
  4098                                  	mov ebx,0xFFFFFFFF
  4099                                  	mov ecx,filepath
  4100                                  	mov edx,0x777
  4101                                  %else
  4102 00001692 B941020000              	mov ecx,O_WRONLY_CREAT_TRUNC
  4103 00001697 8B15[E8360100]          	mov edx,[perms]
  4104                                  %endif
  4105                                  %endif
  4106 0000169D E83D050000              	call OpenFile
  4107 000016A2 783B                    OSejmp0:js OSejmp9			;OSerror
  4108 000016A4 93                      	xchg ebx,eax			;file descriptor  (xchg is only 1 byte)
  4109                                  ;-------
  4110                                  %ifdef SYS_fchown
  4111 000016A5 8B0D[E8360100]          	mov ecx,[perms]
  4112 000016AB E83B050000              	call Fchmod
  4113                                  %endif
  4114                                  %ifdef SYS_fstat
  4115 000016B0 8B0D[F8360100]          	mov ecx,[fstatbuf+stat_struc.st_uid]
  4116                                  %ifdef UIDGID_WORD			;Linux special
  4117 000016B6 89CA                    	mov edx,ecx
  4118 000016B8 C1EA10                  	shr edx,16
  4119 000016BB 0FB7C9                  	movzx ecx,cx			;OLD and ecx,0xffff
  4120                                  %else
  4121                                  	mov edx,[fstatbuf+stat_struc.st_gid]
  4122                                  %endif
  4123 000016BE E835050000              	call ChownFile
  4124                                  %endif
  4125                                  ;-------
  4126 000016C3 B9[ED3C0100]            	mov ecx,sot			;ecx=bof
  4127 000016C8 89EA                    	mov edx,ebp			;eof
  4128 000016CA 29CA                    SaveFile2:sub edx,ecx			;edx=fileesize= eof-bof
  4129 000016CC E81DF4FFFF              	call IsViMode
  4130 000016D1 7507                    	jnz NoAddNL
  4131 000016D3 807DFF0A                	cmp byte [ebp-1],NEWLINE
  4132 000016D7 7401                    	jz NoAddNL
  4133 000016D9 42                      	inc edx				;append NewLine char for VI mode
  4134 000016DA E8FA040000              NoAddNL:call Write_File			;ebx=file descriptor
  4135 000016DF 7851                    OSejmp9:js OSejmp			;OSerror
  4136 000016E1 6A05                    	push byte ERRNOIO
  4137 000016E3 8F05[5C2F0100]          	pop dword[ErrNr]		;just in case of....
  4138 000016E9 39D0                    	cmp eax,edx			;all written?
  4139                                  %ifdef BEOS
  4140                                  	jnz near OSerror
  4141                                  %else
  4142 000016EB 757D                    	jnz OSerror
  4143                                  %endif
  4144 000016ED E8F1040000              	call CloseFile
  4145 000016F2 783E                    	js OSejmp			;OSerror
  4146 000016F4 C3                      SaveFile3:ret
  4147                                  ;-------
  4148                                  ;  save block (called by ^KW)
  4149                                  ;
  4150 000016F5 E8B5010000              SaveBlock:call GetBlockName
  4151 000016FA 7226                    	jc jcDE2
  4152                                  SaveBl2:
  4153                                  %ifdef W32
  4154                                  	mov ebx,blockpath
  4155                                  SaveBl3:mov ecx,CREATE_ALWAYS
  4156                                  	mov edx,GENERIC_WRITE
  4157                                  %else
  4158                                  %ifdef BEOS
  4159                                  	mov ebx,blockpath
  4160                                  SaveBl3:mov ecx,0xFFFFFFFF
  4161                                  	xchg ebx,ecx
  4162                                  	mov edx,0x241			;was 0x777 upto Dec 01
  4163                                  %else
  4164 000016FC BB[C8310100]            	mov ebx,blockpath
  4165 00001701 B941020000              SaveBl3:mov ecx,O_WRONLY_CREAT_TRUNC
  4166 00001706 BAA4010000              	mov edx,PERMS
  4167                                  %endif
  4168                                  %endif
  4169 0000170B E8CF040000              	call OpenFile
  4170 00001710 7820                    	js OSejmp			;OSerror
  4171 00001712 89F1                    	mov ecx,esi			;= block begin
  4172 00001714 8B15[1C2F0100]          	mov edx,[blockende]
  4173 0000171A 93                      	xchg ebx,eax			;file descriptor  (xchg is only 1 byte)
  4174 0000171B EBAD                    	jmp short SaveFile2
  4175                                  ;-------
  4176                                  ; read a block into buffer (by ^KR)
  4177                                  ;
  4178 0000171D E88D010000              ReadBlock:call GetBlockName
  4179 00001722 0F8285000000            jcDE2:	jc near DE2
  4180                                  ReadBlock2:
  4181                                  %ifdef BEOS
  4182                                  	xor ebx,ebx
  4183                                  	mov edx,ebx
  4184                                  	dec ebx				;edx==0,ebx==-1
  4185                                  	mov ecx,blockpath
  4186                                  %else
  4187 00001728 BB[C8310100]            	mov ebx,blockpath
  4188                                  %endif
  4189 0000172D E8AB040000              	call OpenFile0
  4190 00001732 7836                    OSejmp:	js OSerror
  4191 00001734 E823020000              	call Seek
  4192 00001739 782F                    	js OSerror
  4193 0000173B 50                      	push eax			;eax=fileesize
  4194 0000173C E862FCFFFF              	call InsertByte
  4195 00001741 5A                      	pop edx				;file size
  4196 00001742 72B0                    	jc SaveFile3			;ret if cy InsertByte told an error message itself
  4197 00001744 89F9                    	mov ecx,edi			;^offset akt ptr
  4198 00001746 E884040000              	call Read_File
  4199 0000174B 7816                    	js preOSerror			;to delete inserted bytes (# in EDX)
  4200 0000174D 89C1                    	mov ecx,eax    			;bytes read
  4201 0000174F E88F040000              	call CloseFile
  4202 00001754 7814                    	js OSerror
  4203 00001756 6A05                    	push byte ERRNOIO
  4204 00001758 8F05[5C2F0100]          	pop dword[ErrNr]		;just in case of....
  4205 0000175E 39CA                    	cmp edx,ecx			;all read?
  4206 00001760 7508                    	jnz OSerror
  4207 00001762 C3                      	ret
  4208                                  ;-------
  4209 00001763 89D0                    preOSerror:mov eax,edx			;count bytes
  4210 00001765 E80CFCFFFF              	call DeleteByte			;delete space reserved for insertation
  4211 0000176A 57                      OSerror:push edi
  4212 0000176B BF[682F0100]            	mov edi,error+8			;where to store ASCII value of ErrNr
  4213 00001770 A1[5C2F0100]            	mov eax,[ErrNr]
  4214 00001775 50                      	push eax
  4215 00001776 E8AFFBFFFF              	call IntegerToAscii
  4216 0000177B 59                      	pop ecx				;for getting error text via LookPD2
  4217 0000177C 83F920                  	cmp ecx,MAXERRNO
  4218 0000177F 771C                    	ja DE0
  4219 00001781 BF[AA310000]            	mov edi,errmsgs
  4220 00001786 E8BBF9FFFF              	call LookPD2			;look message # (ecx) in line number #
  4221 0000178B 89FE                    	mov esi,edi
  4222 0000178D BF[692F0100]            	mov edi,error+9
  4223 00001792 66B8203A                	mov ax,' :'
  4224                                  %ifdef ARMCPU
  4225                                  	stosb				;error+9 is not aligned
  4226                                  %else
  4227 00001796 66AB                    	stosw
  4228                                  %endif
  4229 00001798 6A50                    	push byte 80			;max strlen / compare errlen equ 100
  4230 0000179A 59                      	pop ecx
  4231 0000179B F3A4                    	rep movsb
  4232 0000179D BE[602F0100]            DE0:	mov esi,error
  4233 000017A2 5F                      	pop edi
  4234 000017A3 E8D7000000              DE1:	call WriteMess9
  4235 000017A8 E8A3F8FFFF              	call ReadOneChar		;was GetChar
  4236                                  DE2:	;continued...
  4237                                  ;----------------------------------------------------------------------
  4238                                  ;
  4239                                  ; more STATUS LINE maintaining subroutines
  4240                                  ;
  4241                                  RestoreStatusLine:PUSH_ALL		;important e.g. for asksave
  4242                              <1> RestoreStatusLine:
  4243 000017AD 60                  <1>  pusha
  4244 000017AE E8E6000000              	call InitStatusLine
  4245 000017B3 BE[A0380100]            	mov esi,mode
  4246 000017B8 8B0D[F02E0100]          	mov ecx,[columns]		;width
  4247 000017BE 80F920                  	cmp cl,stdtxtlen+15+5+2		;this window is too small
  4248                                  %ifdef ARMCPU
  4249                                  	and ecx,0xFFFFFFFC		;get aligned
  4250                                  %endif
  4251 000017C1 0F82AB000000            	jb near RSno_lineNr
  4252 000017C7 A0[0C2F0100]            	mov al,byte[changed]
  4253 000017CC A2[35370100]            	mov byte[screenline+1],al	;changed status
  4254                                  ;-------
  4255                                  %ifndef LINUX
  4256                                  	lea eax,[ecx-13+screenline]	;FreeBSD or Beos ...
  4257                                  %else
  4258 000017D1 8D81[28370100]          	lea eax,[ecx-12+screenline]
  4259                                  %endif
  4260 000017D7 66C740087669            	mov word[eax+8],'vi'		;vi does show mode info only.
  4261 000017DD 803E08                  	cmp byte [esi],VI		;vi doesn't get altH text because altH won't work...
  4262 000017E0 7510                    	jnz RSL0			;...caused by different handling due single ESC keys
  4263 000017E2 803D[80380100]01        	cmp byte [VICmdMode],1
  4264 000017E9 7536                    	jnz NOVI0
  4265 000017EB BB434D4420              	mov ebx,'CMD '
  4266 000017F0 EB42                    	jmp short RSL1
  4267 000017F2 C700616C7448            RSL0:	mov dword [eax],'altH'
  4268 000017F8 C740043D68656C          	mov dword [eax+4],'=hel'	;'p' is stored with editor mode name
  4269 000017FF BB[29260000]            	mov ebx,editmode
  4270 00001804 8B13                    	mov edx,[ebx]
  4271 00001806 803E04                  	cmp byte [esi],PI
  4272 00001809 7503                    	jnz No_PI1
  4273 0000180B 8B5304                  	mov edx,[ebx+4]
  4274 0000180E 803E02                  No_PI1:	cmp byte [esi],EM
  4275 00001811 7503                    	jnz No_Em1
  4276 00001813 8B5308                  	mov edx,[ebx+8]
  4277 00001816 803E10                  No_Em1:	cmp byte [esi],NE
  4278 00001819 7503                    	jnz No_Ne1
  4279 0000181B 8B530C                  	mov edx,[ebx+12]
  4280 0000181E 895008                  No_Ne1:	mov [eax+8],edx
  4281                                  ;-------
  4282 00001821 B820494E53              NOVI0:	mov eax,' INS'			;Insert
  4283 00001826 803D[582F0100]01        	cmp byte [insstat],1
  4284 0000182D 7405                    	jz RSL1
  4285 0000182F B8204F5652              	mov eax,' OVR'			;Overwrite
  4286 00001834 A3[38370100]            RSL1:	mov [screenline+4],eax		;mode status
  4287                                  %ifdef UTF8RTS
  4288                                  	cmp byte [isUTF8],0
  4289                                  	jnz RSL1a
  4290                                  	mov al,'7'			;"7bit_non_utf8" status
  4291                                  RSL1a:  mov byte [screenline],al
  4292                                  %endif
  4293 00001839 BF[3E370100]            	mov edi,screenline+stdtxtlen
  4294 0000183E 8D49E2                  	lea ecx,[ecx-(stdtxtlen+15+5)]	;space for other than filename
  4295 00001841 BE[C82F0100]            	mov esi,filepath		;lea ... is shorter than sub ecx,stdtxtlen+15+5
  4296 00001846 AC                      RSL2:	lodsb
  4297 00001847 08C0                    	or al,al
  4298 00001849 7403                    	jz RSL4
  4299 0000184B AA                      	stosb
  4300 0000184C E2F8                    	loop RSL2
  4301 0000184E BF[25370100]            RSL4:	mov edi,screenline-15
  4302 00001853 033D[F02E0100]          	add edi,[columns]
  4303 00001859 A1[F42E0100]            	mov eax,[columne]
  4304 0000185E 40                      	inc eax				;start with 1
  4305 0000185F E8C6FAFFFF              	call IntegerToAscii
  4306 00001864 C6073A                  	mov byte [edi],':'		;delimiter ROW:COL
  4307 00001867 4F                      	dec edi
  4308 00001868 A1[2C2F0100]            	mov eax,[linenr]
  4309 0000186D E8B8FAFFFF              	call IntegerToAscii
  4310 00001872 E881F4FFFF              RSno_lineNr:call StatusLineShow		;now write all at once
  4311                                  	POP_ALL
  4312 00001877 61                  <1>  popa
  4313 00001878 F9                      	stc				;error status only important if called via OSError
  4314 00001879 C3                      	ret
  4315                                  ;-------
  4316                                  ;
  4317                                  ; write an answer prompt into status line
  4318                                  ; (with and without re-initialisation)
  4319                                  ; expecting esi points to ASCIIZ or 0A terminated string
  4320                                  ;
  4321 0000187A E81A000000              WriteMess9MakeLine:call InitStatusLine
  4322                                  WriteMess9:PUSH_ALL
  4323                              <1> WriteMess9:
  4324 0000187F 60                  <1>  pusha
  4325 00001880 BF[34370100]            	mov edi,screenline
  4326 00001885 FC                      	cld
  4327 00001886 AC                      WriteMLoop:lodsb
  4328 00001887 3C0A                    	cmp al,LINEFEED			;for error messages
  4329 00001889 7603                    	jbe WriteMEnd
  4330 0000188B AA                      	stosb
  4331 0000188C EBF8                    	jmp short WriteMLoop
  4332 0000188E E865F4FFFF              WriteMEnd:call StatusLineShow
  4333                                  	POP_ALL
  4334 00001893 61                  <1>  popa
  4335 00001894 E93AFAFFFF              	jmp KursorStatusLine
  4336                                  ;-------
  4337                                  ; a helper for other status line functions:
  4338                                  ; simply init an empty line
  4339                                  ;
  4340                                  InitStatusLine:PUSH_ALL			;simply init an empty line
  4341                              <1> InitStatusLine:
  4342 00001899 60                  <1>  pusha
  4343 0000189A BF[34370100]            	mov edi,screenline
  4344 0000189F B020                    	mov al,SPACECHAR
  4345 000018A1 8B0D[F02E0100]          	mov ecx,[columns]
  4346                                  %ifndef LINUX
  4347                                  	dec ecx				;? FreeBSD
  4348                                  	js ISL				;should never be = -1
  4349                                  %endif
  4350 000018A7 FC                      	cld
  4351 000018A8 F3AA                    	rep stosb
  4352 000018AA B000                    	mov al,0			;prepare ASCIIZ string
  4353 000018AC AA                      	stosb
  4354                                  ISL:	POP_ALL
  4355                              <1> ISL: 
  4356 000018AD 61                  <1>  popa
  4357 000018AE C3                      	ret
  4358                                  ;-------
  4359                                  ; read a file name for block operations
  4360                                  ;
  4361                                  GetBlockName:PUSH_ALL
  4362                              <1> GetBlockName:
  4363 000018AF 60                  <1>  pusha
  4364 000018B0 BE[B6220000]            	mov esi,block
  4365 000018B5 B9[C8310100]            	mov ecx,blockpath
  4366 000018BA E8D5F4FFFF              	call InputString0		;cy if empty string
  4367 000018BF 9C                      	pushf
  4368 000018C0 E818FAFFFF              	call RestKursPos
  4369 000018C5 9D                      	popf
  4370                                  	POP_ALL
  4371 000018C6 61                  <1>  popa
  4372 000018C7 C3                      	ret
  4373                                  ;-------
  4374                                  ; helper for NewFile
  4375                                  ;
  4376 000018C8 C605[EC3C0100]0A        InitVars:mov byte [text],NEWLINE	;don't touch esi!
  4377 000018CF E8D7EFFFFF              	call Unchg			;i.e. "mov byte [changed],UNCHANGED"
  4378 000018D4 E84E000000              	call InitSomeVars		;set eax=0
  4379 000018D9 C705[242F0100]-         	mov dword[old],sot
  4380 000018DF [ED3C0100]         
  4381 000018E3 40                      	inc eax				;set eax=1
  4382 000018E4 A2[80380100]            	mov byte [VICmdMode],al
  4383 000018E9 A3[2C2F0100]            	mov dword [linenr],eax
  4384 000018EE A2[582F0100]            	mov byte [insstat],al
  4385 000018F3 C705[C42F0100]00A0-     	mov dword [maxlen],max
  4386 000018FB 0F00               
  4387 000018FD C705[602F0100]4552-     	mov dword [error],'ERRO'
  4388 00001905 524F               
  4389 00001907 C705[642F0100]5220-     	mov dword [error+4],'R   '
  4390 0000190F 2020               
  4391 00001911 C705[E8360100]A401-     	mov dword [perms],PERMS
  4392 00001919 0000               
  4393                                  %ifdef SYS_fstat
  4394 0000191B 48                      	dec eax
  4395 0000191C 48                      	dec eax				;eax == -1 i.e. no changes in fchown
  4396                                  %ifdef UIDGID_WORD			;Linux special
  4397 0000191D A3[F8360100]            	mov [fstatbuf+stat_struc.st_uid],eax	;both: giduid
  4398                                  %else
  4399                                  	mov [fstatbuf+stat_struc.st_gid],eax
  4400                                  	mov [fstatbuf+stat_struc.st_uid],eax
  4401                                  %endif
  4402                                  %endif
  4403 00001922 E9A5EEFFFF              	jmp ShowBl1			;i.e. mov byte [showblock],1
  4404                                  ;-------
  4405                                  InitSomeVars:
  4406 00001927 31C0                    	xor eax,eax
  4407                                  %ifdef USE_UNDO
  4408 00001929 A3[EC2E0000]            	mov [undobuffer],eax		;i.e. invalid pointer
  4409 0000192E C705[E82E0000]-          	mov dword[undoptr],undobuffer+4 ;init to first frame
  4410 00001934 [F02E0000]         
  4411                                  %endif
  4412 00001938 A3[74380100]            	mov [EmaMark],eax
  4413 0000193D A3[102F0100]            	mov dword [oldQFpos],eax
  4414 00001942 A2[142F0100]            	mov byte[bereitsges],al
  4415 00001947 A2[202F0100]            	mov [endeedit],al
  4416 0000194C A3[6C380100]            InitSV1:mov [EmaKiSize],eax		;do not allow side effects
  4417 00001951 A3[182F0100]            InitSV2:mov [blockbegin],eax		;i.e. NO block valid now
  4418 00001956 A3[1C2F0100]            InitSV3:mov [blockende],eax
  4419 0000195B C3                      	ret
  4420                                  ;-------
  4421 0000195C 93                      Seek:	xchg ebx,eax			;mov file_descriptor to ebx (xchg is 1 byte only)
  4422 0000195D 6A02                    	push byte 2			;FILE_END
  4423 0000195F 5A                      	pop edx
  4424 00001960 E8A5020000              	call SeekFile			;end
  4425 00001965 7809                    	js SeekRet
  4426 00001967 31D2                    	xor edx,edx			;FILE_BEGIN
  4427 00001969 50                      	push eax
  4428 0000196A E89B020000              	call SeekFile			;home
  4429 0000196F 58                      	pop eax
  4430 00001970 C3                      SeekRet:ret
  4431                                  ;----------------------------------------------------------------------
  4432                                  ;
  4433                                  ; FIND/REPLACE related stuff
  4434                                  ;
  4435 00001971 BE[E4220000]            AskForReplace:mov esi,askreplace1
  4436 00001976 E814F4FFFF              	call InputString00
  4437 0000197B 7240                    	jc AskFor_Ex
  4438 0000197D A3[342F0100]            	mov [suchlaenge],eax
  4439 00001982 BE[ED220000]            	mov esi,askreplace2
  4440 00001987 B9[C8320100]            	mov ecx,replacetext
  4441 0000198C E803F4FFFF              	call InputString0
  4442 00001991 EB0C                    	jmp short GetOptions		;cy flag is allowed here 18.6.00
  4443 00001993 BE[FF220000]            AskForFind:mov esi,askfind
  4444 00001998 E8F2F3FFFF              	call InputString00
  4445 0000199D 721E                    	jc AskFor_Ex
  4446 0000199F A3[382F0100]            GetOptions:mov [repllaenge],eax
  4447 000019A4 F605[A0380100]11        	test byte [mode],WS|NE
  4448 000019AB 740F                    	jz GetOpt2
  4449 000019AD BE[A3220000]            	mov esi,optiontext
  4450 000019B2 E8C9F3FFFF              	call InputStringWithMessage	;empty string is allowd for std options...
  4451 000019B7 E812000000              	call ParseOptions		;...(set in ParseOptions)
  4452 000019BC F8                      GetOpt2:clc
  4453 000019BD 7307                    AskFor_Ex:jnc AFE2
  4454 000019BF C605[142F0100]00        	mov byte [bereitsges],0
  4455 000019C6 9C                      AFE2:	pushf
  4456 000019C7 E811F9FFFF              	call RestKursPos
  4457 000019CC 9D                      	popf
  4458 000019CD C3                      	ret
  4459                                  ;-------
  4460                                  ; check string for 2 possible options: C,c,B,b  (case sensitive & backward)
  4461                                  ;
  4462 000019CE 56                      ParseOptions:push esi
  4463 000019CF FC                      	cld
  4464 000019D0 BE[C8350100]            	mov esi,optbuffer
  4465 000019D5 6A01                    	push byte 1
  4466 000019D7 8F05[3C2F0100]          	pop dword[vorwarts]		;mov dword[vorwarts],1 is longer
  4467 000019DD C605[402F0100]DF        	mov byte[grossklein],0dfh
  4468 000019E4 AC                      Scan1:	lodsb
  4469 000019E5 245F                    	and al,5fh			;upper case
  4470 000019E7 3C43                    	cmp al,'C'
  4471 000019E9 7507                    	jnz notCopt
  4472 000019EB 8035[402F0100]20        	xor byte[grossklein],20h	;result 0dfh,   2*C is like not C option
  4473 000019F2 3C42                    notCopt:cmp al,'B'
  4474 000019F4 7506                    	jnz notBopt
  4475 000019F6 F71D[3C2F0100]          	neg dword[vorwarts]		;similar 2*B is backward twice i.e. forward
  4476 000019FC 08C0                    notBopt:or al,al
  4477 000019FE 75E4                    	jnz Scan1
  4478 00001A00 5E                      	pop esi
  4479 00001A01 C3                      	ret
  4480                                  ;-------
  4481                                  ; the find subroutine itself
  4482                                  ;
  4483 00001A02 89FB                    find2:	mov ebx,edi
  4484 00001A04 AC                      find3:	lodsb
  4485 00001A05 08C0                    	or al,al			;=end?
  4486 00001A07 7466                    	jz found
  4487 00001A09 3C41                    	cmp al,41h
  4488 00001A0B 7202                    	jb find7
  4489 00001A0D 20E8                    	and al,ch
  4490 00001A0F 47                      find7:	inc edi
  4491 00001A10 8A0F                    	mov cl,byte [edi]
  4492 00001A12 80F941                  	cmp cl,41h
  4493 00001A15 7202                    	jb find10
  4494 00001A17 20E9                    	and cl,ch
  4495 00001A19 38C8                    find10:	cmp al,cl
  4496 00001A1B 74E7                    	jz find3
  4497 00001A1D 89DF                    	mov edi,ebx
  4498 00001A1F 8A2D[402F0100]          FindText:mov ch,[grossklein]		;ff or df
  4499 00001A25 BE[C8330100]            	mov esi,suchtext
  4500 00001A2A FC                      	cld
  4501 00001A2B AC                      	lodsb
  4502 00001A2C 3C41                    	cmp al,41h
  4503 00001A2E 7202                    	jb find1
  4504 00001A30 20E8                    	and al,ch			;FIXME: check UTF-8 stuff !!
  4505                                  ;-------
  4506 00001A32 033D[3C2F0100]          find1:	add edi,[vorwarts]		;+1 or -1 (increase or decrease pointer) 
  4507 00001A38 8A0F                    	mov cl,byte [edi]
  4508 00001A3A 80F941                  	cmp cl,41h
  4509 00001A3D 7202                    	jb find6
  4510 00001A3F 20E9                    	and cl,ch
  4511 00001A41 38C8                    find6:	cmp al,cl
  4512 00001A43 74BD                    	je find2
  4513 00001A45 803D[A0380100]04        	cmp byte[mode],PI		;is it Pico? (always searching forward)
  4514 00001A4C 7513                    	jnz find_WS			;no, continue
  4515 00001A4E 3B3D[8C380100]          	cmp edi,[PicoSearch]		;yes, but did we search from BOF up to here?
  4516 00001A54 7417                    	je notfound			;yes, so we did not found the text
  4517 00001A56 39EF                    	cmp edi,ebp			;no, but did we touch EOF?
  4518 00001A58 72D8                    	jb find1			;no, continue from here
  4519 00001A5A BF[EC3C0100]            	mov edi,sot-1			;yes, let's continue at BOF
  4520 00001A5F EBD1                    	jmp short find1			;loop
  4521 00001A61 39EF                    find_WS:cmp edi,ebp
  4522 00001A63 7708                    	ja notfound
  4523 00001A65 81FF[ED3C0100]          find9:	cmp edi,sot			;this is needed for WStar backward option searching
  4524 00001A6B 73C5                    	jnb find1
  4525 00001A6D F9                      notfound:stc
  4526 00001A6E C3                      	ret
  4527 00001A6F 89DF                    found:	mov edi,ebx
  4528 00001A71 F8                      	clc				;edi points after location
  4529 00001A72 C3                      	ret
  4530                                  ;----------------------------------------------------------------------
  4531                                  ;
  4532                                  ; some GENERAL helper functions
  4533                                  ;
  4534                                  ;
  4535                                  ; Get.....ToInteger reads integer value from keyboard (only > 0)
  4536                                  ;
  4537 00001A73 6A07                    GetOctalToInteger:push byte 7		;octal base-1
  4538 00001A75 EB02                    	jmp short GATI2
  4539 00001A77 6A09                    GetAsciiToInteger:push byte 9		;decimal base-1
  4540 00001A79 E870F0FFFF              GATI2:	call IsViMode
  4541 00001A7E 740A                    	jz ISVI8
  4542 00001A80 E8FBF2FFFF              	call InputStringWithMessage	;eax = al = length
  4543 00001A85 E833FFFFFF              	call AskFor_Ex			;repair status line & set cursor pos / preserve flags
  4544 00001A8A 6A00                    ISVI8:	push byte 0
  4545 00001A8C 5E                      	pop esi				;preserve flags
  4546 00001A8D 5B                      	pop ebx				;bl == base-1
  4547 00001A8E 87CE                    	xchg ecx,esi
  4548 00001A90 721E                    	jc AIexit2
  4549 00001A92 FC                      	cld
  4550 00001A93 AC                      AIload:	lodsb				;eax bit 8..31 are 0
  4551 00001A94 2C30                    	sub al,'0'
  4552 00001A96 7816                    	js AIexit
  4553 00001A98 38D8                    	cmp al,bl
  4554 00001A9A 7712                    	ja AIexit
  4555 00001A9C 80FB07                  	cmp bl,7			;if base==8
  4556 00001A9F 7408                    	je GATI3
  4557 00001AA1 8D0C89                  	lea ecx,[ecx+4*ecx]
  4558 00001AA4 8D0C48                  	lea ecx,[2*ecx+eax]		;mul 10 plus digit
  4559 00001AA7 EBEA                    	jmp short AIload
  4560 00001AA9 8D0CC8                  GATI3:	lea ecx,[8*ecx+eax]		;mul 8 plus digit
  4561 00001AAC EBE5                    	jmp short AIload
  4562                                  %ifdef ARMCPU
  4563                                  AIexit:	cmp ecx,0			;ret ecx
  4564                                  %else
  4565 00001AAE 09C9                    AIexit:	or ecx,ecx			;ret ecx
  4566                                  %endif
  4567 00001AB0 C3                      AIexit2:ret				;CY or ZR if error
  4568                                  ;-------
  4569                                  ;
  4570                                  ; SpacesForTab expects current column in edx
  4571                                  ; returns # spaces up to next tabulated location in AH
  4572                                  ;
  4573 00001AB1 51                      SpacesForTab:push ecx
  4574 00001AB2 89D0                    	mov eax,edx
  4575 00001AB4 B108                    	mov cl,TAB
  4576 00001AB6 30E4                    	xor ah,ah
  4577 00001AB8 F6F1                    	div cl
  4578 00001ABA F6DC                    	neg ah				;ah = modulo division
  4579 00001ABC 80C408                  	add ah,TAB			;TAB - pos % TAB
  4580 00001ABF 59                      	pop ecx
  4581 00001AC0 C3                      	ret
  4582                                  ;-------
  4583                                  ;
  4584                                  ; GetHelpText returns ecx==size of help text / esi==help text for current edit mode
  4585                                  ;
  4586                                  GetHelpText:
  4587 00001AC1 BE[31300000]            	mov esi,help_ne			;start with last text block...
  4588 00001AC6 B963020000              	mov ecx,help_ws_size
  4589                                  %ifdef USE_BUILTINHELP
  4590 00001ACB B8[A0380100]            	mov eax,mode
  4591 00001AD0 803810                  	cmp byte [eax],NE
  4592 00001AD3 7506                    	jnz NoNe1
  4593 00001AD5 B979010000              	mov ecx,help_ne_size
  4594 00001ADA C3                      	ret
  4595 00001ADB 29CE                    NoNe1:	sub esi,ecx			;...and sub block by block until we've found it
  4596 00001ADD 803808                  	cmp byte [eax],VI
  4597 00001AE0 7410                    	jz GHT
  4598 00001AE2 29CE                    	sub esi,ecx
  4599 00001AE4 803802                  	cmp byte [eax],EM
  4600 00001AE7 7409                    	jz GHT
  4601 00001AE9 29CE                    	sub esi,ecx
  4602 00001AEB 803804                  	cmp byte [eax],PI
  4603 00001AEE 7402                    	jz GHT
  4604 00001AF0 29CE                    	sub esi,ecx
  4605                                  %endif
  4606 00001AF2 C3                      GHT:	ret
  4607                                  ;-------
  4608                                  ;
  4609                                  ; Check whether user discarded his input
  4610                                  ;
  4611 00001AF3 BE[A0380100]            CheckUserAbort:mov esi,mode
  4612 00001AF8 803E01                  	cmp byte[esi],WS
  4613 00001AFB 7408                    	jz CUAWS
  4614 00001AFD 803E02                  	cmp byte[esi],EM
  4615 00001B00 7406                    	jz CUAEM
  4616 00001B02 3C03                    	cmp al,3			;^C abort
  4617 00001B04 C3                      	ret
  4618 00001B05 3C15                    CUAWS:	cmp al,15h			;^U abort
  4619 00001B07 C3                      	ret
  4620 00001B08 3C07                    CUAEM:	cmp al,7			;^G abort
  4621 00001B0A C3                      	ret
  4622                                  ;-------
  4623                                  KeyEditMode:
  4624 00001B0B BE[1B230000]            	mov esi,modetxt
  4625 00001B10 E86BF2FFFF              	call InputStringWithMessage	;empty string is allowd for std options...
  4626 00001B15 E8C3F7FFFF              	call RestKursPos
  4627 00001B1A BE[C8350100]            	mov esi,optbuffer
  4628 00001B1F E803FEFFFF              	call InitSomeVars
  4629                                  ;-------
  4630 00001B24 B8[A0380100]            SetEditMode:mov eax,mode		;returns Z flag if the mode was changed / NZ else
  4631                                  %ifndef ARMCPU
  4632                                  %ifdef AMD64
  4633                                  	mov ecx,dword [rsi]
  4634                                  %else
  4635 00001B29 8B0E                    	mov ecx,dword [esi]
  4636                                  %endif
  4637                                  %else					;one never knows how aligned esi will be
  4638                                  	mov cl,byte [esi+3]
  4639                                  	shl ecx,8
  4640                                  	mov cl,byte [esi+2]
  4641                                  	shl ecx,8
  4642                                  	mov cl,byte [esi+1]
  4643                                  	shl ecx,8
  4644                                  	mov cl,byte [esi]
  4645                                  %endif
  4646                                  %ifdef W32
  4647                                  	or ecx,020202020h		;convert to lower case
  4648                                  %endif
  4649 00001B2B 81F965336E65            	cmp ecx,'e3ne'
  4650 00001B31 7504                    	jnz NoNe
  4651 00001B33 C60010                  	mov byte [eax],NE
  4652 00001B36 C3                      	ret
  4653 00001B37 81F96533656D            NoNe:	cmp ecx,'e3em'
  4654 00001B3D 7504                    	jnz NoEm
  4655 00001B3F C60002                  	mov byte [eax],EM
  4656 00001B42 C3                      	ret
  4657 00001B43 81F965337069            NoEm:	cmp ecx,'e3pi'
  4658 00001B49 7504                    	jnz NoPi
  4659 00001B4B C60004                  	mov byte [eax],PI
  4660 00001B4E C3                      	ret
  4661 00001B4F 81F976690000            NoPi:	cmp ecx,'vi'
  4662 00001B55 7504                    	jnz NoVi
  4663 00001B57 C60008                  	mov byte [eax],VI
  4664 00001B5A C3                      	ret
  4665 00001B5B 81F965337773            NoVi:	cmp ecx,'e3ws'
  4666 00001B61 7503                    	jnz modeOK
  4667 00001B63 C60001                  	mov byte [eax],WS
  4668 00001B66 C3                      modeOK:	ret
  4669                                  ;-----------------------------------------------------------------------
  4670                                  ;
  4671                                  ; Oleg's suggestion / Sat Mar 16 17:58:06
  4672                                  ;
  4673                                  %ifdef USE_EXT_MOVE
  4674                                  KeyHome2:cmp byte[edi-1],NEWLINE	
  4675                                  	jz KCQPjmp
  4676                                  	jmp KeyHome
  4677                                  ;-------
  4678                                  KeyEnd2:cmp byte[edi],NEWLINE	
  4679                                  	jz KCQPjmp
  4680                                  	jmp KeyEnd	
  4681                                  ;-------
  4682                                  KeyCtrlQR2:cmp edi,sot
  4683                                  	jz KCQPjmp
  4684                                  	jmp KeyCtrlQR
  4685                                  ;-------
  4686                                  KeyCtrlQC2:cmp edi,ebp
  4687                                  KCQPjmp:jz near KeyCtrlQP
  4688                                  	jmp KeyCtrlQC 
  4689                                  %endif
  4690                                  ;-----------------------------------------------------------------------
  4691                                  %ifdef SYS_kill
  4692 00001B67 E871F7FFFF              SigHandler:call RestKursPos
  4693 00001B6C BF[00000000]            	mov edi,screenbuffer		;make buffer invalid with something
  4694 00001B71 B9A00B0000              	mov ecx,screenbuffer_dwords	;this will force a complete screen redraw
  4695 00001B76 FC                      	cld
  4696 00001B77 F3AB                    	rep stosd
  4697                                  %endif
  4698                                  ;------- cont
  4699                                  SetTermStruc:
  4700                                  %ifdef W32
  4701                                  	push dword STD_INPUT_HANDLE
  4702                                  	call GetStdHandle
  4703                                  	mov [hin],eax
  4704                                  	push dword STD_OUTPUT_HANDLE
  4705                                  	call GetStdHandle
  4706                                  	mov [hout],eax
  4707                                  	push byte ENABLE_WINDOW_INPUT	;equ 8
  4708                                  	push dword [hin]
  4709                                  	call SetConsoleMode		;Do not use "jmp SetConsoleMode" here
  4710                                  	ret
  4711                                  %else
  4712 00001B79 B901540000              	mov ecx,TERMIOS_GET
  4713 00001B7E E83C000000              	call IOctlTerminal0
  4714 00001B83 89D6                    	mov esi,edx
  4715 00001B85 BF[802E0000]            	mov edi,termios
  4716 00001B8A 89FA                    	mov edx,edi
  4717 00001B8C 6A24                    	push byte termios_struc_size	;prepare a copy of original settings
  4718 00001B8E 59                      	pop ecx
  4719 00001B8F FC                      	cld
  4720 00001B90 F3A4                    	rep movsb
  4721                                  ;-------
  4722                                  %ifdef LINUX
  4723 00001B92 C6421701                	mov byte [edx+termios_struc.c_cc+VMIN],1				;set min=1 ->needed for gnome-terminal
  4724                                  %endif
  4725                                  %ifdef ARMCPU
  4726                                  	and byte [edx+termios_struc.c_lflag+0],(~ICANON & ~ISIG & ~ECHO)	;icanon off, isig (^C) off, echo off
  4727                                  %else
  4728 00001B96 80620CF4                	and TSize [edx+termios_struc.c_lflag+0],(~ICANON & ~ISIG & ~ECHO)	;icanon off, isig (^C) off, echo off
  4729                                  %endif
  4730 00001B9A 806201FA                	and byte [edx+termios_struc.c_iflag+1],(~(IXON>>8) & ~(ICRNL>>8))	;ixon off,   icrnl off
  4731 00001B9E B902540000              	mov ecx,TERMIOS_SET
  4732 00001BA3 EB1F                    	jmp short IOctlTerminal		;edx is termios pointer
  4733                                  %endif
  4734                                  ;----------------------------------------------------------------------
  4735                                  %ifdef NEW_CURSOR_MGNT
  4736                                  SetCursorNormal:PUSH_ALL
  4737                              <1> SetCursorNormal:
  4738 00001BA5 60                  <1>  pusha
  4739 00001BA6 B9[24260000]            	mov ecx,normcurs
  4740 00001BAB 6A05                    	push byte normcurslen
  4741 00001BAD EB08                    	jmp short SCB
  4742                                  SetCursorBlock:PUSH_ALL
  4743                              <1> SetCursorBlock:
  4744 00001BAF 60                  <1>  pusha
  4745 00001BB0 B9[19260000]            	mov ecx,blockcurs		;second argument: pointer to message to write
  4746 00001BB5 6A0B                    	push byte blockcurslen		;third argument: message length
  4747 00001BB7 5A                      SCB:	pop edx
  4748 00001BB8 E819000000              	call WriteFile0
  4749                                  	POP_ALL
  4750 00001BBD 61                  <1>  popa
  4751 00001BBE C3                      	ret
  4752                                  %endif
  4753                                  ;----------------------------------------------------------------------
  4754                                  ;
  4755                                  ; INTERFACE to OS kernel
  4756                                  ; we differ between Linux, and and ...
  4757                                  ;
  4758                                  %ifndef W32
  4759 00001BBF BA[A42E0000]            IOctlTerminal0:mov edx,termios_orig
  4760 00001BC4 BB00000000              IOctlTerminal:mov ebx,stdin		;expects EDX termios or winsize structure ptr
  4761                                  %ifdef LIBC
  4762                                  	push edx
  4763                                  	push ecx
  4764                                  	push ebx
  4765                                  	call ioctl
  4766                                  	mov ebx,[_errno]
  4767                                  	mov [ErrNr],ebx
  4768                                  	pop ebx
  4769                                  	pop ecx
  4770                                  	pop edx
  4771                                  	or eax,eax
  4772                                  	ret
  4773                                  %else
  4774 00001BC9 B036                    	mov al,SYS_ioctl
  4775 00001BCB EB41                    	jmp short IntCall		;ECX TCSETS,TCGETS,TIOCGWINSZ
  4776                                  %endif
  4777                                  %endif
  4778                                  ;------
  4779                                  ReadFile0:
  4780                                  %ifdef W32
  4781                                  	;all API: 
  4782                                  	;- direction flag is cleared before and after call
  4783                                  	;- preserves ebx,esi,edi,ebp
  4784                                  	PUSH_ALL
  4785                                  	push dword 0xFFFFFFFF
  4786                                  	push dword [hin]
  4787                                  	call WaitForSingleObject
  4788                                  	POP_ALL
  4789                                  %ifdef W32_EXTENDED_IO
  4790                                  	push ecx			;destr
  4791                                  	push edx			;destr
  4792                                  	push dword w32result
  4793                                  	push byte 1
  4794                                  	push ecx
  4795                                  	push dword [hin]
  4796                                  	call ReadConsoleInputA
  4797                                  	pop edx
  4798                                  	pop ecx
  4799                                  ;-------
  4800                                  	mov ebx,dword [ecx]
  4801                                  	cmp bl,1			;is it a key_event?
  4802                                  	jnz ReadFile0			;no, read new
  4803                                  	mov ebx,dword [ecx+4]
  4804                                  	cmp ebx,1			;is it a keydown event?
  4805                                  	jnz ReadFile0			;no, read new
  4806                                  	;PUSH_ALL
  4807                                  	;push dword [hin]
  4808                                  	;call FlushConsoleInputBuffer
  4809                                  	;POP_ALL
  4810                                  ;-------
  4811                                  	mov ebx,dword [ecx+8]		;virtual key code
  4812                                  	shr ebx,16
  4813                                  ;-------
  4814                                  	cmp ebx,dword VK_SPACE
  4815                                  	jnz Normal0
  4816                                  	test dword [ecx+16],CTRL_PRESSED
  4817                                  	jz Normal0
  4818                                  	mov dword[ecx],0FF00h		;return ascii 00 for EMACS ^SPACE key
  4819                                  	ret
  4820                                  Normal0:cmp ebx,dword VK_DELETE
  4821                                  	ja Normal1
  4822                                  	cmp ebx,dword VK_PRIOR
  4823                                  	jb Normal1
  4824                                  ;-------
  4825                                  	sub bl,VK_PRIOR			;found a cursor key
  4826                                  	mov al,bl
  4827                                  	mov ebx,ScanTable
  4828                                  	xlatb				;translate to terminal value...
  4829                                  	cmp al,DoNo			;...in results 0..9
  4830                                  ReadF0:	jz ReadFile0
  4831                                  	mov ah,0xFE			;marker for a pre-processed cursor key
  4832                                  	mov [ecx],eax
  4833                                  	ret
  4834                                  ;-------
  4835                                  Normal1:mov ebx,dword [ecx+12]		;get ascii char value
  4836                                  	shr ebx,16
  4837                                  	or bl,bl
  4838                                  	jz ReadF0			;no useful ascii char pressed
  4839                                  	mov bh,0xFF
  4840                                  	and dword [ecx+16],LEFT_ALT_PRESSED	;controlkeystate: left ALT key pressed
  4841                                  	jz Normal2
  4842                                  	mov bh,0xFD			;marker for a pre-processed ALT key
  4843                                  Normal2:mov dword[ecx],ebx
  4844                                  	ret
  4845                                  %else					;this way simple input via ReadFile
  4846                                  	mov ebx,[hin]
  4847                                  %endif
  4848                                  %else
  4849 00001BCD 31DB                    	xor ebx,ebx			;mov ebx,stdin		;file desc
  4850                                  %endif
  4851                                  Read_File:
  4852                                  %ifdef W32
  4853                                  	push ecx			;destr
  4854                                  	push edx			;destr
  4855                                  	push byte 0
  4856                                  	push dword w32result
  4857                                  	push edx			;length
  4858                                  	push ecx			;buffer
  4859                                  	push ebx			;handle
  4860                                  	call ReadFile
  4861                                  	pop edx
  4862                                  	pop ecx
  4863                                  ;-------
  4864                                  	or eax,eax
  4865                                  	jnz ReadFileOkay
  4866                                  	call GetLastError
  4867                                  	mov [ErrNr],eax
  4868                                  	neg eax
  4869                                  	ret
  4870                                  ReadFileOkay:
  4871                                  	mov eax,[w32result]
  4872                                  	or eax,eax			;clear sign flag
  4873                                  	ret
  4874                                  %else
  4875                                  %ifdef BEOS
  4876                                  	push byte SYS_read		;4+X? stack places
  4877                                  	jmp short WFile
  4878                                  %else
  4879                                  %ifdef LIBC
  4880                                  	push edx
  4881                                  	push ecx
  4882                                  	push ebx
  4883                                  	call read
  4884                                  	mov ebx,[_errno]
  4885                                  	mov [ErrNr],ebx
  4886                                  	pop ebx
  4887                                  	pop ecx
  4888                                  	pop edx
  4889                                  	or eax,eax
  4890                                  	ret
  4891                                  %else
  4892 00001BCF B003                    	mov al,SYS_read			;system call number (sys_read) ;return read byte EAX
  4893 00001BD1 EB3B                    	jmp short IntCall		;ebx file / ecx buffer / edx count byte
  4894                                  %endif
  4895                                  %endif
  4896                                  %endif
  4897                                  ;-------
  4898 00001BD3 31D2                    WriteFile00:xor edx,edx
  4899 00001BD5 42                      	inc edx				;mov edx,1	write 1 byte
  4900                                  WriteFile0:
  4901                                  %ifdef W32
  4902                                  	mov ebx,[hout]
  4903                                  %else
  4904 00001BD6 31DB                    	xor ebx,ebx			;mov ebx,stdout		;file desc
  4905 00001BD8 43                      	inc ebx				;ditto
  4906                                  %endif
  4907                                  Write_File:
  4908                                  %ifdef W32
  4909                                  	push edx			;destr
  4910                                  	push byte 0
  4911                                  	push dword w32result
  4912                                  	push edx			
  4913                                  	push ecx			;buffer
  4914                                  	push ebx			;handle
  4915                                  	call WriteFile
  4916                                  	pop edx
  4917                                  	or eax,eax
  4918                                  	jnz WriteFileOkay
  4919                                  	call GetLastError
  4920                                  	mov [ErrNr],eax
  4921                                  	neg eax
  4922                                  	ret
  4923                                  WriteFileOkay:
  4924                                  	mov eax,[w32result]
  4925                                  	or eax,eax			;clr sign flag
  4926                                  	ret
  4927                                  %else
  4928                                  %ifdef BEOS
  4929                                  	push byte SYS_write
  4930                                  WFile:	pop eax
  4931                                  	call IntRdWr
  4932                                  	nop
  4933                                  	nop
  4934                                  	nop
  4935                                  	nop
  4936                                  	ret
  4937                                  %else
  4938                                  %ifdef LIBC
  4939                                  	push edx
  4940                                  	push ecx
  4941                                  	push ebx
  4942                                  	call write
  4943                                  	mov ebx,[_errno]
  4944                                  	mov [ErrNr],ebx
  4945                                  	pop ebx
  4946                                  	pop ecx
  4947                                  	pop edx
  4948                                  	or eax,eax
  4949                                  	ret
  4950                                  %else
  4951 00001BD9 B004                    	mov al,SYS_write
  4952 00001BDB EB31                    	jmp short IntCall
  4953                                  %endif
  4954                                  %endif
  4955                                  %endif
  4956                                  ;-------
  4957                                  OpenFile0:
  4958                                  %ifndef BEOS
  4959                                  %ifdef W32
  4960                                  	mov ecx,OPEN_EXISTING
  4961                                  	mov edx,GENERIC_READ
  4962                                  %else
  4963 00001BDD 31C9                    	xor ecx,ecx			;i.e O_RDONLY
  4964                                  %endif
  4965                                  %endif
  4966                                  OpenFile:
  4967                                  %ifdef W32
  4968                                  	push byte 0
  4969                                  	push dword FILE_ATTRIBUTE_NORMAL
  4970                                  	push ecx			;"CREATE_ALWAYS" or "OPEN_EXISTING"
  4971                                  	push byte 0
  4972                                  	push byte 0
  4973                                  	push edx			;"GENERIC_WRITE" or "GENERIC_READ"
  4974                                  	push ebx			;filename
  4975                                  	call CreateFileA
  4976                                  	cmp eax,INVALID_HANDLE_VALUE
  4977                                  	jnz OpenFileOkay
  4978                                  	call GetLastError
  4979                                  	mov [ErrNr],eax
  4980                                  	neg eax
  4981                                  OpenFileOkay:ret
  4982                                  %else
  4983                                  %ifdef BEOS
  4984                                  	mov al,SYS_open			;5 stack places
  4985                                  	push edi
  4986                                  	mov edi,0x1A4
  4987                                  	call IntCall
  4988                                  	pop edi
  4989                                  	ret
  4990                                  %else
  4991                                  %ifdef LIBC
  4992                                  	push edx
  4993                                  	push ecx
  4994                                  	push ebx
  4995                                  	call open
  4996                                  	mov ebx,[_errno]
  4997                                  	mov [ErrNr],ebx
  4998                                  	pop ebx
  4999                                  	pop ecx
  5000                                  	pop edx
  5001                                  	or eax,eax
  5002                                  	ret
  5003                                  %else
  5004 00001BDF B005                    	mov al,SYS_open
  5005 00001BE1 EB2B                    	jmp short IntCall		;ecx mode / ebx path / edx permissions (if create)
  5006                                  %endif
  5007                                  %endif
  5008                                  %endif
  5009                                  ;-------
  5010                                  CloseFile:
  5011                                  %ifdef W32
  5012                                  	push edx			;destr
  5013                                  	push ecx			;destr
  5014                                  	push ebx			;handle
  5015                                  	call CloseHandle
  5016                                  	pop ecx
  5017                                  	pop edx
  5018                                  	ret
  5019                                  %else
  5020                                  %ifdef LIBC
  5021                                  	push edx			;destr
  5022                                  	push ecx			;destr
  5023                                  	push ebx
  5024                                  	call close
  5025                                  	mov ebx,[_errno]
  5026                                  	mov [ErrNr],ebx
  5027                                  	pop ebx
  5028                                  	pop ecx
  5029                                  	pop edx
  5030                                  	or eax,eax
  5031                                  	ret
  5032                                  %else
  5033 00001BE3 B006                    	mov al,SYS_close
  5034 00001BE5 EB27                    	jmp short IntCall		;ebx is file desc
  5035                                  %endif
  5036                                  %endif
  5037                                  ;-------
  5038                                  %ifdef SYS_readlink
  5039 00001BE7 B055                    ReadLink:mov al,SYS_readlink
  5040 00001BE9 EB23                    	jmp short IntCall
  5041                                  %endif
  5042                                  ;-------
  5043                                  %ifdef SYS_fchmod
  5044                                  Fchmod:	
  5045                                  %ifdef LIBC
  5046                                  	push ecx
  5047                                  	push ebx
  5048                                  	call fchmod
  5049                                  	mov ebx,[_errno]
  5050                                  	mov [ErrNr],ebx
  5051                                  	pop ebx
  5052                                  	pop ecx
  5053                                  	or eax,eax
  5054                                  	ret
  5055                                  %else
  5056 00001BEB B05E                    	mov al,SYS_fchmod
  5057 00001BED EB1F                    	jmp short IntCall
  5058                                  %endif
  5059                                  %endif
  5060                                  ;-------
  5061                                  %ifdef SYS_fstat
  5062 00001BEF B9[EC360100]            Fstat:	mov ecx,fstatbuf
  5063                                  %ifdef LIBC
  5064                                  	push ecx
  5065                                  	push ebx
  5066                                  	call fstat
  5067                                  	mov ebx,[_errno]
  5068                                  	mov [ErrNr],ebx
  5069                                  	pop ebx
  5070                                  	pop ecx
  5071                                  	or eax,eax
  5072                                  	ret
  5073                                  %else
  5074                                  %ifdef FREEBSD				;includes NET-BSD
  5075                                  	mov ax,SYS_fstat
  5076                                  	jmp short IntCall2
  5077                                  %else
  5078 00001BF4 B06C                    	mov al,SYS_fstat
  5079 00001BF6 EB16                    	jmp short IntCall
  5080                                  %endif
  5081                                  %endif
  5082                                  ;-------
  5083                                  ChownFile:
  5084                                  %ifdef LIBC
  5085                                  	push edx
  5086                                  	push ecx
  5087                                  	push ebx
  5088                                  	call fchown
  5089                                  	mov ebx,[_errno]
  5090                                  	mov [ErrNr],ebx
  5091                                  	pop ebx
  5092                                  	pop ecx
  5093                                  	pop edx
  5094                                  	or eax,eax
  5095                                  	ret
  5096                                  %else
  5097 00001BF8 B05F                    	mov al,SYS_fchown
  5098 00001BFA EB12                    	jmp short IntCall
  5099                                  %endif
  5100                                  %endif					;endifdef SYS_fstat
  5101                                  ;-------
  5102                                  RenameFile:
  5103                                  %ifdef W32
  5104                                  	push ebx			;destr
  5105                                  	push ecx			;destr
  5106                                  	push ecx			;for MoveFile
  5107                                  	push ecx
  5108                                  	call DeleteFileA
  5109                                  	push ebx
  5110                                  	call MoveFileA
  5111                                  	pop ecx
  5112                                  	pop ebx
  5113                                  	or eax,eax
  5114                                  	jnz RenameFileOkay
  5115                                  	call GetLastError
  5116                                  	mov [ErrNr],eax
  5117                                  	neg eax
  5118                                  	ret
  5119                                  RenameFileOkay:	
  5120                                  	xor eax,eax
  5121                                  	ret
  5122                                  %else
  5123                                  %ifdef LIBC
  5124                                  	push ecx
  5125                                  	push ebx
  5126                                  	call rename
  5127                                  	mov ebx,[_errno]
  5128                                  	mov [ErrNr],ebx
  5129                                  	pop ebx
  5130                                  	pop ecx
  5131                                  	or eax,eax
  5132                                  	ret
  5133                                  %else
  5134 00001BFC B026                    	mov al,SYS_rename
  5135 00001BFE EB0E                    	jmp short IntCall
  5136                                  %endif
  5137                                  %endif
  5138                                  ;-------
  5139                                  %ifdef SYS_brk
  5140 00001C00 B02D                    SysBrk:	mov al,SYS_brk
  5141 00001C02 EB0A                    	jmp short IntCall		;ebx addr
  5142                                  %endif
  5143                                  ;-------
  5144                                  %ifndef W32
  5145 00001C04 31DB                    Exit:	xor ebx,ebx
  5146                                  Exit2:
  5147                                  %ifdef LIBC
  5148                                  	push ebx
  5149                                  	call _exit
  5150                                  %else
  5151 00001C06 B001                    	mov al,SYS_exit
  5152 00001C08 EB04                    	jmp short IntCall
  5153                                  %endif
  5154                                  %endif
  5155                                  ;-------
  5156 00001C0A 31C9                    SeekFile:xor ecx,ecx			;ecx offset / ebx file / edx method
  5157                                  %ifdef W32
  5158                                  	push edx
  5159                                  	push byte 0
  5160                                  	push ecx
  5161                                  	push ebx
  5162                                  	call SetFilePointer
  5163                                  	cmp eax,0xFFFFFFFF
  5164                                  	jnz SeekFileOkay
  5165                                  	call GetLastError
  5166                                  	mov [ErrNr],eax
  5167                                  	neg eax
  5168                                  SeekFileOkay:ret
  5169                                  %else
  5170                                  %ifdef FREEBSD				;31 October 2005: 64 bit offset  initial for *BSD
  5171                                  	push edi			;ebx=fh/ecx=dummy/edx,esi=offset/edi=where
  5172                                  	push esi
  5173                                  	xor esi,esi
  5174                                  	xor edi,edi
  5175                                  	xchg edx,edi
  5176                                  	mov al,SYS_lseek
  5177                                  	call IntCall
  5178                                  	neg eax
  5179                                  	mov [ErrNr],eax
  5180                                  	neg eax				;set flags also
  5181                                  	pop esi
  5182                                  	pop edi
  5183                                  	ret
  5184                                  %else
  5185                                  %ifdef BEOS
  5186                                  	mov al,SYS_lseek		;4 stack places (using 64 bit for ptr)
  5187                                  	push edi
  5188                                  	push edx
  5189                                  	mov edi,edx
  5190                                  	xor edx,edx
  5191                                  	call IntCall
  5192                                  	pop edx
  5193                                  	pop edi
  5194                                  	ret
  5195                                  %else
  5196                                  %ifdef LIBC
  5197                                  	push edx
  5198                                  %ifdef OPENBSD
  5199                                  	push byte 0
  5200                                  %endif
  5201                                  	push ecx
  5202                                  	push ebx
  5203                                  	call lseek
  5204                                  	mov ebx,[_errno]
  5205                                  	mov [ErrNr],ebx
  5206                                  	pop ebx
  5207                                  	pop ecx
  5208                                  %ifdef OPENBSD
  5209                                  	pop edx
  5210                                  %endif
  5211                                  	pop edx
  5212                                  	or eax,eax
  5213                                  	ret
  5214                                  %else
  5215 00001C0C B013                    	mov al,SYS_lseek		;oldseek =32bit
  5216                                  %endif
  5217                                  %endif
  5218                                  %endif
  5219                                  %endif
  5220                                  ;-------
  5221                                  %ifndef LIBC
  5222                                  %ifndef W32
  5223 00001C0E B400                    IntCall:mov ah,0
  5224 00001C10 98                      IntCall2:cwde
  5225                                  %ifdef BEOS
  5226                                  	push edi
  5227                                  	push byte 0
  5228                                  	push edi
  5229                                  	push edx
  5230                                  	push ecx
  5231                                  	push ebx
  5232                                  	push dword be_ret
  5233                                  	int 25h
  5234                                  be_ret:	pop ebx
  5235                                  	pop ebx
  5236                                  	pop ecx
  5237                                  	pop edx
  5238                                  	pop edi
  5239                                  	pop edi
  5240                                  	mov [ErrNr],eax
  5241                                  	and dword [ErrNr],7Fh
  5242                                  	or eax,eax			;set flags also
  5243                                  	pop edi
  5244                                  %else
  5245                                  %ifdef ATHEOS
  5246                                  	int 80h
  5247                                  	cmp eax,0xFFFFF001
  5248                                  	jae Fru
  5249                                  	or eax,eax
  5250                                  	ret
  5251                                  Fru:	neg eax
  5252                                  	mov [ErrNr],eax
  5253                                  	and dword [ErrNr],7Fh
  5254                                  	neg eax				;set flags also
  5255                                  	ret
  5256                                  %else
  5257                                  %ifdef LINUX
  5258                                  %ifdef AMD64
  5259                                  	push rbx
  5260                                  	push rcx
  5261                                  	push rsi
  5262                                  	push rdi
  5263                                  	xchg rbx,rdi
  5264                                  	xchg rcx,rsi
  5265                                  	xchg rbx,r8
  5266                                  	mov r10,rcx			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5267                                  	syscall
  5268                                  	pop rdi
  5269                                  	pop rsi
  5270                                  	pop rcx
  5271                                  	pop rbx
  5272                                  %else
  5273 00001C11 CD80                    	int 80h
  5274                                  %endif
  5275                                  %else
  5276                                  	push edi
  5277                                  	push esi
  5278                                  	push edx
  5279                                  	push ecx
  5280                                  	push ebx
  5281                                  %ifdef NETBSD
  5282                                  	push dword nbsdint
  5283                                  %else
  5284                                  	push eax
  5285                                  %endif	
  5286                                  	int 80h
  5287                                  nbsdint:
  5288                                  	pop ebx
  5289                                  	pop ebx
  5290                                  	pop ecx
  5291                                  	pop edx
  5292                                  	pop esi
  5293                                  	pop edi
  5294                                  	jc err
  5295                                  %endif
  5296 00001C13 F7D8                    AfterInt:neg eax
  5297 00001C15 A3[5C2F0100]            err:	mov [ErrNr],eax
  5298 00001C1A F7D8                    	neg eax				;set flags also
  5299                                  %endif
  5300                                  %endif
  5301 00001C1C C3                      	ret
  5302                                  %endif
  5303                                  %endif
  5304                                  ;-------
  5305                                  %ifdef BEOS
  5306                                  IntRdWr:push edx			;used for Read & Write
  5307                                  	push ecx
  5308                                  	push ebx
  5309                                  	push dword be_ret2
  5310                                  	int 25h
  5311                                  be_ret2:pop ebx
  5312                                  	pop ebx
  5313                                  	pop ecx
  5314                                  	pop edx
  5315                                  	mov [ErrNr],eax
  5316                                  	pop eax
  5317                                  	lea eax,[eax+4]			;add eax,4
  5318                                  	push eax
  5319                                  	mov eax,[ErrNr]
  5320                                  	and dword [ErrNr],7Fh
  5321                                  	or eax,eax			;set flags
  5322                                  	ret
  5323                                  %endif
  5324                                  ;--------------------------------------------------------------------------
  5325                                  %ifdef SYS_select
  5326                                  %ifdef LIBC
  5327                                  Select:	push dword timevalsec
  5328                                  	xor ebx,ebx
  5329                                  	push ebx
  5330                                  	push ebx
  5331                                  	mov ecx,readfds
  5332                                  	push ecx
  5333                                  	inc ebx
  5334                                  	mov byte [ecx],bl
  5335                                  	push ebx
  5336                                  	call select
  5337                                  	push ebx
  5338                                  	mov ebx,[_errno]
  5339                                  	mov [ErrNr],ebx
  5340                                  	pop ebx
  5341                                  	add esp,20
  5342                                  	or eax,eax
  5343                                  	ret
  5344                                  %else
  5345 00001C1D 31DB                    Select:	xor ebx,ebx
  5346 00001C1F 43                      	inc ebx
  5347 00001C20 B9[A4380100]            	mov ecx,readfds
  5348 00001C25 8819                    	mov byte [ecx],bl
  5349 00001C27 31D2                    	xor edx,edx
  5350 00001C29 31F6                    	xor esi,esi
  5351 00001C2B BF[A8380100]            	mov edi,timevalsec		;points to [0 sec / 0 usec]
  5352 00001C30 B08E                    	mov al,SYS_select
  5353 00001C32 EBDA                    	jmp short IntCall
  5354                                  %endif
  5355                                  %endif
  5356                                  ;-----------------------------------------------------------------------
  5357                                  %ifdef SYS_readlink
  5358 00001C34 B01E                    Utime:	mov al,SYS_utime
  5359 00001C36 EBD6                    	jmp short IntCall
  5360                                  %endif
  5361                                  ;-------
  5362                                  %ifdef USE_PIPE
  5363 00001C38 B002                    Fork:	mov al,SYS_fork
  5364 00001C3A EBD2                    	jmp short IntCall
  5365                                  ;-------
  5366                                  Pipe:	
  5367                                  %ifdef FREEBSD
  5368                                  	mov eax,SYS_pipe
  5369                                  	push edi
  5370                                  	push esi
  5371                                  	push ecx
  5372                                  	push ebx
  5373                                  	int 80h
  5374                                  	pop ebx
  5375                                  	pop ecx
  5376                                  	pop esi
  5377                                  	pop edi
  5378                                  	mov [ebx],eax
  5379                                  	mov [ebx+4],edx
  5380                                  	jmp short AfterInt
  5381                                  %else
  5382 00001C3C B02A                    	mov al,SYS_pipe
  5383 00001C3E EBCE                    	jmp short IntCall
  5384                                  %endif
  5385                                  ;-------
  5386 00001C40 B03F                    Dup2:	mov al,SYS_dup2
  5387 00001C42 EBCA                    	jmp short IntCall
  5388                                  ;-------
  5389 00001C44 B00B                    Execve:	mov al,SYS_execve
  5390 00001C46 EBC6                    	jmp short IntCall
  5391                                  ;-------
  5392 00001C48 B072                    Wait4:	mov al,SYS_wait4		;set ecx to buffer!
  5393                                  %ifdef AMD64
  5394                                  	xor rbx,rbx
  5395                                  	dec rbx	
  5396                                  %else
  5397 00001C4A 31DB                    	xor ebx,ebx
  5398 00001C4C 4B                      	dec ebx
  5399                                  %endif
  5400 00001C4D 31D2                    	xor edx,edx
  5401 00001C4F 31F6                    	xor esi,esi
  5402 00001C51 EBBB                    	jmp short IntCall
  5403                                  ;-------
  5404                                  %endif
  5405                                  Unlink:
  5406                                  %ifdef W32
  5407                                  	push edx
  5408                                  	push ecx
  5409                                  	push ebx
  5410                                  	call DeleteFileA
  5411                                  	pop ebx
  5412                                  	pop ecx
  5413                                  	pop edx
  5414                                  	ret
  5415                                  %else
  5416                                  %ifdef LIBC
  5417                                  	push edx
  5418                                  	push ecx
  5419                                  	push ebx
  5420                                  	call unlink
  5421                                  	mov ebx,[_errno]
  5422                                  	mov [ErrNr],ebx
  5423                                  	pop ebx
  5424                                  	pop ecx
  5425                                  	pop edx
  5426                                  	or eax,eax
  5427                                  	ret
  5428                                  %else
  5429                                  %ifdef BEOS
  5430                                  	mov ecx,ebx
  5431                                  %endif
  5432 00001C53 B00A                    	mov al,SYS_unlink
  5433 00001C55 EBB7                    	jmp short IntCall		;ebx is file desc
  5434                                  %endif
  5435                                  %endif
  5436                                  ;----------------------------------------------------------------------
  5437                                  %ifdef SYS_kill
  5438 00001C57 E877F6FFFF              KeySuspend:call KursorStatusLine	;simply looks better so
  5439 00001C5C 6A13                    	push byte SIGSTOP
  5440 00001C5E 59                      	pop ecx
  5441 00001C5F 31DB                    	xor ebx,ebx
  5442 00001C61 B025                    Kill:	mov al,SYS_kill
  5443 00001C63 EBA9                    ICjmp:	jmp short IntCall
  5444                                  ;-------
  5445                                  SetSigHandler:
  5446 00001C65 6A12                    	push byte SIGCONT
  5447 00001C67 5B                      	pop ebx
  5448 00001C68 B9[48360100]            	mov ecx,sigaction
  5449                                  %ifdef AMD64
  5450                                  	mov rdx,qword SigHandler
  5451                                  	mov qword [rcx],rdx
  5452                                  	mov qword [rcx+8],4000000h	;flags @ 8
  5453                                  	mov rdx,qword SigRestorer
  5454                                  	mov qword [rcx+16],rdx		;restorer @ 16
  5455                                  	xor edx,edx
  5456                                  	mov esi,8
  5457                                  	mov al,SYS_rt_sigaction
  5458                                  	jmp short ICjmp
  5459                                  ;-------
  5460                                  SigRestorer:mov eax,SYS_rt_sigreturn
  5461                                  	syscall				;thanks to Andi Kleen for info
  5462                                  %else
  5463 00001C6D C701[671B0000]          	mov [ecx],dword SigHandler
  5464 00001C73 31D2                    	xor edx,edx
  5465                                  %ifdef SIGREST32			;just like on AMD-64 would be:
  5466                                  	mov dword [ecx+8],4000000h
  5467                                  	mov [ecx+12],dword SigRestorer32
  5468                                  %endif
  5469 00001C75 B043                    Sigaction:mov al,SYS_sigaction
  5470 00001C77 EBEA                    	jmp short ICjmp
  5471                                  ;-------
  5472                                  %ifdef SIGREST32
  5473                                  SigRestorer32:pop eax
  5474                                  	mov eax,119			;sigreturn
  5475                                  	int 80h				;syscall
  5476                                  %endif
  5477                                  %endif
  5478                                  %endif
  5479                                  ;-----------------------------------------------------------------------
  5480                                  ;
  5481                                  ; pipe buffer through child process
  5482                                  ;
  5483                                  %ifdef USE_PIPE
  5484 00001C79 E8FDF0FFFF              KeyCtrlKP:call InputStringWithMessage0	;WS, Emacs's, Pico's access to sed|ex pipe
  5485 00001C7E 9C                      	pushf
  5486 00001C7F E859F6FFFF              	call RestKursPos
  5487 00001C84 9D                      	popf
  5488 00001C85 721E                    	jc ExExEx
  5489 00001C87 E838F4FFFF              KeyVICmdtemp:call CheckENum		;i.e. mov byte [numeriere],1
  5490                                  	PUSH_ALL
  5491 00001C8C 60                  <1>  pusha
  5492 00001C8D BB[7E220000]            	mov ebx,tempfile
  5493 00001C92 BE[ED3C0100]            	mov esi,sot
  5494 00001C97 892D[1C2F0100]          	mov [blockende],ebp
  5495 00001C9D E85FFAFFFF              	call SaveBl3
  5496                                  	POP_ALL
  5497 00001CA2 61                  <1>  popa
  5498 00001CA3 7301                    	jnc SaveOK
  5499 00001CA5 C3                      ExExEx:	ret				;cannot save buffer to tmp file...
  5500                                  SaveOK:					;...this is handled inside SaveBlock, so just return
  5501                                  %ifdef USE_UNDO
  5502 00001CA6 31C0                    	xor eax,eax
  5503 00001CA8 48                      	dec eax
  5504 00001CA9 E829040000              	call DataForUndoDelete
  5505                                  %endif
  5506                                  %ifdef CAPTURE_STDERR
  5507 00001CAE BB[98380100]            	mov ebx,sedpipeC0
  5508 00001CB3 E884FFFFFF              	call Pipe
  5509 00001CB8 782F                    	js OSerrJmp0
  5510                                  %endif
  5511 00001CBA BB[90380100]            	mov ebx,sedpipeB0
  5512 00001CBF E878FFFFFF              	call Pipe
  5513 00001CC4 7823                    	js OSerrJmp0
  5514 00001CC6 E86DFFFFFF              	call Fork
  5515 00001CCB 781C                    	js OSerrJmp0
  5516 00001CCD 09C0                    	or eax,eax
  5517 00001CCF 0F84B9000000            	jz near ForkChild
  5518                                  ;-------
  5519                                  %ifdef USE_EX_NO_SED
  5520                                  ;
  5521                                  ; This is the UNDEFAULT way using "ex -s" (silent ex).
  5522                                  ; We save the buffer into a tempfile and
  5523                                  ; WRITE the COMMAND (followed by 'wq' command)
  5524                                  ; into a pipe to ex's STDIN.
  5525                                  ; Then we truncate the current edit buffer
  5526                                  ; and read the tempfile just like a WS block.
  5527                                  ;
  5528                                  ; "Anything you want, you got it"
  5529                                  ; "Anything you need, you got it"
  5530                                  ; "Anything at all, you got it, Baby ...." (Jeff Lynne/Roy Orbison/Tom Petty 1989)
  5531                                  ;
  5532                                  	mov ebx,[ebx]			;i.e. sedpipeB0
  5533                                  	call CloseFile			;unused pipe direction READ
  5534                                  OSerrJmp0:js OSerrJmp1
  5535                                  	mov ebx,[sedpipeB1]
  5536                                  ;-------
  5537                                  	xor edx,edx
  5538                                  	mov ecx,optbuffer
  5539                                  	mov esi,ecx
  5540                                  	cld
  5541                                  	dec edx
  5542                                  Bufloop:inc edx
  5543                                  	lodsb
  5544                                  	or al,al
  5545                                  	jnz Bufloop			;count ex cmd length
  5546                                  	call Write_File			;write to ex program
  5547                                  ;-------
  5548                                  	mov ecx,wq_suffix
  5549                                  	mov edx,wq_suffix_len
  5550                                  	call Write_File			;write "wq" string to ex program
  5551                                  	call CloseFile
  5552                                  OSerrJmp1:js OSerrJmp
  5553                                  	mov ecx,optbuffer		;for return status
  5554                                  	push ecx			;new in e3 2.6.1 (needed in Linux 2.6.8-24.10)
  5555                                  	push edi
  5556                                  	call Wait4
  5557                                  	pop edi
  5558                                  	pop ecx
  5559                                  	js OSerrJmp
  5560                                  	mov ecx,[ecx]			;getting return status
  5561                                  	shr ecx,8
  5562                                  	and ecx,0xFF
  5563                                  	mov [ErrNr],ecx
  5564                                  	jnz OSerrJmp
  5565                                  ;-------
  5566                                  	mov ebx,tempfile
  5567                                  	push ebp
  5568                                  	push edi
  5569                                  	mov edi,sot			;truncate old file
  5570                                  	mov ebp,sot
  5571                                  	mov al,LINEFEED
  5572                                  	xchg byte [ebp],al		;EOF marker
  5573                                  	push eax
  5574                                  	call ReadBlock2
  5575                                  	pop eax
  5576                                  	pop edi
  5577                                  	jc preEx_Ex
  5578                                  	pop ebx				;dummy (not restore ebp)
  5579                                  ;-------
  5580                                  	mov ebx,tempfile
  5581                                  	call Unlink
  5582                                  	jns ChkCursPos			;if no Error
  5583                                  ;-------
  5584                                  OSerrJmp:call ChkCursPos		;Error in Wait,Close,...
  5585                                  	jmp near OSerror		;TODO: unlink helper file if exists
  5586                                  preEx_Ex:pop ebp			;Error in ReadBlock
  5587                                  	mov byte[sot],al		;restore pre op values if Read Error
  5588                                  	;continue ChkCursPos
  5589                                  ;
  5590                                  %else	;------------------ DEFAULT WAY -------------------
  5591                                  ;
  5592                                  ; This is the DEFAULT way using stream editor "sed -e".
  5593                                  ; The default way is quite opposite: we save the buffer
  5594                                  ; into a tempfile, then call sed with the operational command
  5595                                  ; given on sed's command line and at last we READ the DATA
  5596                                  ; from sed's output via a STDIN READ pipe.
  5597                                  ;
  5598 00001CD5 53                      	push ebx
  5599 00001CD6 8B5B04                  	mov ebx,[ebx+4]			;i.e. sedpipeB1
  5600 00001CD9 E805FFFFFF              	call CloseFile			;unused pipe direction
  5601                                  %ifdef CAPTURE_STDERR
  5602 00001CDE 8B1D[9C380100]          	mov ebx,[sedpipeC1]
  5603 00001CE4 E8FAFEFFFF              	call CloseFile			;unused pipe direction
  5604                                  %endif
  5605 00001CE9 7849                    OSerrJmp0:js OSerrJmp1
  5606 00001CEB 5B                      	pop ebx
  5607 00001CEC 8B35[C42F0100]          	mov esi,[maxlen]
  5608 00001CF2 8B1B                    	mov ebx,[ebx]			;pipe read channel
  5609 00001CF4 B9[ED2C0100]            	mov ecx,sot-SEDBLOCK
  5610 00001CF9 01CE                    	add esi,ecx
  5611 00001CFB 55                      	push ebp
  5612 00001CFC BD[ED3C0100]            	mov ebp,sot
  5613 00001D01 31C0                    	xor eax,eax
  5614 00001D03 E844FCFFFF              	call InitSV1			;forbid any side efects
  5615 00001D08 BA00100000              ReadPipe:mov edx,SEDBLOCK
  5616 00001D0D 01D1                    	add ecx,edx
  5617 00001D0F E8BBFEFFFF              	call Read_File
  5618 00001D14 01C5                    	add ebp,eax			;compute eof
  5619 00001D16 39F5                    	cmp ebp,esi
  5620 00001D18 7310                    	jae ReadOK			;sorry, truncating. FIXME: add a message
  5621 00001D1A 39D0                    	cmp eax,edx
  5622 00001D1C 74EA                    	jz ReadPipe
  5623 00001D1E 81FD[ED3C0100]          	cmp ebp,sot			;if nothing comes back, keep buffer as is
  5624 00001D24 7504                    	jnz ReadOK
  5625 00001D26 5A                      	pop edx
  5626 00001D27 89D5                    	mov ebp,edx
  5627 00001D29 56                      	push esi			;keep stack balanced
  5628 00001D2A C645000A                ReadOK:	mov byte [ebp],NEWLINE		;EOF marker
  5629 00001D2E 5E                      	pop esi				;dummy
  5630 00001D2F E8AFFEFFFF              	call CloseFile
  5631 00001D34 784E                    OSerrJmp1:js OSerrJmp
  5632                                  %ifdef CAPTURE_STDERR
  5633 00001D36 8B1D[98380100]          	mov ebx,[sedpipeC0]
  5634                                  %ifdef BEEP_IN_VI
  5635 00001D3C B9[B0380100]            	mov ecx,buffercopy
  5636 00001D41 31D2                    	xor edx,edx
  5637 00001D43 42                      	inc edx
  5638 00001D44 E886FEFFFF              	call Read_File
  5639 00001D49 09C0                    	or eax,eax
  5640 00001D4B 7405                    	je NoStdErrMsg
  5641 00001D4D E8EC020000              	call VIBeepForD
  5642                                  %endif
  5643 00001D52 E88CFEFFFF              NoStdErrMsg:call CloseFile		;stderr pipe
  5644                                  %endif
  5645 00001D57 E86DE4FFFF              	call SetChg			;i.e. mov byte [changed],CHANGED  (assumption only)
  5646 00001D5C B9[C8350100]            	mov ecx,optbuffer		;for return status
  5647 00001D61 51                      	push ecx			;new in e3 2.6.1 (needed in Linux 2.6.8-24.10)
  5648 00001D62 57                      	push edi
  5649 00001D63 E8E0FEFFFF              	call Wait4
  5650 00001D68 5F                      	pop edi
  5651 00001D69 59                      	pop ecx				;ditto new in e3 2.6.1
  5652 00001D6A 7818                    	js OSerrJmp
  5653 00001D6C BB[7E220000]            	mov ebx,tempfile
  5654 00001D71 E8DDFEFFFF              	call Unlink
  5655 00001D76 780C                    	js OSerrJmp
  5656 00001D78 0FB64901                	movzx ecx,byte[ecx+1]		;old shr ecx,8 / and ecx,0xFF
  5657 00001D7C 890D[5C2F0100]          	mov [ErrNr],ecx
  5658 00001D82 E35D                    	jecxz ChkCursPos
  5659 00001D84 E858000000              OSerrJmp:call ChkCursPos		;TODO: unlink helper file if exists
  5660 00001D89 E9DCF9FFFF              	jmp near OSerror
  5661                                  %endif
  5662                                  ;----------------------------------------------------------------------
  5663 00001D8E 8B1B                    ForkChild:mov ebx,[ebx]			;i.e. sedpipeB0
  5664 00001D90 31C9                    	xor ecx,ecx
  5665                                  %ifdef USE_EX_NO_SED
  5666                                  	call Dup2			;capturing STDIN
  5667                                  	js FCError
  5668                                  	mov ebx,[sedpipeB1]
  5669                                  	call CloseFile			;unused pipe direction STDOUT
  5670                                  	js FCError
  5671                                  	mov ebx,expath
  5672                                  	mov ecx,exargs
  5673                                  %else
  5674 00001D92 E84CFEFFFF              	call CloseFile			;unused pipe direction STDIN
  5675 00001D97 7840                    	js FCError
  5676 00001D99 8B1D[94380100]          	mov ebx,[sedpipeB1]
  5677 00001D9F 41                      	inc ecx
  5678 00001DA0 E89BFEFFFF              	call Dup2			;capturing STDOUT
  5679 00001DA5 7832                    	js FCError
  5680                                  %ifdef CAPTURE_STDERR
  5681 00001DA7 8B1D[98380100]          	mov ebx,[sedpipeC0]
  5682 00001DAD E831FEFFFF              	call CloseFile			;unused pipe direction
  5683 00001DB2 41                      	inc ecx
  5684 00001DB3 8B1D[9C380100]          	mov ebx,[sedpipeC1]
  5685 00001DB9 E882FEFFFF              	call Dup2			;capturing STDERR
  5686 00001DBE 7819                    	js FCError
  5687                                  %endif
  5688 00001DC0 BB[97220000]            	mov ebx,sedpath
  5689 00001DC5 B9[83220000]            	mov ecx,sedargs
  5690                                  %endif
  5691 00001DCA 31D2                    	xor edx,edx			;no env
  5692 00001DCC E873FEFFFF              	call Execve
  5693 00001DD1 6A1F                    	push byte ERRNOEXEC
  5694 00001DD3 5B                      	pop ebx				;set error
  5695 00001DD4 E92DFEFFFF              FCex:	jmp near Exit2			;in case of error
  5696 00001DD9 8B1D[5C2F0100]          FCError:mov ebx,[ErrNr]
  5697 00001DDF EBF3                    	jmp short FCex
  5698                                  %endif ;USE_PIPE
  5699                                  ;----------------------------------------------------------------------
  5700                                  ;
  5701                                  ; care about cursor pos
  5702                                  ;
  5703                                  ChkCursPos:
  5704                                  %ifdef UTF8
  5705 00001DE1 47                      	inc edi
  5706 00001DE2 4F                      CCloopUTF8:dec edi
  5707                                  %ifdef UTF8RTS
  5708                                  	cmp byte [isUTF8],0
  5709                                  	je noUTF_Z
  5710                                  %endif
  5711 00001DE3 8A07                    	mov al,byte [edi]
  5712 00001DE5 24C0                    	and al,0C0h
  5713 00001DE7 3C80                    	cmp al,080h
  5714 00001DE9 74F7                    	je CCloopUTF8
  5715                                  noUTF_Z:
  5716                                  %endif
  5717 00001DEB 39EF                    	cmp edi,ebp			;never let run cursor outside buffer
  5718 00001DED 7602                    	jbe CCP
  5719 00001DEF 89EF                    	mov edi,ebp
  5720 00001DF1 81FF[ED3C0100]          CCP:	cmp edi,sot
  5721 00001DF7 7305                    	jae CCP2
  5722 00001DF9 BF[ED3C0100]            	mov edi,sot
  5723 00001DFE C3                      CCP2:	ret
  5724                                  ;----------------------------------------------------------------------
  5725                                  ;
  5726                                  ; copy file to a real backup file (for sym linked files only)
  5727                                  ;
  5728                                  ; expecting ebx==filepath
  5729                                  ;	    ecx==bakpath
  5730                                  ;
  5731                                  %ifdef SYS_readlink
  5732                                  CopyToBackup:PUSH_ALL
  5733                              <1> CopyToBackup:
  5734 00001DFF 60                  <1>  pusha
  5735 00001E00 51                      	push ecx			;backup file path later needed for Utime call
  5736 00001E01 51                      	push ecx
  5737 00001E02 E8D6FDFFFF              	call OpenFile0
  5738 00001E07 96                      	xchg esi,eax			;save handle to copy of original file
  5739 00001E08 B941020000              	mov ecx,O_WRONLY_CREAT_TRUNC
  5740 00001E0D 8B15[E8360100]          	mov edx,[perms]
  5741 00001E13 5B                      	pop ebx				;handle to backupfile
  5742 00001E14 E8C6FDFFFF              	call OpenFile
  5743 00001E19 93                      	xchg ebx,eax
  5744 00001E1A 8B0D[F8360100]          	mov ecx,[fstatbuf+stat_struc.st_uid]
  5745                                  %ifdef UIDGID_WORD                      ;Linux special
  5746 00001E20 89CA                    	mov edx,ecx
  5747 00001E22 C1EA10                  	shr edx,16
  5748 00001E25 0FB7C9                  	movzx ecx,cx			;OLD and ecx,0xffff
  5749                                  %else
  5750                                  	mov edx,[fstatbuf+stat_struc.st_gid]
  5751                                  %endif
  5752 00001E28 E8CBFDFFFF              	call ChownFile
  5753                                  ;-------
  5754 00001E2D 31FF                    	xor edi,edi			;init eof indicator
  5755 00001E2F 53                      copylop:push ebx
  5756 00001E30 89F3                    	mov ebx,esi			;saved orig file handle
  5757 00001E32 B9[00000000]            	mov ecx,screenbuffer		;used as copy buffer
  5758 00001E37 BA00100000              	mov edx,4096
  5759 00001E3C E88EFDFFFF              	call Read_File
  5760 00001E41 5B                      	pop ebx				;backup file handle
  5761                                  	;js...
  5762 00001E42 39D0                    	cmp eax,edx
  5763 00001E44 7401                    	jz notready
  5764 00001E46 47                      	inc edi				;eof found
  5765 00001E47 B9[00000000]            notready:mov ecx,screenbuffer
  5766 00001E4C 89C2                    	mov edx,eax			;write read count of byte
  5767 00001E4E E886FDFFFF              	call Write_File
  5768                                  	;js...
  5769 00001E53 09FF                    	or edi,edi			;eof ?
  5770 00001E55 74D8                    	jz copylop
  5771                                  ;-------
  5772 00001E57 E887FDFFFF              	call CloseFile			;ready: close backup file
  5773 00001E5C 89F3                    	mov ebx,esi
  5774 00001E5E E880FDFFFF              	call CloseFile			;close original file
  5775 00001E63 5B                      	pop ebx				;original file path
  5776 00001E64 B9[2C370100]            	mov ecx,accesstime		;i.e. a data structure of 2* 32 bit
  5777 00001E69 E8C6FDFFFF              	call Utime			;set change time
  5778                                  	POP_ALL
  5779 00001E6E 61                  <1>  popa
  5780 00001E6F C3                      	ret
  5781                                  %endif
  5782                                  ;----------------------------------------------------------------------
  5783                                  ; recursive descent parser for very SIMPLE math calc within the text:
  5784                                  ;              1234+56*78=
  5785                                  ; place cursor ^<--here and press   ^KN  ^QC  ^XN  #   ^K
  5786                                  ;			(for one of WS   PI   EM   VI  NE modes)
  5787                                  ; 		this should insert the result of 5602 into text.
  5788                                  ;
  5789                                  ; Use values +-0, 0.000001 ,... up to 999999999999.999999 
  5790                                  ; and + - * / 
  5791                                  ; and ( )
  5792                                  ; and r  (for using the last result in next calculation)
  5793                                  ; and p  =3.141593
  5794                                  ;
  5795                                  KeyCtrlKN:
  5796                                  %ifdef USE_MATH
  5797 00001E70 FC                      	cld				;preserve ebp,edi!
  5798 00001E71 DBE3                    	fninit
  5799 00001E73 89FE                    	mov esi,edi
  5800 00001E75 8925[B83C0100]          	mov [stackptr],esp
  5801 00001E7B 31C0                    	xor eax,eax
  5802 00001E7D A3[B03C0100]            	mov [level],eax
  5803 00001E82 A3[B43C0100]            	mov [ptlevel],eax
  5804 00001E87 E8C3000000              	call Recurs0
  5805 00001E8C DD3D[BC3C0100]          	fnstsw [x87]
  5806 00001E92 8025[BC3C0100]1F        	and byte[x87],1Fh		;any exception flags?
  5807 00001E99 0F8599010000            GErr:	jnz near isErr
  5808 00001E9F FF0D[B03C0100]          	dec dword[level]		;stack balanced?
  5809 00001EA5 75F2                    	jnz GErr
  5810 00001EA7 31C0                    	xor eax,eax
  5811 00001EA9 3B05[B43C0100]          	cmp eax,[ptlevel]		;all parenthesis closed?
  5812 00001EAF 75E8                    	jnz GErr
  5813 00001EB1 4E                      NoAllgFehl:dec esi
  5814 00001EB2 89F7                    	mov edi,esi			;up to here we have read
  5815 00001EB4 AC                      	lodsb
  5816 00001EB5 3C3D                    	cmp al,'='
  5817 00001EB7 7408                    	jz EquChar
  5818 00001EB9 B03D                    	mov al,'='
  5819 00001EBB E80A020000              	call OutChar
  5820 00001EC0 4F                      	dec edi
  5821 00001EC1 47                      EquChar:inc edi
  5822 00001EC2 DD15[C83C0100]          	fst qword[lastresult87]		;carry last result for further calc
  5823 00001EC8 DD05[71220000]          	fld qword[factor]
  5824 00001ECE DEC9                    	fmulp st1
  5825 00001ED0 DF35[BC3C0100]          	fbstp [x87]
  5826 00001ED6 6A0C                    	push byte 12			;12 digits
  5827 00001ED8 59                      	pop ecx				
  5828 00001ED9 30F6                    	xor dh,dh			;flag for suppressing leading 0
  5829 00001EDB 8D35[C53C0100]          	lea esi,[x87+9]			;9 BCD data byte and sign
  5830 00001EE1 FD                      	std
  5831 00001EE2 AC                      	lodsb
  5832 00001EE3 08C0                    	or al,al
  5833 00001EE5 790B                    	jns plus
  5834 00001EE7 3C80                    	cmp al,0x80
  5835 00001EE9 75AE                    	jnz GErr
  5836 00001EEB B02D                    	mov al,'-'
  5837 00001EED E8D8010000              	call OutChar
  5838 00001EF2 E83D000000              plus:	call OutHlp
  5839 00001EF7 08F6                    	or dh,dh
  5840 00001EF9 7507                    	jnz dec_dig
  5841 00001EFB B030                    	mov al,'0'
  5842 00001EFD E8C8010000              	call OutChar
  5843                                  ;-------
  5844 00001F02 BE[BC3C0100]            dec_dig:mov esi,x87
  5845 00001F07 31DB                    	xor ebx,ebx
  5846 00001F09 6A03                    	push byte 3
  5847 00001F0B 59                      	pop ecx
  5848 00001F0C FC                      	cld
  5849 00001F0D AC                      dlop:	lodsb
  5850 00001F0E 88C2                    	mov dl,al
  5851 00001F10 240F                    	and al,0fh
  5852 00001F12 750C                    	jnz nonull
  5853 00001F14 43                      	inc ebx
  5854 00001F15 88D0                    	mov al,dl
  5855 00001F17 C0E804                  	shr al,4
  5856 00001F1A 7504                    	jnz nonull
  5857 00001F1C 43                      	inc ebx
  5858 00001F1D E2EE                    isnul2:	loop dlop
  5859 00001F1F C3                      	ret				;no decimal digits: ready
  5860                                  ;-------
  5861 00001F20 6A06                    nonull:	push byte 6			;6 decimal digits
  5862 00001F22 59                      	pop ecx
  5863 00001F23 29D9                    	sub ecx,ebx
  5864 00001F25 B6FF                    	mov dh,0xff			;now do not suppress 0
  5865 00001F27 B02E                    	mov al,'.'
  5866 00001F29 E89C010000              	call OutChar
  5867 00001F2E 8D35[BE3C0100]          	lea esi,[x87+2]			;decimal digits pos
  5868 00001F34 FD                      OutHlp:	std
  5869 00001F35 AC                      	lodsb
  5870 00001F36 88C2                    	mov dl,al
  5871 00001F38 C0E804                  	shr al,4
  5872 00001F3B E882010000              	call OutNumber
  5873 00001F40 49                      	dec ecx
  5874 00001F41 E30B                    	jecxz xret
  5875 00001F43 88D0                    	mov al,dl
  5876 00001F45 240F                    	and al,0fh
  5877 00001F47 E876010000              	call OutNumber
  5878 00001F4C E2E6                    	loop OutHlp
  5879 00001F4E C3                      xret:	ret
  5880                                  ;-------
  5881 00001F4F B02B                    Recurs0:mov al,'+'
  5882 00001F51 50                      RecursPars:push eax			;op code
  5883 00001F52 C605[E83C0100]00        	mov byte[signctl],0		;last token was an opcode
  5884 00001F59 AC                      RecConti:lodsb
  5885 00001F5A 3C0A                    	cmp al,LINEFEED			;EOL?
  5886 00001F5C 7406                    	jz short RRR			;jz RecReturn
  5887 00001F5E 3C29                    	cmp al,')'
  5888 00001F60 7474                    	jz short RRet2
  5889 00001F62 3C3D                    	cmp al,'='			;end of task?
  5890 00001F64 7476                    RRR:	jz short RecReturn
  5891 00001F66 3C21                    	cmp al,'!'			;white space?
  5892 00001F68 72EF                    	jb short RecConti
  5893 00001F6A 803D[E83C0100]00        	cmp byte[signctl],0		;last was opcode?
  5894 00001F71 7516                    	jnz short CheckNP		;sign is allowed after opcode only
  5895 00001F73 3C2B                    	cmp al,'+'
  5896 00001F75 740A                    	jz short rPlus
  5897 00001F77 3C2D                    	cmp al,'-'
  5898 00001F79 750E                    	jnz short CheckNP
  5899 00001F7B FE05[E83C0100]          	inc byte[signctl]		;2 for minus 
  5900 00001F81 FE05[E83C0100]          rPlus:	inc byte[signctl]		;1 for plus
  5901 00001F87 EBD0                    	jmp short RecConti		;continue
  5902                                  
  5903 00001F89 FF35[E83C0100]          CheckNP:push dword [signctl]		;we need that for numbers and parenthesis
  5904 00001F8F 3C28                    	cmp al,'('
  5905 00001F91 750D                    	jnz short CheckNum
  5906 00001F93 FF05[B43C0100]          	inc dword[ptlevel]		;increase nesting level
  5907 00001F99 E8B1FFFFFF              	call Recurs0			;compute term instead of parse number
  5908 00001F9E EB15                    	jmp short fromP
  5909 00001FA0 3C30                    CheckNum:cmp al,'0'
  5910 00001FA2 724E                    	jb short noNumber
  5911 00001FA4 3C72                    	cmp al,'r'			;last Result
  5912 00001FA6 7436                    	jz short isLastRes
  5913 00001FA8 3C70                    	cmp al,'p'			;pi 3.141593
  5914 00001FAA 743A                    	jz short isPi
  5915 00001FAC 3C39                    	cmp al,'9'
  5916 00001FAE 7740                    	ja short isErr2
  5917 00001FB0 E86F000000              	call Number
  5918 00001FB5 58                      fromP:	pop eax				;signctl on stack
  5919 00001FB6 3C02                    	cmp al,2
  5920 00001FB8 7502                    	jnz short isPlus
  5921 00001FBA D9E0                    	FCHS				;parenthesis or number is negative
  5922 00001FBC C605[E83C0100]01        isPlus:	mov byte[signctl],1		;last token was a number (or parenthesis)
  5923 00001FC3 8A0424                  	mov al,[esp]			;our opcode
  5924 00001FC6 3C2B                    	cmp al,'+'
  5925 00001FC8 748F                    	jz short RecConti
  5926 00001FCA 3C2D                    	cmp al,'-'
  5927 00001FCC 750E                    	jnz short RecReturn
  5928 00001FCE C604242B                	mov byte[esp],'+'		;adding negative value
  5929 00001FD2 D9E0                    	FCHS
  5930 00001FD4 EB83                    RecCon2:jmp short RecConti
  5931                                  ;-------
  5932 00001FD6 FF0D[B43C0100]          RRet2:	dec dword[ptlevel]
  5933 00001FDC 58                      RecReturn:pop eax
  5934 00001FDD C3                      	ret
  5935                                  ;-------
  5936 00001FDE DD05[C83C0100]          isLastRes:fld qword[lastresult87]
  5937 00001FE4 EB02                    	jmp short isPi2
  5938 00001FE6 D9EB                    isPi:	fldpi
  5939 00001FE8 FF05[B03C0100]          isPi2:	inc dword[level]
  5940 00001FEE EBC5                    	jmp short fromP
  5941 00001FF0 EB46                    isErr2:	jmp short isErr
  5942                                  ;-------
  5943 00001FF2 59                      noNumber:pop ecx			;due above "push dword [signctl]" (we don't need it here)
  5944 00001FF3 8D6424F0                	lea esp,[esp-16]
  5945 00001FF7 D91C24                  	fstp dword [esp]
  5946 00001FFA E852FFFFFF              	call RecursPars
  5947 00001FFF D90424                  	fld dword [esp]
  5948 00002002 8D642410                	lea esp,[esp+16]
  5949 00002006 FF0D[B03C0100]          	dec dword[level]
  5950 0000200C 3C2A                    	cmp al,'*'
  5951 0000200E 7504                    	jnz noMul
  5952 00002010 DEC9                    	FMULP st1
  5953 00002012 EBC0                    	jmp short RecCon2
  5954 00002014 3C2F                    noMul:	cmp al,'/'
  5955 00002016 7504                    	jnz noDiv
  5956 00002018 DEF1                    	FDIVRP st1
  5957 0000201A EBB8                    	jmp short RecCon2
  5958 0000201C 3C2B                    noDiv:	cmp al,'+'
  5959 0000201E 7518                    	jnz isErr			;not one of * / +
  5960 00002020 DEC1                    	FADDP st1
  5961 00002022 EBB8                    	jmp short RecReturn
  5962                                  ;-------
  5963 00002024 D9EE                    Number:	FLDZ
  5964 00002026 DF35[BC3C0100]          	FBSTP [x87]			;init buffer
  5965 0000202C 6A0C                    	push byte 12			;read 13 chars  (up to 12 digits)
  5966 0000202E 59                      	pop ecx
  5967 0000202F E885000000              num_ctr:call DigitHlp
  5968 00002034 7215                    	jc int_end
  5969 00002036 E2F7                    	loop num_ctr			;error if >12 digits
  5970                                  isErr:	
  5971 00002038 8B25[B83C0100]          	mov esp,[stackptr]		;restore stack pos for math calc
  5972                                  %endif ;USE_MATH
  5973                                  %ifdef BEEP_IN_VI
  5974                                  VIBeepForD:PUSH_ALL
  5975                              <1> VIBeepForD:
  5976 0000203E 60                  <1>  pusha
  5977                                  %ifdef W32
  5978                                  	push byte 0
  5979                                  	call MessageBeep
  5980                                  %else
  5981 0000203F B9[F8250000]            	mov ecx,BeepChar
  5982 00002044 E88AFBFFFF              	call WriteFile00
  5983                                  %endif
  5984                                  	POP_ALL
  5985 00002049 61                  <1>  popa
  5986                                  %endif
  5987 0000204A C3                      	ret
  5988                                  ;-------
  5989                                  %ifdef USE_MATH
  5990 0000204B 57                      int_end:push edi			;****
  5991 0000204C F7D9                    	neg ecx
  5992 0000204E 8D490D                  	lea ecx,[ecx+13]
  5993 00002051 51                      	push ecx			;stor # of integer digits
  5994 00002052 FF05[B03C0100]          	inc dword[level]
  5995 00002058 4E                      	dec esi				;num_ctr loop has read 1 too much
  5996 00002059 89F2                    	mov edx,esi			;position we have read so far
  5997 0000205B 3CFE                    	cmp al,('.'-'0')
  5998 0000205D 7529                    	jnz integers
  5999 0000205F 46                      	inc esi
  6000 00002060 8D3D[BE3C0100]          	lea edi,[x87+2]			;start of decimal places
  6001 00002066 B103                    	mov cl,3			;6/2 decimal places
  6002 00002068 FC                      dec_ctr:cld
  6003 00002069 E84B000000              	call DigitHlp
  6004 0000206E 7215                    	jc decend
  6005 00002070 C0E004                  	shl al,4
  6006 00002073 88C3                    	mov bl,al
  6007 00002075 8807                    	mov [edi],al			;important if abort at digit 1,3,5
  6008 00002077 E83D000000              	call DigitHlp
  6009 0000207C 7207                    	jc decend	
  6010 0000207E 00D8                    	add al,bl
  6011 00002080 FD                      	std
  6012 00002081 AA                      	stosb
  6013 00002082 E2E4                    	loop dec_ctr			;if >6 decimal places it will run into error later
  6014 00002084 46                      	inc esi
  6015 00002085 4E                      decend:	dec esi
  6016 00002086 87D6                    	xchg edx,esi			;edx where later to continue scanning
  6017                                  ;-------
  6018 00002088 59                      integers:pop ecx			;ecx # of integer digits
  6019 00002089 4E                      	dec esi				;esi where integer places are
  6020 0000208A 8D3D[BF3C0100]          	lea edi,[x87+3]			;start of integer part
  6021 00002090 FD                      intloop:std
  6022 00002091 AC                      	lodsb
  6023 00002092 2C30                    	sub al,'0'
  6024 00002094 88C3                    	mov bl,al
  6025 00002096 49                      	dec ecx
  6026 00002097 E308                    	jecxz h2
  6027 00002099 AC                      	lodsb
  6028 0000209A 2C30                    	sub al,'0'
  6029 0000209C C0E004                  	shl al,4
  6030 0000209F 00D8                    	add al,bl
  6031 000020A1 FC                      h2:	cld
  6032 000020A2 AA                      	stosb
  6033 000020A3 E302                    	jecxz h3
  6034 000020A5 E2E9                    	loop intloop
  6035 000020A7 DF25[BC3C0100]          h3:	FBLD [x87]
  6036 000020AD DD05[71220000]          	FLD qword [factor]
  6037 000020B3 DEF9                    	fdivp st1
  6038 000020B5 89D6                    	mov esi,edx			;pointer for continued reading
  6039 000020B7 5F                      	pop edi				;****
  6040 000020B8 C3                      	ret
  6041                                  ;-------
  6042 000020B9 AC                      DigitHlp:lodsb
  6043 000020BA 2C30                    	sub al,'0'
  6044 000020BC 7203                    	jb dret
  6045 000020BE 3C0A                    	cmp al,10
  6046 000020C0 F5                      	cmc
  6047 000020C1 C3                      dret:	ret				;return: al=value / cy if error
  6048                                  ;-------
  6049 000020C2 38F0                    OutNumber:cmp al,dh			;flag set?
  6050 000020C4 7410                    	jz OCret
  6051 000020C6 0430                    	add al,'0'
  6052 000020C8 B6FF                    	mov dh,0xff			;set flag
  6053 000020CA 56                      OutChar:push esi
  6054 000020CB 52                      	push edx
  6055 000020CC 51                      	push ecx
  6056 000020CD E8B2E0FFFF              	call NormChar
  6057 000020D2 59                      	pop ecx
  6058 000020D3 5A                      	pop edx
  6059 000020D4 5E                      	pop esi
  6060 000020D5 43                      	inc ebx
  6061                                  %endif
  6062 000020D6 C3                      OCret:	ret
  6063                                  ;----------------------------------------------------------------------
  6064                                  %ifdef USE_UNDO
  6065                                  %define ROLLBACK
  6066                                  %undef ROLLBACK
  6067                                  ; Undo is organized in frames on a ringbuffer stack
  6068                                  ;
  6069                                  ; FRAME_AAAAprevFRAME_BBBBprevCURRENT_EMPTY_FRAME
  6070                                  ; ^         v   ^          v  v
  6071                                  ; |         |   |          |  |
  6072                                  ;  \-------/     \--------/|  |
  6073                                  ;                          |  v
  6074                                  ;                          v  [undoptr] == next free frame
  6075                                  ;                          [undoptr]-4  == begin of previous frame
  6076                                  ;
  6077                                  ; there are 3 types of frames: DELETE,INSERT,OVERWRITE, see details below:
  6078                                  ;
  6079                                  DataForUndoDelete:
  6080                                  ;
  6081                                  ; Data collector for "delete" by PUSHING undo data into a frame on the undo stack,
  6082                                  ; growing to higher addresses, using a variable size (16+X byte) data structure:
  6083                                  ; 
  6084                                  ; |12345679|--WHERE-|--SIZE--|<data>....X       |PREV-PTR|--NEXT--| ......
  6085                                  ; |  =sign |  =edi  |  =eax  |                  |        |        |
  6086                                  ; |        |        |        |                  |        |        |
  6087                                  ; | edx+0  | edx+4  | edx+8  | edx+12           |edx+16+X|edx+20+X| <----- ADDRESSES
  6088                                  ;                                                         ^^^^^^^^
  6089                                  ;                                                         NEXT_undo_frame_address stored in [undoptr]
  6090                                  ; If the data size is > undobuffer size we have to 
  6091                                  ; save the data otherwise, i.e. in a file:
  6092                                  ; |1234567B|--WHERE-|--SIZE--|<PREV-PTR|--NEXT--| ......
  6093                                  ; |  =sign |  =edi  |  =eax  |         |        |
  6094                                  ; |        |        |        |         |        |
  6095                                  ; | edx+0  | edx+4  | edx+8  | edx+12  |edx+16  | <----- ADDRESSES
  6096                                  ;
  6097 000020D7 803D[E02E0000]01        	cmp byte [enter_undo],1		;do not collect undo data if within undo operation
  6098 000020DE 74F6                    	jz OCret
  6099 000020E0 3DE8FF0000              	cmp eax,undobuffer_size-24
  6100                                  	PUSH_ALL
  6101 000020E5 60                  <1>  pusha
  6102 000020E6 7249                    	jb DFok
  6103                                  ;-------
  6104                                  	PUSH_ALL
  6105 000020E8 60                  <1>  pusha
  6106 000020E9 8B1D[E42E0000]          	mov ebx,[last_undo_file]
  6107 000020EF 09DB                    	or ebx,ebx
  6108 000020F1 740E                    	jz noundo_info
  6109 000020F3 813B7B563412            	cmp dword [ebx],0x01234567B
  6110 000020F9 7506                    	jnz noundo_info
  6111 000020FB C70300000000            	mov dword [ebx],0		;only ONE external undo info allowed, thus destroy older
  6112 00002101 BE[ED3C0100]            noundo_info:mov esi,sot			;i.e. huge undo data
  6113 00002106 892D[1C2F0100]          	mov [blockende],ebp
  6114 0000210C BB[79220000]            	mov ebx,tempfile2
  6115 00002111 E8EBF5FFFF              	call SaveBl3
  6116                                  	POP_ALL
  6117 00002116 61                  <1>  popa
  6118                                  ;-------
  6119 00002117 E82E010000              	call InitUndoFrame0
  6120 0000211C C7027B563412            	mov dword [edx],0x01234567B	;2nd signature for "delete"
  6121 00002122 8915[E42E0000]          	mov [last_undo_file],edx
  6122 00002128 89E8                    	mov eax,ebp
  6123 0000212A 2D[ED3C0100]            	sub eax,sot			;ebp -sot == size of buffer
  6124 0000212F EB5A                    	jmp short OVWdata
  6125                                  ;-------	
  6126                                  DFok:					;i.e. small undo data
  6127 00002131 89C1                    	mov ecx,eax			;extra data size / size of copy
  6128 00002133 E814010000              	call InitUndoFrame
  6129 00002138 C70279563412            	mov dword [edx],0x012345679	;signature for "delete", later undo will insert data again
  6130 0000213E 897A04                  	mov [edx+4],edi			;where
  6131 00002141 894208                  	mov [edx+8],eax			;how much
  6132 00002144 89FE                    	mov esi,edi			;source is inside editor text buffer
  6133 00002146 8D7A0C                  	lea edi,[edx+12]		;destination of copy
  6134 00002149 FC                      	cld
  6135 0000214A F3A4                    	rep movsb
  6136 0000214C A1[E82E0000]            	mov eax,[undoptr]		;this frame...
  6137 00002151 8907                    	mov [edi],eax			;... is the prev frame for the next one
  6138 00002153 8D4704                  	lea eax,[edi+4]			;eax: now the new frame address
  6139 00002156 EB3F                    	jmp short DFex
  6140                                  ;-------
  6141                                  DataForUndoOverwrite:
  6142                                  ;
  6143                                  ; Data collector for "overwrite" by PUSHING data on a stack, 
  6144                                  ; growing to higher addresses, using a data structure like in DataForUndoInsert
  6145                                  ;
  6146                                  	PUSH_ALL
  6147 00002158 60                  <1>  pusha
  6148 00002159 E8EC000000              	call InitUndoFrame0
  6149 0000215E C7027A563412            	mov dword [edx],0x01234567A	;signature for "overwrite", later undo will restore
  6150 00002164 8B07                    	mov eax,[edi]			;fetch overwritten char
  6151 00002166 EB23                    	jmp short OVWdata
  6152                                  DataForUndoXchange:
  6153                                  ;
  6154                                  ; Data collector for "Emacs ^T" by PUSHING data on a stack, 
  6155                                  ; growing to higher addresses, using a data structure like in DataForUndoOverWrite
  6156                                  ;
  6157                                  	PUSH_ALL
  6158 00002168 60                  <1>  pusha
  6159 00002169 E8DC000000              	call InitUndoFrame0
  6160 0000216E C70277563412            	mov dword [edx],0x012345677	;signature for "xchg", later undo will restore
  6161 00002174 EB15                    	jmp short OVWdata
  6162                                  ;------
  6163                                  DataForUndoInsert:
  6164                                  ;
  6165                                  ; Data collector for "insert" by PUSHING data on a stack,
  6166                                  ; growing to higher addresses, using a fixed size (16 byte) data structure:
  6167                                  ; 
  6168                                  ; |12345678|--WHERE-|--SIZE--|PREV-PTR|--NEXT--| .........
  6169                                  ; |  =sign |  =edi  |  =eax  |        |        |     
  6170                                  ; |        |        |        |        |        |
  6171                                  ; | edx+0  | edx+4  | edx+8  | edx+12 |edx+16  |edx+20  <----- ADDRESSES
  6172                                  ;                                      ^^^^^^^^
  6173                                  ;                                      NEXT_undo_frame_address stored in [undoptr]
  6174                                  ;
  6175                                  ; An analogue data structure is used for DataForUndoOverwrite:
  6176                                  ; |1234567A|--WHERE-|--CHAR--|PREV-PTR|--NEXT--| .........
  6177                                  ;
  6178                                  ;
  6179 00002176 803D[E02E0000]01        	cmp byte [enter_undo],1		;do not collect undo data if within undo operation
  6180 0000217D 741E                    	jz DFUI
  6181                                  	PUSH_ALL
  6182 0000217F 60                  <1>  pusha
  6183 00002180 E8C5000000              	call InitUndoFrame0
  6184 00002185 C70278563412            	mov dword [edx],0x012345678	;signature for "insert", later undo will delete that data
  6185 0000218B 897A04                  OVWdata:mov [edx+4],edi			;where
  6186 0000218E 894208                  	mov [edx+8],eax			;how much chars (or the character itself)
  6187 00002191 89520C                  	mov [edx+12],edx		;this frame is the prev frame for the next one
  6188 00002194 8D4210                  	lea eax,[edx+16]		;address of next frame
  6189 00002197 A3[E82E0000]            DFex:	mov [undoptr],eax		;let undoptr point to next frame 
  6190                                  	POP_ALL
  6191 0000219C 61                  <1>  popa
  6192 0000219D C3                      DFUI:	ret
  6193                                  ;----------------------------------------------------------------------
  6194                                  ;
  6195                                  ; this subroutine is bound to one of the keys like ^KU and
  6196                                  ; will POP any UNDO data from the undo stack using 3 types of undo frames
  6197                                  ;
  6198 0000219E C605[E02E0000]01        KeyUndo:mov byte [enter_undo],1		;do not log dele/insert when in undo mode
  6199 000021A5 89FB                    	mov ebx,edi			;for case of error
  6200 000021A7 8B15[E82E0000]          	mov edx,[undoptr]
  6201 000021AD 8B52FC                  	mov edx,[edx-4]			;get begin of previos frame
  6202 000021B0 09D2                    	or edx,edx
  6203 000021B2 741E                    	jz NotAv			;no date available
  6204 000021B4 31C9                    	xor ecx,ecx			;read signature into ecx and destroy sign
  6205 000021B6 870A                    	xchg ecx,[edx]			;(destroying is neccessary because it's a ring buffer)
  6206 000021B8 8B4208                  	mov eax,[edx+8]			;data size or character itself
  6207 000021BB 8B7A04                  	mov edi,[edx+4]			;position
  6208 000021BE 81E977563412            	sub ecx,0x12345677
  6209 000021C4 7410                    	jz UndoOfXchange
  6210 000021C6 49                      	dec ecx
  6211 000021C7 742B                    	jz UndoOfInsert
  6212 000021C9 49                      	dec ecx
  6213 000021CA 7413                    	jz UndoOfDelete
  6214 000021CC 49                      	dec ecx
  6215 000021CD 7421                    	jz UndoOfOverwrite
  6216 000021CF 49                      	dec ecx
  6217 000021D0 7429                    	jz ReReadBuffer
  6218 000021D2 89DF                    NotAv:	mov edi,ebx			;abort UNDO: no valid signature found
  6219                                  %ifdef ROLLBACK
  6220                                  	xor edx,edx
  6221                                  %endif
  6222 000021D4 EB68                    	jmp short KUret
  6223                                  ;-------
  6224 000021D6 8A07                    UndoOfXchange:mov al,byte [edi]
  6225 000021D8 8647FF                  	xchg byte [edi-1],al
  6226 000021DB 8807                    	mov byte [edi],al
  6227 000021DD EB50                    	jmp short KUexit
  6228                                  ;-------
  6229 000021DF 8D720C                  UndoOfDelete:lea esi,[edx+12]		;source ptr for deleted <data>
  6230 000021E2 56                      	push esi
  6231 000021E3 E8BBF1FFFF              	call InsertByte			;get some space.....
  6232 000021E8 5E                      	pop esi				;source ptr (somewhere inside UNDO frame)
  6233 000021E9 E872F2FFFF              	call MoveBlock			;....and move <data> back into text
  6234 000021EE EB3F                    	jmp short KUexit
  6235                                  ;-------
  6236 000021F0 8807                    UndoOfOverwrite:mov byte [edi],al
  6237 000021F2 EB3B                    	jmp short KUexit
  6238                                  ;-------
  6239 000021F4 E87DF1FFFF              UndoOfInsert:call DeleteByte
  6240 000021F9 EB34                    	jmp short KUexit
  6241                                  ;-------
  6242 000021FB 8DA8[ED3C0100]          ReReadBuffer:lea ebp,[eax+sot]		;compute eof pointer
  6243 00002201 C645000A                	mov byte [ebp],NEWLINE		;eof-marker
  6244 00002205 50                      	push eax			;size
  6245 00002206 BB[79220000]            	mov ebx,tempfile2
  6246 0000220B E8CDF9FFFF              	call OpenFile0
  6247 00002210 5A                      	pop edx				;size
  6248 00002211 781C                    	js KUexit
  6249 00002213 93                      	xchg ebx,eax			;file handle
  6250 00002214 B9[ED3C0100]            	mov ecx,sot
  6251 00002219 E8B1F9FFFF              	call Read_File
  6252 0000221E 780F                    	js KUexit
  6253 00002220 E8BEF9FFFF              	call CloseFile
  6254 00002225 BB[79220000]            	mov ebx,tempfile2
  6255 0000222A E824FAFFFF              	call Unlink
  6256                                  ;-------
  6257 0000222F 8B15[E82E0000]          KUexit:	mov edx,[undoptr]		;switch to undo frame before (i.e. POP)
  6258 00002235 8B52FC                  	mov edx,[edx-4]			;the prev frame....
  6259 00002238 8915[E82E0000]          	mov [undoptr],edx		;...is now current frame
  6260 0000223E C605[E02E0000]00        KUret:	mov byte [enter_undo],0		;leave UNDO status
  6261 00002245 E97AEEFFFF              KUjmp:	jmp CheckENum			;renumbering because we have changed the cursor position
  6262                                  ;-------
  6263                                  %ifdef ROLLBACK
  6264                                  RollBack:call KeyUndo
  6265                                  	or edx,edx
  6266                                  	jnz RollBack
  6267                                  	jmp short KUjmp	
  6268                                  %endif
  6269                                  ;----------------------------------------------------------------------
  6270                                  ;
  6271                                  ; This inits the frame data pointer into edx.
  6272                                  ; If there is not enough space we will wrap around to buffer begin and adjust [undoptr]:
  6273                                  ;
  6274                                  ;BEFORE WRAP:
  6275                                  ;|******any_frame**********any_frame********any_frame*******PREV-PTR---------------| buffer_end
  6276                                  ;                                                                   <---too less--->
  6277                                  ;                                                                   ^^^^^^^^^
  6278                                  ;                                                                   [undoptr]
  6279                                  ;NOW AFTER WRAP:
  6280                                  ;|PREV-PTR<-space_for_new_frame->ame********any_frame*******PREV-PTR---------------| buffer_end
  6281                                  ;         ^^^^^^^^               ^^^^^^^^^^ ^^^^^^^^^         
  6282                                  ;        [undoptr]               invalid     last ok frame
  6283                                  ;                               frame part
  6284                                  ;
  6285 0000224A 31C9                    InitUndoFrame0:xor ecx,ecx		;no extra data
  6286 0000224C 8B15[E82E0000]          InitUndoFrame:mov edx,[undoptr]		;get current frame
  6287 00002252 BE[D42E0100]            	mov esi,undobuffer_end-24
  6288 00002257 29CE                    	sub esi,ecx			;extra data if exist
  6289 00002259 39F2                    	cmp edx,esi			;low memory?
  6290 0000225B 7213                    	jb IUFret			;leave if far away from buffer end 
  6291                                  ;-------
  6292 0000225D 8B5AFC                  	mov ebx,[edx-4]			;fetch PREV-PTR frame address @[undoptr-4]
  6293 00002260 BA[EC2E0000]            	mov edx,undobuffer		;wrap around: now BACK AT BUFFER BEGIN...
  6294 00002265 891A                    	mov [edx],ebx			;store prev data frame pointer just before new frame
  6295 00002267 8D5204                  	lea edx,[edx+4]			;=new frame begins here at undobuffer+4
  6296 0000226A 8915[E82E0000]          	mov [undoptr],edx
  6297 00002270 C3                      IUFret:	ret
  6298                                  %endif
  6299                                  %ifdef UTF8RTS
  6300                                  KeyUTF8switch:not byte [isUTF8]
  6301                                  	ret
  6302                                  %endif
  6303                                  ;----------------------------------------------------------------------
  6304                                  %ifdef LINUX
  6305                                  %ifndef CRIPLED_ELF
  6306                                  section .data
  6307                                  bits 32
  6308                                  %endif
  6309                                  %endif
  6310                                  ;
  6311                                  ; CONSTANT DATA AREA
  6312                                  ;
  6313                                  %ifdef USE_MATH
  6314 00002271 0000000080842E41        factor		dq 1000000.0
  6315                                  %endif
  6316 00002279 6533232300              tempfile2 	db 'e3##',0		;tempfile (FIXME: use PID for name)
  6317                                  %ifdef USE_PIPE
  6318 0000227E 6533242400              tempfile 	db 'e3$$',0		;tempfile (FIXME: use PID for name)
  6319                                  %ifdef USE_EX_NO_SED
  6320                                  %ifndef AMD64
  6321                                  exargs		dd expath
  6322                                  		dd minus_s
  6323                                  		dd tempfile
  6324                                  		dd 0
  6325                                  %else
  6326                                  exargs		dq expath
  6327                                  		dq minus_s
  6328                                  		dq tempfile
  6329                                  		dq 0
  6330                                  %endif
  6331                                  expath		db EX_PATH,0
  6332                                  minus_s		db '-s',0
  6333                                  wq_suffix	db LINEFEED,'wq',LINEFEED
  6334                                  wq_suffix_len	equ $-wq_suffix
  6335                                  %else
  6336                                  %ifndef AMD64
  6337 00002283 [97220000]              sedargs		dd sedpath		;this way default
  6338 00002287 [A0220000]              		dd minus_e
  6339 0000228B [C8350100]              		dd optbuffer
  6340 0000228F [7E220000]              		dd tempfile
  6341 00002293 00000000                		dd 0
  6342                                  %else
  6343                                  sedargs		dq sedpath		;this way default
  6344                                  		dq minus_e
  6345                                  		dq optbuffer
  6346                                  		dq tempfile
  6347                                  		dq 0
  6348                                  %endif
  6349 00002297 2F62696E2F73656400      sedpath		db SEDPATH,0
  6350                                  %ifndef PERLPIPE
  6351 000022A0 2D6500                  minus_e		db '-e',0
  6352                                  %else
  6353                                  minus_e		db '-pe',0
  6354                                  %endif
  6355                                  ;
  6356                                  %endif
  6357                                  %endif
  6358                                  ;
  6359 000022A3 4F50543F20432F4200      optiontext	db 'OPT? C/B',0
  6360 000022AC 46494C454E414D453A-     filename	db 'FILENAME:',0
  6361 000022B5 00                 
  6362 000022B6 2020204E414D453A00      block		db '   NAME:',0
  6363 000022BF 534156452041533A00      saveas		db 'SAVE AS:',0
  6364 000022C8 202020534156453A00      filesave	db '   SAVE:',0
  6365 000022D1 534156453F20596E6C-     asksave		db 'SAVE? Ynl',0
  6366 000022DA 00                 
  6367 000022DB 534156453F20596E00      asksave2	db 'SAVE? Yn',0
  6368 000022E4 5245504C4143453A00      askreplace1	db 'REPLACE:',0
  6369 000022ED 524520574954483A00      askreplace2	db 'RE WITH:',0
  6370 000022F6 474F204C494E453A00      asklineno	db 'GO LINE:',0
  6371 000022FF 205345415243483A00      askfind		db ' SEARCH:',0
  6372 00002308 5E51204F4354414C3A-     asknumber	db '^Q OCTAL:',0
  6373 00002311 00                 
  6374 00002312 6D6F64652045583A00      extext		db 'mode EX:',0
  6375 0000231B 534554204D4F444500      modetxt		db 'SET MODE',0
  6376                                  %define DoNo 10
  6377                                  
  6378                                  ScanTable: 	;another xlat table containing offsets in jumptab1 table
  6379                                  %ifdef W32
  6380                                  	db 2	;VK_PRIOR  = Scan 21h (pgup)
  6381                                  	db 7	;VK_NEXT   = Scan 22h (pgdn)
  6382                                  	db 5	;(end)
  6383                                  	db 0	;(home)
  6384                                  	db 3	;(left)
  6385                                  	db 1	;(up)
  6386                                  	db 4	;(right)
  6387                                  	db 6	;(dn)
  6388                                  	db DoNo	;29h ignored 
  6389                                  	db DoNo	;2ah ditto
  6390                                  	db DoNo	;2bh ditto
  6391                                  	db DoNo	;2ch ditto
  6392                                  	db 8	;VK_INSERT = Scan 2dh (insert)
  6393                                  	db 9	;VK_DELETE = Scan 2eh (del)
  6394                                  %else
  6395 00002324 0A                      	db DoNo	;		esc[0~
  6396 00002325 00                      	db 0	;keyHome	esc[1~
  6397 00002326 08                      	db 8	;keyIns		esc[2~
  6398 00002327 09                      	db 9	;keyDel		esc[3~
  6399 00002328 05                      	db 5	;keyEnd		esc[4~
  6400 00002329 02                      	db 2	;keyPgUp	esc[5~
  6401 0000232A 07                      	db 7	;KeyPDn		esc[6~
  6402 0000232B 00                      	db 0	;keyHome	esc[7~
  6403 0000232C 05                      	db 5	;keyEnd		esc[8~
  6404                                  		;---------------------
  6405                                  %ifdef QNX
  6406                                  	db 8	;keyIns		esc[@
  6407                                  %endif
  6408 0000232D 01                      	db 1	;keyUp		esc[A
  6409 0000232E 06                      	db 6	;keyDown	esc[B
  6410 0000232F 04                      	db 4	;keyRight	esc[C
  6411 00002330 03                      	db 3	;keyLeft	esc[D
  6412 00002331 0A                      	db DoNo	;		esc[E
  6413 00002332 05                      	db 5	;keyEnd		esc[F
  6414 00002333 07                      	db 7	;keyPgDn	esc[G
  6415 00002334 00                      	db 0	;keyHome	esc[H
  6416                                  %ifndef LINUX
  6417                                  	db 2	;keyPUp		esc[I
  6418                                  	db DoNo	;		esc[J
  6419                                  	db DoNo	;		esc[K
  6420                                  	db 8	;keyIns		esc[L
  6421                                  %endif
  6422                                  %ifdef QNX
  6423                                  	db DoNo	;		esc[M
  6424                                  	db DoNo	;		esc[M
  6425                                  	db DoNo	;		esc[O
  6426                                  	db 9	;		esc[P
  6427                                  	db DoNo	;		esc[Q
  6428                                  	db DoNo	;		esc[R
  6429                                  	db DoNo	;		esc[S
  6430                                  	db DoNo	;		esc[T
  6431                                  	db 7	;		esc[U
  6432                                  	db 2	;		esc[V
  6433                                  	db DoNo	;		esc[W
  6434                                  	db DoNo	;		esc[X
  6435                                  	db 5	;		esc[Y
  6436                                  %endif
  6437                                  STsize equ ($-ScanTable)
  6438                                  %endif
  6439                                  ;----------------------------------------------------------------------
  6440                                  EmaAltTable: 	;another xlat table containing offsets in jumptab1 table
  6441 00002335 12                      	db 12h	;'B'
  6442 00002336 0A                      	db DoNo	;'C'
  6443 00002337 0A                      	db DoNo	;'D'
  6444 00002338 0A                      	db DoNo	;'E'
  6445 00002339 13                      	db 13h	;'F'
  6446 0000233A 11                      	db 11h	;'G'
  6447 0000233B 3D                      	db 3Dh	;'H'	Help!
  6448 0000233C 0A                      	db DoNo	;'I'
  6449 0000233D 0A                      	db DoNo	;'J'
  6450 0000233E 0A                      	db DoNo	;'K'
  6451 0000233F 0A                      	db DoNo	;'L'
  6452 00002340 0A                      	db DoNo	;'M'
  6453 00002341 0A                      	db DoNo	;'N'
  6454 00002342 0A                      	db DoNo	;'O'
  6455 00002343 0A                      	db DoNo	;'P'
  6456 00002344 0A                      	db DoNo	;'Q'
  6457 00002345 0A                      	db DoNo	;'R'
  6458 00002346 0A                      	db DoNo	;'S'
  6459 00002347 0A                      	db DoNo	;'T'
  6460 00002348 0A                      	db DoNo	;'U'
  6461 00002349 02                      	db 2 	;'V'
  6462 0000234A 27                      	db 27h	;'W'
  6463 0000234B 3E                      	db 3Eh	;'X'
  6464                                  ATsize equ ($-EmaAltTable)
  6465                                  ;----------------------------------------------------------------------
  6466                                  %define Beep 0x4E
  6467 0000234C 4E                      VIcmdTable:db Beep;0
  6468 0000234D 4E                      	db Beep	;1
  6469 0000234E 02                      	db 2	;^B PageUp
  6470 0000234F 4E                      	db Beep	;3
  6471 00002350 36                      	db 36h	;^D half PageUp
  6472 00002351 4E                      	db Beep	;5
  6473 00002352 07                      	db 7	;^F PageDn
  6474 00002353 4E                      	db Beep	;7
  6475 00002354 03                      	db 3	;^H KeyLeft
  6476 00002355 4E                      	db Beep	;9
  6477 00002356 06                      	db 6	;^J KeyDown
  6478 00002357 4E                      	db Beep	;11
  6479 00002358 4E                      	db Beep	;12
  6480 00002359 06                      	db 6	;^M KeyDown
  6481 0000235A 4E                      	db Beep	;^N
  6482 0000235B 4E                      	db Beep	;^O
  6483 0000235C 4E                      	db Beep	;^P
  6484 0000235D 4E                      	db Beep	;^Q
  6485 0000235E 4E                      	db Beep	;^R
  6486 0000235F 4E                      	db Beep	;^S
  6487 00002360 4E                      	db Beep	;^T
  6488 00002361 37                      	db 37h 	;^U
  6489 00002362 4E                      	db Beep	;22
  6490 00002363 4E                      	db Beep	;23
  6491 00002364 4E                      	db Beep	;24
  6492 00002365 4E                      	db Beep	;25
  6493 00002366 51                      	db 51h	;^Z
  6494 00002367 4E                      	db Beep	;27
  6495 00002368 4E                      	db Beep	;28
  6496 00002369 4E                      	db Beep	;29
  6497 0000236A 4E                      	db Beep	;30
  6498 0000236B 4E                      	db Beep	;31
  6499 0000236C 04                      	db 4	;' ' KeyRight
  6500 0000236D 4E                      	db Beep	;33
  6501 0000236E 4E                      	db Beep	;34
  6502 0000236F 4F                      	db 4fh 	;35  Numerics
  6503 00002370 05                      	db 5	;'$' KeyEnd
  6504 00002371 4E                      	db Beep	;37
  6505 00002372 4E                      	db Beep	;38
  6506 00002373 50                      	db 50h	; '
  6507 00002374 4E                      	db Beep	;40
  6508 00002375 4E                      	db Beep	;41
  6509 00002376 4E                      	db Beep	;42
  6510 00002377 06                      	db 6	;'+' KeyDown
  6511 00002378 4E                      	db Beep	;44
  6512 00002379 01                      	db 1	;'-' KeyUp
  6513 0000237A 4E                      	db Beep	;46
  6514 0000237B 39                      	db 39h	;'/' Search
  6515 0000237C 00                      	db 0	;'0' KeyHome
  6516 0000237D 44                      	db 44h	;'1' 1G BOF
  6517 0000237E 4E                      	db Beep	;'2'
  6518 0000237F 4E                      	db Beep	;'3'
  6519 00002380 4E                      	db Beep	;'4'
  6520 00002381 4E                      	db Beep	;'5'
  6521 00002382 4E                      	db Beep	;'6'
  6522 00002383 4E                      	db Beep	;'7'
  6523 00002384 4E                      	db Beep	;'8'
  6524 00002385 4E                      	db Beep	;'9'
  6525 00002386 2C                      	db 2Ch	;':' ex mode
  6526 00002387 3E                      	db 3Eh	;';' e3 special command: QUICK leave vi mode :-)  press  e3ws, e3em, e3pi, e3ne
  6527 00002388 4E                      	db Beep	;'<'
  6528 00002389 4E                      	db Beep	;'='
  6529 0000238A 4E                      	db Beep	;'>'
  6530 0000238B 3A                      	db 3Ah	;'?' search backw
  6531 0000238C 4E                      	db Beep	;'@'
  6532 0000238D 2E                      	db 2Eh	;'A'
  6533 0000238E 12                      	db 12h	;'B' left word
  6534 0000238F 4B                      	db 4Bh	;'C' Change rest of line 
  6535 00002390 4C                      	db 4Ch	;'D' Delete rest of line (not unlike ^QY in WStar)
  6536 00002391 4E                      	db Beep	;'E'
  6537 00002392 4E                      	db Beep	;'F'
  6538 00002393 0F                      	db 0Fh	;'G' EOF
  6539 00002394 30                      	db 30h	;'H' First LIne
  6540 00002395 33                      	db 33h	;'I' switch to insert mode
  6541 00002396 4D                      	db 4Dh	;'J' Join lines
  6542 00002397 4E                      	db Beep	;'K'
  6543 00002398 31                      	db 31h	;'L' Last Line
  6544 00002399 52                      	db 52h	;'M'
  6545 0000239A 4E                      	db Beep	;'N'
  6546 0000239B 32                      	db 32h	;'O' Open Line
  6547 0000239C 3C                      	db 3Ch	;'P' Paste
  6548 0000239D 4E                      	db Beep	;'Q'
  6549 0000239E 34                      	db 34h	;'R' overwrite
  6550 0000239F 40                      	db 40h	;'S' kill +insmode
  6551 000023A0 4E                      	db Beep	;'T'
  6552 000023A1 4E                      	db Beep	;'U'
  6553 000023A2 4E                      	db Beep	;'V'
  6554 000023A3 13                      	db 13h	;'W' next word
  6555 000023A4 3F                      	db 3fh	;'X' del left
  6556 000023A5 4E                      	db Beep	;'Y'
  6557 000023A6 41                      	db 41h	;'Z'
  6558 000023A7 4E                      	db Beep	;'['
  6559 000023A8 4E                      	db Beep	;'\'
  6560 000023A9 4E                      	db Beep	;']'
  6561 000023AA 38                      	db 38h	;'^' KeyFirstChar
  6562 000023AB 4E                      	db Beep	;'_'
  6563 000023AC 4E                      	db Beep	;'`'
  6564 000023AD 2D                      	db 2Dh	;'a' append (KeyLeft plus insert mode)
  6565 000023AE 12                      	db 12h	;'b' left word
  6566 000023AF 4E                      	db Beep	;'c'
  6567 000023B0 35                      	db 35h	;'d' delete
  6568 000023B1 43                      	db 43h	;'e'
  6569 000023B2 4E                      	db Beep	;'f'
  6570 000023B3 4E                      	db Beep	;'g'
  6571 000023B4 03                      	db 3	;'h' KeyLeft
  6572 000023B5 2B                      	db 2Bh	;'i' switch to insert mode
  6573 000023B6 06                      	db 6	;'j' KeyDown
  6574 000023B7 01                      	db 1	;'k' KeyUp
  6575 000023B8 04                      	db 4	;'l' KeyRight
  6576 000023B9 45                      	db 45h	;'m' set the one and only marker 'a'
  6577 000023BA 4E                      	db Beep	;'n'
  6578 000023BB 2F                      	db 2Fh	;'o' Open Line
  6579 000023BC 3B                      	db 3Bh	;'p' Paste
  6580 000023BD 4E                      	db Beep	;'q'
  6581 000023BE 4A                      	db 4Ah	;'r' repl one char
  6582 000023BF 4E                      	db Beep	;'s'
  6583 000023C0 4E                      	db Beep	;'t'
  6584                                  %ifdef USE_UNDO
  6585 000023C1 53                      	db 53h	;'u'	UNDO
  6586                                  %else
  6587                                  	db Beep	;'u'
  6588                                  %endif
  6589 000023C2 4E                      	db Beep	;'v'
  6590 000023C3 13                      	db 13h	;'w' next word
  6591 000023C4 09                      	db 9	;'x' KeyDel
  6592 000023C5 46                      	db 46h	;'y'
  6593 000023C6 42                      	db 42h	;'z' center line z.
  6594                                  VIsize equ ($-VIcmdTable)
  6595                                  ;----------------------------------------------------------------------
  6596 000023C7 0A                      Ktable	db DoNo	;^K@	xlatb table for making pseudo-scancode
  6597 000023C8 0A                      	db DoNo	;^ka
  6598 000023C9 24                      	db 24h	;^kb	24h for example points to KeyCtrlKB function offset
  6599 000023CA 15                      	db 15h	;^kc
  6600 000023CB 0D                      	db 0dh	;^kd
  6601 000023CC 0A                      	db DoNo	;^ke	DoNo means SimpleRet i.e. 'do nothing'
  6602 000023CD 0A                      	db DoNo	;^kf
  6603 000023CE 0A                      	db DoNo	;^kg
  6604 000023CF 1D                      	db 1dh	;^kh
  6605 000023D0 0A                      	db DoNo	;^ki
  6606 000023D1 0A                      	db DoNo	;^kj
  6607 000023D2 14                      	db 14h	;^kk
  6608 000023D3 0A                      	db DoNo	;^kl
  6609 000023D4 3E                      	db 3eh	;^km	Set Mode
  6610 000023D5 4F                      	db 4Fh	;^kn
  6611 000023D6 0A                      	db DoNo	;^ko
  6612 000023D7 48                      	db 48h 	;^kp    Pipe thru sed
  6613 000023D8 0B                      	db 0bh	;^kq
  6614 000023D9 10                      	db 10h	;^kr
  6615 000023DA 0C                      	db 0ch	;^ks
  6616 000023DB 0A                      	db DoNo	;^kt
  6617                                  %ifdef UTF8RTS
  6618                                  	db 54h	;^ku	^KU UTF8 view switcher
  6619                                  %else
  6620 000023DC 0A                      	db DoNo	;^ku
  6621                                  %endif
  6622 000023DD 23                      	db 23h	;^kv
  6623 000023DE 25                      	db 25h	;^kw
  6624 000023DF 16                      	db 16h	;^kx
  6625 000023E0 19                      	db 19h	;^ky
  6626 000023E1 51                      	db 51h	;^kz	^KZ suspend (like in joe editor)
  6627                                  Ktable_size equ $-Ktable
  6628 000023E2 0A                      Qtable	db DoNo	;^q@	ditto for ^Q menu
  6629 000023E3 1A                      	db 1ah	;^qa
  6630 000023E4 20                      	db 20h	;^qb
  6631 000023E5 0F                      	db 0fh	;^qc
  6632 000023E6 05                      	db 05h	;^qd
  6633 000023E7 1E                      	db 1eh	;^qe
  6634 000023E8 1B                      	db 1bh	;^qf
  6635 000023E9 0A                      	db DoNo	;^qg
  6636 000023EA 17                      	db 17h	;^qh, ^qDEL
  6637 000023EB 11                      	db 11h	;^qi
  6638 000023EC 0A                      	db DoNo	;^qj
  6639 000023ED 21                      	db 21h	;^qk
  6640 000023EE 0A                      	db DoNo	;^ql
  6641 000023EF 0A                      	db DoNo	;^qm
  6642 000023F0 0A                      	db DoNo	;^qn
  6643 000023F1 0A                      	db DoNo	;^qo
  6644 000023F2 18                      	db 18h	;^qp
  6645 000023F3 0A                      	db DoNo	;^qq
  6646 000023F4 0E                      	db 0eh	;^qr
  6647 000023F5 00                      	db 00h	;^qs
  6648 000023F6 0A                      	db DoNo	;^qt
  6649 000023F7 0A                      	db DoNo	;^qu
  6650 000023F8 1C                      	db 1ch	;^qv
  6651 000023F9 12                      	db 12h	;^qw
  6652 000023FA 1F                      	db 1fh	;^qx
  6653 000023FB 22                      	db 22h	;^qy
  6654 000023FC 13                      	db 13h	;^qz
  6655                                  ;----------------------------------------------------------------------
  6656 000023FD 0A                      Xtable	db DoNo	;^x^@
  6657 000023FE 0A                      	db DoNo	;^x^a
  6658 000023FF 0A                      	db DoNo	;^x^b
  6659 00002400 0B                      	db 0bh	;^x^c	WS: ^KQ
  6660 00002401 0A                      	db DoNo	;^x^d
  6661 00002402 0A                      	db DoNo	;^x^e
  6662 00002403 47                      	db 47h	;^x^f
  6663 00002404 0A                      	db DoNo	;^x^g
  6664 00002405 3D                      	db 3Dh	;^x^h   		i.e.  "HELP!" (The Beatles, 1965)  ;-)
  6665 00002406 10                      	db 10h	;^x i	WS: ^KR
  6666 00002407 0A                      	db DoNo	;^x^j
  6667 00002408 0A                      	db DoNo	;^x^k
  6668 00002409 0A                      	db DoNo	;^x^l
  6669 0000240A 0A                      	db DoNo	;^x^m
  6670 0000240B 4F                      	db 4fh	;^x^n   numerics
  6671 0000240C 0A                      	db DoNo	;^x^o
  6672 0000240D 48                      	db 48h	;^x^p   special sed pipe
  6673 0000240E 0A                      	db DoNo	;^x^q
  6674 0000240F 0A                      	db DoNo	;^x^r
  6675 00002410 0C                      	db 0ch	;^x^s	WS: ^KS
  6676 00002411 0A                       	db DoNo	;^x^t
  6677 00002412 0A                      	db DoNo	;^x^u
  6678 00002413 0A                      	db DoNo	;^x^v
  6679 00002414 29                      	db 29h	;^x^w	write to
  6680 00002415 26                      	db 26h	;^x^x	xchg mark/point
  6681 00002416 0A                      	db DoNo	;^x^y
  6682 00002417 0A                      	db DoNo	;^x^z
  6683                                  ;----------------------------------------------------------------------
  6684 00002418 0A                      PicoJtable db DoNo ;^j@	Junk ops for PI mode
  6685 00002419 0A                      	db DoNo	;^ja
  6686 0000241A 0A                      	db DoNo	;^jb
  6687 0000241B 0A                      	db DoNo	;^jc
  6688 0000241C 0A                      	db DoNo	;^jd
  6689 0000241D 0A                      	db DoNo	;^je
  6690 0000241E 0A                      	db DoNo	;^jf
  6691 0000241F 0A                      	db DoNo	;^jg
  6692 00002420 17                      	db 17h 	;^jh Junk to line Home
  6693 00002421 0A                      	db DoNo	;^ji
  6694 00002422 0A                      	db DoNo	;^jj
  6695 00002423 0A                      	db DoNo	;^jk
  6696 00002424 22                      	db 22h	;^jl Junk Line rest
  6697 00002425 0A                      	db DoNo	;^jm
  6698 00002426 0A                      	db DoNo	;^jn
  6699 00002427 0A                      	db DoNo	;^jo
  6700 00002428 48                      	db 48h	;^jp  special sed pipe
  6701 00002429 0A                      	db DoNo	;^jq
  6702 0000242A 0A                      	db DoNo	;^jr
  6703 0000242B 0A                      	db DoNo	;^js
  6704 0000242C 49                      	db 49h	;^jt repeat last search&replace
  6705 0000242D 0A                      	db DoNo	;^ju
  6706 0000242E 0A                      	db DoNo	;^jv
  6707 0000242F 2A                      	db 2Ah	;^jw Junk Word
  6708 00002430 0A                      	db DoNo	;^jx
  6709 00002431 0A                      	db DoNo	;^jy
  6710 00002432 0A                      	db DoNo	;^jz
  6711 00002433 0A                      PicoQtable db DoNo ;^q@	Quick motions for PI mode: wordstar counterparts on different keys
  6712 00002434 0A                      	db DoNo	;^qa
  6713 00002435 1F                      	db 1Fh	;^qb	Bottom of window
  6714 00002436 4F                      	db 4Fh	;^qc	Calc numerics
  6715 00002437 0A                      	db DoNo	;^qd
  6716 00002438 0F                      	db 0fh	;^qe	End of file
  6717 00002439 1C                      	db 1Ch	;^qf	last Find
  6718 0000243A 0A                      	db DoNo	;^qg
  6719 0000243B 0A                      	db DoNo	;^qh
  6720 0000243C 0A                      	db DoNo	;^qi
  6721 0000243D 0A                      	db DoNo	;^qj
  6722 0000243E 0A                      	db DoNo	;^qk
  6723 0000243F 11                      	db 11h	;^ql	Line number #
  6724 00002440 3E                      	db 3eh	;^qm	set mode
  6725 00002441 13                      	db 13h	;^qn	Next word
  6726 00002442 0A                      	db DoNo	;^qo
  6727 00002443 12                      	db 12h	;^qp	Previous word
  6728 00002444 0A                      	db DoNo	;^qq
  6729 00002445 0A                      	db DoNo	;^qr
  6730 00002446 0E                      	db 0Eh	;^qs	Start of file
  6731 00002447 1E                      	db 1Eh	;^qt	Top of window
  6732                                  %ifdef USE_UNDO
  6733 00002448 53                      	db 53h	;^qu	UNDO
  6734                                  %else
  6735                                  	db DoNo	;^qu
  6736                                  %endif
  6737                                  %ifdef UTF8RTS
  6738                                  	dw 54h	;^qv	UTF8 switcher
  6739                                  %else
  6740 00002449 0A                      	db DoNo	;^qv
  6741                                  %endif
  6742 0000244A 0A                      	db DoNo	;^qw
  6743 0000244B 0A                      	db DoNo	;^qx
  6744 0000244C 0A                      	db DoNo	;^qy
  6745 0000244D 0A                      	db DoNo	;^qz
  6746                                  ;----------------------------------------------------------------------
  6747                                  esize equ 2	;(byte per entry)
  6748                                  %ifdef ARMCPU
  6749                                  align 2
  6750                                  %endif
  6751                                  
  6752                                  jumptab1:	;Storing 16 bit offsets is valid only for code less size 64 kbyte...
  6753                                  		;  ... but in assembler that should never be a problem   ;)
  6754                                  %ifndef USE_EXT_MOVE
  6755 0000244E 2B03                    	dw KeyHome	-_start	;0
  6756                                  %else
  6757                                  	dw KeyHome2	-_start	;0
  6758                                  %endif
  6759 00002450 8D02                    	dw KeyUp	-_start	;1
  6760 00002452 CE02                    	dw KeyPgUp	-_start	;2
  6761 00002454 090A                    	dw KeyLeft	-_start	;3
  6762 00002456 D903                    	dw KeyRight	-_start	;4
  6763                                  %ifndef USE_EXT_MOVE
  6764 00002458 340A                    	dw KeyEnd	-_start	;5
  6765                                  %else
  6766                                  	dw KeyEnd2	-_start	;5
  6767                                  %endif
  6768 0000245A 7C02                    	dw KeyDown	-_start	;6
  6769 0000245C DA02                    	dw KeyPgDn	-_start	;7
  6770 0000245E 4503                    	dw KeyIns	-_start	;8
  6771 00002460 9403                    	dw KeyDel	-_start	;9	0..9 are Cursor pad keys
  6772                                  ;------------------------
  6773 00002462 7202                    	dw SimpleRet	-_start	;10 	DO_NOTHING == DoNo
  6774 00002464 5408                    	dw KeyCtrlKQ	-_start	;0bh EMA ^X^C
  6775 00002466 2F08                    	dw KeyCtrlKS	-_start	;0ch EMA ^X^S
  6776 00002468 4508                    	dw KeyCtrlKD	-_start	;0dh EMA ^X^F
  6777                                  %ifndef USE_EXT_MOVE
  6778 0000246A C405                    	dw KeyCtrlQR	-_start	;0eh EMA Alt<
  6779 0000246C B308                    	dw KeyCtrlQC	-_start	;0fh EMA Alt>
  6780                                  %else
  6781                                  	dw KeyCtrlQR2	-_start	;0eh EMA Alt<
  6782                                  	dw KeyCtrlQC2	-_start	;0fh EMA Alt>
  6783                                  %endif
  6784 0000246E A207                    	dw KeyCtrlKR	-_start	;10h EMA ^XI
  6785 00002470 EF05                    	dw KeyCtrlQI	-_start	;11h EMA Alt-G
  6786 00002472 1004                    	dw KeyCtrlQW	-_start	;12h EMA Alt-B
  6787 00002474 3104                    	dw KeyCtrlQZ	-_start	;13h EMA Alt-F
  6788                                  ;--------------------------
  6789                                  ;up to here this functions are considered common for all (exc vi)
  6790                                  ;Of course some use different key names.
  6791                                  ;
  6792                                  ;now follows special stuff for each editor emulation:
  6793                                  ;-------WS and Pico--------
  6794 00002476 FE06                    	dw KeyCtrlKK	-_start	;14h
  6795 00002478 0607                    	dw KeyCtrlKC	-_start	;15h
  6796 0000247A 8208                    	dw KeyCtrlKX	-_start	;16h
  6797 0000247C 0706                    	dw KeyCtrlQDel	-_start	;17h
  6798 0000247E CB05                    	dw KeyCtrlQP	-_start	;18h
  6799 00002480 D606                    	dw KeyCtrlKY	-_start	;19h
  6800 00002482 CE04                    	dw KeyCtrlQA	-_start	;1ah
  6801 00002484 2E05                    	dw KeyCtrlQF	-_start	;1bh
  6802 00002486 9604                    	dw KeyCtrlQV	-_start	;1ch
  6803 00002488 F606                    	dw KeyCtrlKH	-_start	;1dh
  6804 0000248A 7904                    	dw KeyCtrlQE	-_start	;1eh
  6805 0000248C 8504                    	dw KeyCtrlQX	-_start	;1fh
  6806 0000248E D905                    	dw KeyCtrlQB	-_start	;20h
  6807 00002490 E605                    	dw KeyCtrlQK	-_start	;21h
  6808 00002492 1C06                    	dw KeyCtrlQY	-_start	;22h
  6809 00002494 3007                    	dw KeyCtrlKV	-_start	;23h
  6810 00002496 5807                    	dw KeyCtrlKB	-_start	;24h
  6811 00002498 DA07                    	dw KeyCtrlKW	-_start	;25h
  6812                                  ;-------EM--------
  6813 0000249A 1A07                    	dw KeyCtrlXX	-_start	;26h
  6814 0000249C B814                    	dw KeyEmaAltW	-_start	;27h
  6815 0000249E BF04                    	dw KeyEmaAltPer	-_start ;28h Alt-%
  6816 000024A0 0F08                    	dw KeyEmaCtrlXW	-_start	;29h
  6817                                  ;-------PI--------
  6818 000024A2 6606                    	dw KeyCtrlT	-_start	;2Ah
  6819                                  ;-------VI--------
  6820 000024A4 E009                    	dw KeyVIcmdi	-_start	;2Bh
  6821 000024A6 450A                    	dw KeyVIex	-_start	;2Ch
  6822 000024A8 DB09                    	dw KeyVIcmda	-_start ;2Dh
  6823 000024AA D409                    	dw KeyVICmdA	-_start	;2Eh
  6824 000024AC C809                    	dw KeyVICmdo	-_start	;2Fh
  6825 000024AE 7904                    	dw KeyCtrlQE	-_start	;30h
  6826 000024B0 8504                    	dw KeyCtrlQX	-_start	;31h
  6827 000024B2 B709                    	dw KeyVICmdO	-_start	;32h
  6828 000024B4 6F09                    	dw KeyVICmdI	-_start	;33h
  6829 000024B6 AE09                    	dw KeyVICmdR	-_start ;34h
  6830 000024B8 2409                    	dw KeyVICmdd	-_start ;35h
  6831 000024BA AA02                    	dw KeyHalfPgDn	-_start ;36h
  6832 000024BC 9E02                    	dw KeyHalfPgUp	-_start ;37h
  6833 000024BE F508                    	dw KeyVI1Char	-_start ;38h
  6834 000024C0 AE04                    	dw KeyVIfsearch	-_start ;39h
  6835 000024C2 AA04                    	dw KeyVIbsearch	-_start ;3Ah
  6836 000024C4 7609                    	dw KeyVICmdp	-_start ;3Bh
  6837 000024C6 8C09                    	dw KeyVICmdP	-_start ;3Ch
  6838                                  ;------- later added (mostly vi stuff) ------
  6839 000024C8 B211                    	dw KeyHelp	-_start ;3Dh	general
  6840 000024CA 9D1A                    	dw KeyEditMode	-_start ;3Eh	general
  6841 000024CC 8D03                    	dw KeyDell	-_start ;3Fh	vi
  6842 000024CE 1109                    	dw KeyVICmdS	-_start ;40h	vi	
  6843 000024D0 EB08                    	dw KeyVICmdZ	-_start ;41h	vi
  6844 000024D2 2212                    	dw KeyVICmdz	-_start ;42h	vi
  6845 000024D4 5B04                    	dw KeyVIcmde	-_start ;43h	vi
  6846 000024D6 AB05                    	dw KeyVIcmd1	-_start ;44h	vi
  6847 000024D8 6E07                    	dw KeyVICmdm	-_start ;45h	vi
  6848 000024DA 1414                    	dw KeyVICmdy	-_start ;46h	vi
  6849 000024DC E807                    	dw KeyEmaCtrlXF	-_start ;47h	emacs (extended ^KD from WS)
  6850                                  %ifdef USE_PIPE	
  6851 000024DE 0B1C                    	dw KeyCtrlKP	-_start ;48h    use sed-pipe in WS,Emacs,Pico
  6852                                  %else
  6853                                  	dw SimpleRet	-_start ;48h
  6854                                  %endif
  6855 000024E0 0605                    	dw KeyPiCtrlJT	-_start ;49h	Pico
  6856 000024E2 6301                    	dw KeyVICmdr	-_start ;4Ah	vi
  6857 000024E4 EB09                    	dw KeyVICmdC	-_start ;4Bh	vi
  6858 000024E6 1506                    	dw KeyVICmdD	-_start ;4Ch	vi
  6859 000024E8 8603                    	dw KeyVICmdJ	-_start ;4Dh	vi
  6860                                  %ifdef BEEP_IN_VI
  6861 000024EA D01F                    	dw VIBeepForD	-_start ;4Eh	vi
  6862                                  %else
  6863                                  	dw SimpleRet	-_start ;4Eh	vi
  6864                                  %endif
  6865 000024EC 021E                    	dw KeyCtrlKN	-_start ;4Fh	general
  6866 000024EE 8507                    	dw KeyVICmdJmpM -_start ;50h	vi
  6867                                  %ifdef SYS_kill
  6868 000024F0 E91B                    	dw KeySuspend	-_start ;51h	general
  6869                                  %else
  6870                                  	dw SimpleRet	-_start	;51h
  6871                                  %endif
  6872 000024F2 2C12                    	dw KeyVI_M	-_start ;52h	vi
  6873                                  %ifdef USE_UNDO
  6874 000024F4 3021                    	dw KeyUndo	-_start ;53h	general
  6875                                  %else
  6876                                  	dw SimpleRet	-_start	;53h
  6877                                  %endif
  6878                                  %ifdef UTF8RTS
  6879                                  	dw KeyUTF8switch-_start ;54h	general
  6880                                  %else
  6881 000024F6 7202                    	dw SimpleRet	-_start	;54h
  6882                                  %endif
  6883                                  jumps1 equ ($-jumptab1) / esize
  6884                                  ;--- 32 more for WS--------
  6885 000024F8 7202                    	dw SimpleRet	-_start	;^Space
  6886 000024FA 1004                    	dw KeyCtrlQW	-_start	;^a
  6887 000024FC 7202                    	dw SimpleRet	-_start	;^b  ;; TEST dw KeyUndo-_start
  6888 000024FE DA02                    	dw KeyPgDn	-_start	;^c
  6889 00002500 D903                    	dw KeyRight	-_start ;^d
  6890 00002502 8D02                    	dw KeyUp	-_start	;^e
  6891 00002504 3104                    	dw KeyCtrlQZ	-_start	;^f
  6892 00002506 9403                    	dw KeyDel	-_start	;^g 7
  6893 00002508 8D03                    	dw KeyDell	-_start	;^h 8   DEL (7fh is translated)
  6894 0000250A 1601                    	dw NormChar	-_start	;^i 9	(TAB)
  6895                                  %ifdef SELFTEST
  6896                                  	dw KeyRet	-_start	;^j 0ah
  6897                                  %else
  6898 0000250C B211                    	dw KeyHelp	-_start	;^j
  6899                                  %endif
  6900 0000250E 9101                    	dw CtrlKMenu	-_start	;^k b
  6901 00002510 9205                    	dw KeyCtrlL	-_start	;^l c
  6902 00002512 2A02                    	dw KeyRet	-_start	;^m 0dh
  6903 00002514 7202                    	dw SimpleRet	-_start	;^n e
  6904 00002516 7202                    	dw SimpleRet	-_start	;^o f
  6905 00002518 B211                    	dw KeyHelp	-_start	;^p 10	Help!
  6906 0000251A 9A01                    	dw CtrlQMenu	-_start	;^q 11
  6907 0000251C CE02                    	dw KeyPgUp	-_start	;^r 12
  6908 0000251E 090A                    	dw KeyLeft	-_start	;^s 13
  6909 00002520 6606                    	dw KeyCtrlT	-_start	;^t 14
  6910                                  %ifdef USE_UNDO
  6911 00002522 3021                    	dw KeyUndo	-_start	;^u 15 (abort in Input)
  6912                                  %else
  6913                                  	dw SimpleRet	-_start	;^u
  6914                                  %endif	
  6915 00002524 4503                    	dw KeyIns	-_start	;^v 16
  6916 00002526 B602                    	dw KeyScrollUp	-_start	;^w 17
  6917 00002528 7C02                    	dw KeyDown	-_start	;^x 18
  6918 0000252A 3906                    	dw KeyCtrlY	-_start	;^y 19
  6919 0000252C C202                    	dw KeyScrollDn	-_start ;1a
  6920 0000252E 7202                    	dw SimpleRet	-_start ;1b
  6921 00002530 7202                    	dw SimpleRet	-_start	;1c
  6922 00002532 7202                    	dw SimpleRet	-_start	;1d
  6923 00002534 7202                    	dw SimpleRet	-_start	;1e
  6924                                  %ifdef ROLLBACK	
  6925                                  	dw RollBack	-_start	;1f  for internal testing of UNDO ring buffer only
  6926                                  %else
  6927 00002536 7202                    	dw SimpleRet	-_start	;1f
  6928                                  %endif
  6929                                  ;--- 32 more for EM--------
  6930 00002538 9A07                    	dw KeyEmaMark	-_start	;^Space
  6931 0000253A 2B03                    	dw KeyHome	-_start	;^a
  6932 0000253C 090A                    	dw KeyLeft	-_start	;^b
  6933 0000253E 7202                    	dw SimpleRet	-_start	;^c (not planned)
  6934 00002540 9403                    	dw KeyDel	-_start ;^d
  6935 00002542 340A                    	dw KeyEnd	-_start	;^e
  6936 00002544 D903                    	dw KeyRight	-_start	;^f
  6937 00002546 7202                    	dw SimpleRet	-_start	;^g (abort in Input)
  6938 00002548 8D03                    	dw KeyDell	-_start	;^h
  6939 0000254A 1601                    	dw NormChar	-_start	;^i (TAB)
  6940 0000254C 2A02                    	dw KeyRet	-_start	;^j
  6941 0000254E 7206                    	dw KeyEmaCtrlK	-_start	;^k
  6942 00002550 4412                    	dw KeyEmaCtrlL	-_start	;^l
  6943 00002552 2602                    	dw KeyRetNoInd	-_start	;^m 0dh
  6944 00002554 7C02                    	dw KeyDown	-_start	;^n
  6945 00002556 6D04                    	dw KeyEmaCtrlO	-_start	;^o
  6946 00002558 8D02                    	dw KeyUp	-_start	;^p
  6947 0000255A 7C01                    	dw KeyEmaCtrlQ	-_start	;^q
  6948 0000255C 1005                    	dw KeyEmaCtrlR	-_start	;^r
  6949 0000255E 1405                    	dw KeyEmaCtrlS	-_start	;^s
  6950 00002560 D803                    	dw KeyEmaCtrlT	-_start	;^t
  6951                                  %ifdef UTF8RTS
  6952                                  	dw KeyUTF8switch-_start	;^u UTF8 mode switcher 
  6953                                  	; (ATTENZIONE: that is NOT emacs stuff like: 'C-u runs the command universal-argument')
  6954                                  %else
  6955 00002562 7202                    	dw SimpleRet	-_start	;^u
  6956                                  %endif
  6957 00002564 DA02                    	dw KeyPgDn	-_start	;^v
  6958 00002566 9C06                    	dw KeyEmaCtrlW	-_start	;^w
  6959 00002568 B301                    	dw CtrlXMenu	-_start	;^x
  6960 0000256A 4414                    	dw KeyEmaCtrlY	-_start	;^y
  6961                                  %ifdef SYS_kill
  6962 0000256C E91B                    	dw KeySuspend	-_start ;^z
  6963                                  %else
  6964                                  	dw SimpleRet	-_start	;51h
  6965                                  %endif
  6966 0000256E 7202                    	dw SimpleRet	-_start ;1b
  6967 00002570 7202                    	dw SimpleRet	-_start	;1c
  6968 00002572 7202                    	dw SimpleRet	-_start	;1d
  6969 00002574 7202                    	dw SimpleRet	-_start	;1e
  6970                                  %ifdef USE_UNDO
  6971 00002576 3021                    	dw KeyUndo	-_start ;1f
  6972                                  %else
  6973                                  	dw SimpleRet	-_start	;1f
  6974                                  %endif
  6975                                  ;--- 32 more for PI------
  6976 00002578 9A07                    	dw KeyEmaMark	-_start	;^Space	a redundant marker because ^^ is ugly on some kbds
  6977 0000257A 2B03                    	dw KeyHome	-_start	;^a 1
  6978 0000257C 090A                    	dw KeyLeft	-_start	;^b 2
  6979 0000257E 7202                    	dw SimpleRet	-_start	;^c 3
  6980 00002580 9403                    	dw KeyDel	-_start ;^d 4
  6981 00002582 340A                    	dw KeyEnd	-_start	;^e 5
  6982 00002584 D903                    	dw KeyRight	-_start	;^f 6
  6983 00002586 B211                    	dw KeyHelp	-_start	;^g 7
  6984 00002588 8D03                    	dw KeyDell	-_start	;^h 8   DEL
  6985 0000258A 1601                    	dw NormChar	-_start	;^i 9	(TAB)
  6986 0000258C A101                    	dw PicoJMenu	-_start	;^j a
  6987 0000258E 9C06                    	dw KeyEmaCtrlW	-_start	;^k b
  6988 00002590 9A07                    	dw KeyEmaMark	-_start	;^l c	a redundant marker because ^^ is ugly on some kbds
  6989 00002592 2A02                    	dw KeyRet	-_start	;^m d
  6990 00002594 7C02                    	dw KeyDown	-_start	;^n e
  6991 00002596 2F08                    	dw KeyCtrlKS	-_start	;^o f	SAVE
  6992 00002598 8D02                    	dw KeyUp	-_start	;^p 10
  6993 0000259A AA01                    	dw PicoQMenu	-_start	;^q 11
  6994 0000259C A207                    	dw KeyCtrlKR	-_start	;^r 12
  6995 0000259E 0F08                    	dw KeyEmaCtrlXW	-_start	;^s 13	SAVE_AS
  6996 000025A0 B904                    	dw PicoCtrlTpico-_start	;^t 14
  6997 000025A2 4414                    	dw KeyEmaCtrlY	-_start	;^u 15
  6998 000025A4 DA02                    	dw KeyPgDn	-_start	;^v 16
  6999 000025A6 1405                    	dw KeyEmaCtrlS	-_start	;^w 17
  7000 000025A8 5408                    	dw KeyCtrlKQ	-_start	;^x 18
  7001 000025AA CE02                    	dw KeyPgUp	-_start	;^y 19
  7002                                  %ifdef SYS_kill	
  7003 000025AC E91B                    	dw KeySuspend	-_start ;^z 1A  (not in pico)
  7004                                  %else
  7005                                  	dw SimpleRet	-_start	;^z
  7006                                  %endif
  7007 000025AE 7202                    	dw SimpleRet	-_start	;^[ 1B
  7008 000025B0 7202                    	dw SimpleRet	-_start	;^\ 1C
  7009 000025B2 7202                    	dw SimpleRet	-_start	;^] 1D
  7010 000025B4 9A07                    	dw KeyEmaMark	-_start	;^^ 1E	see ^L
  7011 000025B6 7202                    	dw SimpleRet	-_start ;1F
  7012                                  ;--- 32 more for NE------
  7013 000025B8 9A07                    	dw KeyEmaMark	-_start	;^Space toggle selection mode (no shift cursor keys available!)
  7014 000025BA B905                    	dw KeyNedCtrlA	-_start	;^a 1   Mark all
  7015 000025BC 4503                    	dw KeyIns	-_start	;^b 2   toggle Ins mode
  7016 000025BE B814                    	dw KeyEmaAltW	-_start	;^c 3	COPY
  7017 000025C0 7202                    	dw SimpleRet	-_start ;^d 4
  7018 000025C2 9D1A                    	dw KeyEditMode	-_start	;^e 5   set EDit mode
  7019 000025C4 2E05                    	dw KeyCtrlQF	-_start	;^f 6   find
  7020 000025C6 9205                    	dw KeyCtrlL	-_start	;^g 7   find again
  7021 000025C8 8D03                    	dw KeyDell	-_start	;^h 8   DEL
  7022 000025CA 1601                    	dw NormChar	-_start	;^i 9	TAB
  7023 000025CC 2A02                    	dw KeyRet	-_start	;^j a   RETURN
  7024 000025CE 021E                    	dw KeyCtrlKN	-_start	;^k b   numerics
  7025 000025D0 EF05                    	dw KeyCtrlQI	-_start	;^l c   LINE #
  7026 000025D2 2A02                    	dw KeyRet	-_start	;^m d   RETURN
  7027 000025D4 E807                    	dw KeyEmaCtrlXF	-_start	;^n e	OPEN another
  7028 000025D6 E807                    	dw KeyEmaCtrlXF	-_start	;^o f   OPEN another
  7029 000025D8 7202                    	dw SimpleRet	-_start	;^p 10
  7030 000025DA 5408                    	dw KeyCtrlKQ	-_start	;^q 11  EXIT
  7031 000025DC CE04                    	dw KeyCtrlQA	-_start	;^r 12  REPLACE
  7032 000025DE 2F08                    	dw KeyCtrlKS	-_start	;^s 13	SAVE
  7033 000025E0 7202                    	dw SimpleRet	-_start	;^t 14
  7034                                  %ifdef USE_UNDO
  7035 000025E2 3021                    	dw KeyUndo	-_start ;^u 15	UNDO
  7036                                  %else
  7037                                  	dw SimpleRet	-_start	;^u 15
  7038                                  %endif
  7039 000025E4 4414                    	dw KeyEmaCtrlY	-_start	;^v 16	PASTE
  7040 000025E6 0F08                    	dw KeyEmaCtrlXW	-_start	;^w 13	SAVE_AS/WRITE TO
  7041 000025E8 9C06                    	dw KeyEmaCtrlW	-_start	;^x 18	CUT
  7042                                  %ifdef UTF8RTS
  7043                                  	dw KeyUTF8switch-_start	;^y 19
  7044                                  %else
  7045 000025EA 7202                    	dw SimpleRet	-_start	;^y 19
  7046                                  %endif
  7047                                  %ifdef SYS_kill
  7048 000025EC E91B                    	dw KeySuspend	-_start ;^z 1A
  7049                                  %else
  7050                                  	dw SimpleRet	-_start	;^z
  7051                                  %endif	
  7052 000025EE 7202                    	dw SimpleRet	-_start	;^[ 1B
  7053 000025F0 7202                    	dw SimpleRet	-_start	;^\ 1C
  7054 000025F2 7202                    	dw SimpleRet	-_start	;^] 1D
  7055 000025F4 7202                    	dw SimpleRet	-_start	;^^ 1E
  7056 000025F6 7202                    	dw SimpleRet	-_start ;1F
  7057                                  ;----------------------------------------------------------------------
  7058                                  ;
  7059                                  %ifdef W32
  7060                                   scolorslen	equ 0
  7061                                  %else
  7062 000025F8 07                       BeepChar	db 7
  7063 000025F9 1B5B34306D1B5B3337-      screencolors0	db 27,'[40m',27,'[37m'
  7064 00002602 6D                 
  7065 00002603 1B5B306D                 bold0		db 27,'[0m'		;reset to b/w
  7066 00002607 1B5B34346D1B5B3333-      screencolors1	db 27,'[44m',27,'[33m'	;yellow on blue
  7067 00002610 6D                 
  7068                                   reversevideoX:
  7069 00002611 1B5B316D                 bold1:		db 27,'[1m'		;bold
  7070                                   scolorslen	equ $-screencolors1
  7071                                   boldlen	equ $-bold1		;take care length of bold0 == length of bold1
  7072                                  %ifdef LINUX
  7073 00002615 1B5B376D                		db 27,'[7m'		;good for "linux" terminal on /dev/tty (but not xterm,kvt)
  7074                                  					;again take care length = length of boldX
  7075                                  					;!! important: store directly after bold1 !!
  7076                                  %ifdef NEW_CURSOR_MGNT
  7077 00002619 1B5B3F31373B303B36-      blockcurs	db 27,'[?17;0;64c'	;see e3.h
  7078 00002622 3463               
  7079                                   blockcurslen	equ $-blockcurs
  7080 00002624 1B5B3F3263               normcurs	db 27,'[?2c'
  7081                                   normcurslen	equ $-normcurs
  7082                                  %endif
  7083                                  %endif
  7084                                  %endif
  7085                                  %ifdef SELFTEST
  7086                                   pipein		db 'PIPE_IN',0
  7087                                  %endif
  7088                                  ;-------
  7089                                  %ifdef UTF8
  7090                                  %ifdef UTF8RTS
  7091                                   getPos		db 13, 0c3h, 0B6h,27,'[6n',13	;write carriage_return, followed by 1 UTF8 char
  7092                                   						;german umlaut oe = ö in UTF-8
  7093                                   gPlen		equ $-getPos			;and clean up with another carriage_return
  7094                                  						;Terminal should answer ESC[<line>;<column>R
  7095                                  %endif						;on UTF8 terminals should be column==2 else ==3
  7096                                  %endif
  7097                                  ;-------------------------------------------------------------------------
  7098                                  %ifdef ARMCPU
  7099                                  align 2
  7100                                  %endif
  7101 00002629 702057537020506970-     editmode:db 'p WSp Pip Emp NE'
  7102 00002632 20456D70204E45     
  7103                                  ;
  7104                                  helptext:
  7105 00002639 4D6963726F45646974-     db "MicroEditor e3 v2.7.1"
  7106 00002642 6F722065332076322E-
  7107 0000264B 372E31             
  7108                                  %ifndef NASM
  7109                                  db "Y"
  7110                                  %endif
  7111                                  %ifdef UTF8
  7112 0000264E 2D5554463820C2A9        db "-UTF8 ",0C2h,0A9h
  7113                                  %else
  7114                                  db " (C)"
  7115                                  %endif
  7116 00002656 323030302D30372041-     db "2000-07 A.Kleine",10
  7117 0000265F 2E4B6C65696E650A   
  7118 00002667 456E7465722066696C-     db "Enter filename or leave with RETURN",10,10
  7119 00002670 656E616D65206F7220-
  7120 00002679 6C6561766520776974-
  7121 00002682 682052455455524E0A-
  7122 0000268B 0A                 
  7123                                  %ifdef YASM
  7124                                  %ifdef UTF8
  7125                                  helptextsize equ 54h
  7126                                  %else
  7127                                  helptextsize equ 50h
  7128                                  %endif
  7129                                  %else
  7130                                  helptextsize equ $-helptext
  7131                                  %if helptextsize>127
  7132                                   %error helptextsize
  7133                                  %endif
  7134                                  %endif
  7135 0000268C 0A0A0A0909092D3D20-     helpfoot:db 10,10,10,TABCHAR,TABCHAR,TABCHAR,"-= PRESS ANY KEY =-" ;at least 6 wasted byte ;-)
  7136 00002695 505245535320414E59-
  7137 0000269E 204B4559203D2D     
  7138                                  %ifdef YASM
  7139                                  helpfootsize equ 19h
  7140                                  %else
  7141                                  helpfootsize equ $-helpfoot
  7142                                  %if helpfootsize>127
  7143                                   %error helpfootsize
  7144                                  %endif
  7145                                  %endif
  7146                                  ;
  7147                                  %ifdef USE_BUILTINHELP
  7148                                  help_ws:
  7149 000026A5 4B65792062696E6469-     db "Key bindings in WS mode:",10,10
  7150 000026AE 6E677320696E205753-
  7151 000026B7 206D6F64653A0A0A   
  7152 000026BF 46696C65733A095E4B-     db "Files:	^KR Insert	^KS Save	^KX Save&Exit	^KQ Abort&Exit",10
  7153 000026C8 5220496E7365727409-
  7154 000026D1 5E4B53205361766509-
  7155 000026DA 5E4B58205361766526-
  7156 000026E3 45786974095E4B5120-
  7157 000026EC 41626F727426457869-
  7158 000026F5 740A               
  7159                                  %ifndef USE_PIPE
  7160                                  db "	^KD Save&Load",10
  7161                                  %else
  7162                                  %ifdef USE_EX_NO_SED
  7163                                  db "	^KD Save&Load	^KP Pipe buffer thru 'ex' ",10
  7164                                  %else
  7165 000026F7 095E4B442053617665-     db "	^KD Save&Load	^KP Pipe buffer thru 'sed'",10
  7166 00002700 264C6F6164095E4B50-
  7167 00002709 205069706520627566-
  7168 00002712 666572207468727520-
  7169 0000271B 27736564270A       
  7170                                  %endif
  7171                                  %endif
  7172 00002721 0A                      db 10
  7173 00002722 426C6F636B733A095E-     db "Blocks:	^KB Start	^KK End		^KC Copy	^KY Del",10
  7174 0000272B 4B4220537461727409-
  7175 00002734 5E4B4B20456E640909-
  7176 0000273D 5E4B4320436F707909-
  7177 00002746 5E4B592044656C0A   
  7178 0000274E 095E4B56204D6F7665-     db "	^KV Move	^KW Write",10
  7179 00002757 095E4B572057726974-
  7180 00002760 650A               
  7181 00002762 0A                      db 10
  7182 00002763 5365617263683A095E-     db "Search:	^QF Find	^L  Repeat	^QA Srch&Repl",10
  7183 0000276C 51462046696E64095E-
  7184 00002775 4C2020526570656174-
  7185 0000277E 095E51412053726368-
  7186 00002787 265265706C0A       
  7187 0000278D 4D6F76653A095E4520-     db "Move:	^E  Up		^X  Down	^S  Left	^D  Right",10
  7188 00002796 20557009095E582020-
  7189 0000279F 446F776E095E532020-
  7190 000027A8 4C656674095E442020-
  7191 000027B1 52696768740A       
  7192 000027B7 095E52202050616765-     db "	^R  Page Up	^C  Page Dn	^W  Scroll Up	^Z  Scroll Dn",10
  7193 000027C0 205570095E43202050-
  7194 000027C9 61676520446E095E57-
  7195 000027D2 20205363726F6C6C20-
  7196 000027DB 5570095E5A20205363-
  7197 000027E4 726F6C6C20446E0A   
  7198 000027EC 517569636B2D095E51-     db "Quick-	^QE Wnd Top	^QX Wnd Bott	^QS Home	^QD End",10
  7199 000027F5 4520576E6420546F70-
  7200 000027FE 095E515820576E6420-
  7201 00002807 426F7474095E515320-
  7202 00002810 486F6D65095E514420-
  7203 00002819 456E640A           
  7204 0000281D 2D4D6F76653A095E51-     db "-Move:	^QR BOF		^QC EOF		^QB Blk Begin	^QK Blk End",10
  7205 00002826 5220424F4609095E51-
  7206 0000282F 4320454F4609095E51-
  7207 00002838 4220426C6B20426567-
  7208 00002841 696E095E514B20426C-
  7209 0000284A 6B20456E640A       
  7210 00002850 095E4620204E657874-     db "	^F  Next Word	^A  Prev Word	^QI Line#	^QV Last Find",10
  7211 00002859 20576F7264095E4120-
  7212 00002862 205072657620576F72-
  7213 0000286B 64095E5149204C696E-
  7214 00002874 6523095E5156204C61-
  7215 0000287D 73742046696E640A   
  7216 00002885 0A                      db 10
  7217 00002886 44656C6574653A095E-     db "Delete:	^T  Word	^Y  Line	^H  Left	^G  Chr",10
  7218 0000288F 542020576F7264095E-
  7219 00002898 5920204C696E65095E-
  7220 000028A1 4820204C656674095E-
  7221 000028AA 4720204368720A     
  7222 000028B1 095E5159204C696E65-     db "	^QY Line End	^QDel,^QH Line Beg",10
  7223 000028BA 20456E64095E514465-
  7224 000028C3 6C2C5E5148204C696E-
  7225 000028CC 65204265670A       
  7226                                  %ifdef USE_MATH
  7227 000028D2 4F746865723A095E4B-     db "Other:	^KM Set mode	^KN Numerics"
  7228 000028DB 4D20536574206D6F64-
  7229 000028E4 65095E4B4E204E756D-
  7230 000028ED 6572696373         
  7231                                  %else
  7232                                  db "Other:	^KM Set mode"
  7233                                  %endif
  7234                                  %ifdef SYS_kill
  7235 000028F2 095E4B5A2053757370-     db "	^KZ Suspend "
  7236 000028FB 656E6420           
  7237                                  %endif
  7238                                  %ifdef USE_UNDO
  7239 000028FF 095E552020556E646F      db "	^U  Undo"
  7240                                  %endif
  7241                                  %ifdef UTF8RTS
  7242                                  db 10,"	^KU UTF8"
  7243                                  %endif
  7244                                  help_ws_size equ $-help_ws
  7245                                  ;-------------------------
  7246                                  help_pi:
  7247 00002908 4B65792062696E6469-     db "Key bindings in PICO mode:",10,10
  7248 00002911 6E677320696E205049-
  7249 0000291A 434F206D6F64653A0A-
  7250 00002923 0A                 
  7251 00002924 46696C65733A095E58-     db "Files:	^XN ExitNoSave	^XY Exit+Save	^XL Save+Load New File",10
  7252 0000292D 4E20457869744E6F53-
  7253 00002936 617665095E58592045-
  7254 0000293F 7869742B5361766509-
  7255 00002948 5E584C20536176652B-
  7256 00002951 4C6F6164204E657720-
  7257 0000295A 46696C650A         
  7258 0000295F 095E4F202053617665-     db "	^O  Save	^S  Save as	^R  Read",10
  7259 00002968 095E53202053617665-
  7260 00002971 206173095E52202052-
  7261 0000297A 6561640A           
  7262 0000297E 0A                      db 10
  7263 0000297F 4D6F76653A095E5020-     db "Move:	^P  Up		^N  Down	^B  Left	^F  Right",10
  7264 00002988 20557009095E4E2020-
  7265 00002991 446F776E095E422020-
  7266 0000299A 4C656674095E462020-
  7267 000029A3 52696768740A       
  7268 000029A9 095E59202050616765-     db "	^Y  Page up	^V  Page down	^QN Next word	^QP Previous word",10
  7269 000029B2 207570095E56202050-
  7270 000029BB 61676520646F776E09-
  7271 000029C4 5E514E204E65787420-
  7272 000029CD 776F7264095E515020-
  7273 000029D6 50726576696F757320-
  7274 000029DF 776F72640A         
  7275 000029E4 095E412020486F6D65-     db "	^A  Home	^E  End		^QS Start	^QE EOF",10
  7276 000029ED 095E452020456E6409-
  7277 000029F6 095E51532053746172-
  7278 000029FF 74095E514520454F46-
  7279 00002A08 0A                 
  7280 00002A09 095E515420546F7020-     db "	^QT Top screen	^QB Bottom scr	^QL Line #	^QF last Find",10
  7281 00002A12 73637265656E095E51-
  7282 00002A1B 4220426F74746F6D20-
  7283 00002A24 736372095E514C204C-
  7284 00002A2D 696E652023095E5146-
  7285 00002A36 206C6173742046696E-
  7286 00002A3F 640A               
  7287 00002A41 0A                      db 10
  7288 00002A42 5365617263683A095E-     db "Search:	^W  Where is	^T  Search&Repl	^JT Repeat Search & Replace",10
  7289 00002A4B 572020576865726520-
  7290 00002A54 6973095E5420205365-
  7291 00002A5D 61726368265265706C-
  7292 00002A66 095E4A542052657065-
  7293 00002A6F 617420536561726368-
  7294 00002A78 2026205265706C6163-
  7295 00002A81 650A               
  7296 00002A83 0A                      db 10
  7297 00002A84 44656C6574653A095E-     db "Delete:	^H  Left char	^D  This char	^K  Kill line/region",10
  7298 00002A8D 4820204C6566742063-
  7299 00002A96 686172095E44202054-
  7300 00002A9F 686973206368617209-
  7301 00002AA8 5E4B20204B696C6C20-
  7302 00002AB1 6C696E652F72656769-
  7303 00002ABA 6F6E0A             
  7304 00002ABD 095E4A5720576F7264-     db "	^JW Word	^JL Line end	^JH Line begin",10
  7305 00002AC6 095E4A4C204C696E65-
  7306 00002ACF 20656E64095E4A4820-
  7307 00002AD8 4C696E652062656769-
  7308 00002AE1 6E0A               
  7309 00002AE3 0A                      db 10
  7310 00002AE4 4F746865723A095E55-     db "Other:	^U  Unkill	^G  Help	^^,^L,^<SPC> Mark region",10
  7311 00002AED 2020556E6B696C6C09-
  7312 00002AF6 5E47202048656C7009-
  7313 00002AFF 5E5E2C5E4C2C5E3C53-
  7314 00002B08 50433E204D61726B20-
  7315 00002B11 726567696F6E0A     
  7316                                  %ifndef USE_PIPE
  7317                                  db "	^QM Set Edit Mode ",10
  7318                                  %else
  7319                                  %ifdef USE_EX_NO_SED
  7320                                  db "	^QM Set Edit Mode		^JP Pipe buffer thru 'ex' ",10
  7321                                  %else
  7322 00002B18 095E514D2053657420-     db "	^QM Set Edit Mode		^JP Pipe buffer thru 'sed'",10
  7323 00002B21 45646974204D6F6465-
  7324 00002B2A 09095E4A5020506970-
  7325 00002B33 652062756666657220-
  7326 00002B3C 746872752027736564-
  7327 00002B45 270A               
  7328                                  %endif
  7329                                  %endif
  7330                                  %ifdef USE_MATH
  7331 00002B47 095E51432043616C63-     db "	^QC Calculate"
  7332 00002B50 756C617465         
  7333                                  %else
  7334                                  db " "
  7335                                  %endif
  7336                                  %ifdef SYS_kill
  7337 00002B55 0909095E5A20537573-     db "			^Z Suspend"
  7338 00002B5E 70656E64           
  7339                                  %endif
  7340                                  %ifdef USE_UNDO
  7341 00002B62 095E515520556E646F      db "	^QU Undo"
  7342                                  %endif
  7343                                  %ifdef UTF8RTS
  7344                                  db 10,"	^QV UTF8"
  7345                                  %endif
  7346                                  help_pi_size equ $-help_pi
  7347                                  ;-------------------------
  7348                                  help_em:
  7349 00002B6B 4B65792062696E6469-     db "Key bindings in EMACS mode:",10,10
  7350 00002B74 6E677320696E20454D-
  7351 00002B7D 414353206D6F64653A-
  7352 00002B86 0A0A               
  7353 00002B88 46696C65733A095E58-     db "Files:	^X^C Exit	^XI  Insert	^X^S Save	^X^F Load New",10
  7354 00002B91 5E432045786974095E-
  7355 00002B9A 58492020496E736572-
  7356 00002BA3 74095E585E53205361-
  7357 00002BAC 7665095E585E46204C-
  7358 00002BB5 6F6164204E65770A   
  7359                                  %ifndef USE_PIPE
  7360                                  db "	^X^W Write new	^X^H Help ",10
  7361                                  %else
  7362                                  %ifdef USE_EX_NO_SED
  7363                                  db "	^X^W Write new	^X^H Help	^X^P Pipe buffer thru 'ex' ",10
  7364                                  %else
  7365 00002BBD 095E585E5720577269-     db "	^X^W Write new	^X^H Help	^X^P Pipe buffer thru 'sed'",10
  7366 00002BC6 7465206E6577095E58-
  7367 00002BCF 5E482048656C70095E-
  7368 00002BD8 585E50205069706520-
  7369 00002BE1 627566666572207468-
  7370 00002BEA 72752027736564270A 
  7371                                  %endif
  7372                                  %endif
  7373 00002BF3 0A                      db 10
  7374 00002BF4 4D6F76653A095E5020-     db "Move:	^P   Up		^N  Down	^B   Left	^F   Right",10
  7375 00002BFD 2020557009095E4E20-
  7376 00002C06 20446F776E095E4220-
  7377 00002C0F 20204C656674095E46-
  7378 00002C18 20202052696768740A 
  7379 00002C21 09616C745620506720-     db "	altV Pg up	^V  Pg down	altB Left word	altF Right word",10
  7380 00002C2A 7570095E5620205067-
  7381 00002C33 20646F776E09616C74-
  7382 00002C3C 42204C65667420776F-
  7383 00002C45 726409616C74462052-
  7384 00002C4E 6967687420776F7264-
  7385 00002C57 0A                 
  7386 00002C58 095E41202020486F6D-     db "	^A   Home	^E  End		alt< BOF	alt> EOF",10
  7387 00002C61 65095E452020456E64-
  7388 00002C6A 0909616C743C20424F-
  7389 00002C73 4609616C743E20454F-
  7390 00002C7C 460A               
  7391 00002C7E 09616C744720476F20-     db "	altG Go line#	^L  Center Pos",10
  7392 00002C87 6C696E6523095E4C20-
  7393 00002C90 2043656E7465722050-
  7394 00002C99 6F730A             
  7395 00002C9C 0A                      db 10
  7396 00002C9D 5365617263683A095E-     db "Search:	^S Find fwd	^R Find bwd	alt% Search&Replace like WS",10
  7397 00002CA6 532046696E64206677-
  7398 00002CAF 64095E522046696E64-
  7399 00002CB8 2062776409616C7425-
  7400 00002CC1 205365617263682652-
  7401 00002CCA 65706C616365206C69-
  7402 00002CD3 6B652057530A       
  7403 00002CD9 0A                      db 10
  7404 00002CDA 4275666665723A0961-     db "Buffer:	altW Copy	^Y Yank		^<SPC> Mark	^X^X Xchg Mark/Pt",10
  7405 00002CE3 6C745720436F707909-
  7406 00002CEC 5E592059616E6B0909-
  7407 00002CF5 5E3C5350433E204D61-
  7408 00002CFE 726B095E585E582058-
  7409 00002D07 636867204D61726B2F-
  7410 00002D10 50740A             
  7411 00002D13 0A                      db 10
  7412 00002D14 44656C6574653A095E-     db "Delete:	^K Line		^W Region	^H Left	Chr	^D This Chr",10
  7413 00002D1D 4B204C696E6509095E-
  7414 00002D26 5720526567696F6E09-
  7415 00002D2F 5E48204C6566740943-
  7416 00002D38 6872095E4420546869-
  7417 00002D41 73204368720A       
  7418 00002D47 0A                      db 10
  7419                                  %ifdef UTF8
  7420                                  ; FIXME: ^T
  7421 00002D48 4F746865723A095E4F-     db "Other:	^O Open line	           	^I Ins Tab	^Q Quoted Ins",10
  7422 00002D51 204F70656E206C696E-
  7423 00002D5A 650920202020202020-
  7424 00002D63 20202020095E492049-
  7425 00002D6C 6E7320546162095E51-
  7426 00002D75 2051756F7465642049-
  7427 00002D7E 6E730A             
  7428                                  %else
  7429                                  db "Other:	^O Open line	^T Xchg Chr	^I Ins Tab	^Q Quoted Ins",10
  7430                                  %endif
  7431 00002D81 095E4D204E4C09095E-     db "	^M NL		^J NL+indent	altX Set edit mode",10
  7432 00002D8A 4A204E4C2B696E6465-
  7433 00002D93 6E7409616C74582053-
  7434 00002D9C 65742065646974206D-
  7435 00002DA5 6F64650A           
  7436                                  %ifdef USE_MATH
  7437 00002DA9 095E585E4E2043616C-     db "	^X^N Calculate"
  7438 00002DB2 63756C617465       
  7439                                  %else
  7440                                  db "		"
  7441                                  %endif
  7442                                  %ifdef SYS_kill
  7443 00002DB8 0909095E5A20537573-     db "			^Z Suspend"
  7444 00002DC1 70656E64           
  7445                                  %endif
  7446                                  %ifdef USE_UNDO
  7447 00002DC5 095E5F2020556E646F      db "	^_  Undo"
  7448                                  %endif
  7449                                  %ifdef UTF8RTS
  7450                                  db 10,"	^U UTF-8"
  7451                                  %endif
  7452                                  help_em_size equ $-help_em
  7453                                  ;-------------------------
  7454                                  help_vi:
  7455 00002DCE 4B65792062696E6469-     db "Key bindings in vi mode:",10
  7456 00002DD7 6E677320696E207669-
  7457 00002DE0 206D6F64653A0A     
  7458 00002DE7 0A                      db 10
  7459 00002DE8 3C4553433E09090965-     db "<ESC>			enter cmd mode",10
  7460 00002DF1 6E74657220636D6420-
  7461 00002DFA 6D6F64650A         
  7462 00002DFF 682C6A2C6B2C6C2C2B-     db "h,j,k,l,+,-,<Ret>,<SPC>	move by chars&lines",10
  7463 00002E08 2C2D2C3C5265743E2C-
  7464 00002E11 3C5350433E096D6F76-
  7465 00002E1A 652062792063686172-
  7466 00002E23 73266C696E65730A   
  7467 00002E2B 5E422C5E462C5E442C-     db "^B,^F,^D,^U		move by [half]page",10
  7468 00002E34 5E5509096D6F766520-
  7469 00002E3D 6279205B68616C665D-
  7470 00002E46 706167650A         
  7471 00002E4B 242C302C5E2C772C62-     db "$,0,^,w,b,e,H,L,M,z.	move in line/screen",10
  7472 00002E54 2C652C482C4C2C4D2C-
  7473 00002E5D 7A2E096D6F76652069-
  7474 00002E66 6E206C696E652F7363-
  7475 00002E6F 7265656E0A         
  7476 00002E74 2F2C3F2C4709090973-     db "/,?,G			srch fwd/bwd, go EOF",10
  7477 00002E7D 726368206677642F62-
  7478 00002E86 77642C20676F20454F-
  7479 00002E8F 460A               
  7480 00002E91 6D612C276109090973-     db "ma,'a			set/go marker a",10
  7481 00002E9A 65742F676F206D6172-
  7482 00002EA3 6B657220610A       
  7483 00002EA9 782C582C3C44656C3E-     db "x,X,<Del>,dw,D		dele chr,word,EOL",10
  7484 00002EB2 2C64772C4409096465-
  7485 00002EBB 6C65206368722C776F-
  7486 00002EC4 72642C454F4C0A     
  7487 00002ECB 532C432C64642C6427-     db "S,C,dd,d'a,yy,y'a	subst,change,dele,yank",10
  7488 00002ED4 612C79792C79276109-
  7489 00002EDD 73756273742C636861-
  7490 00002EE6 6E67652C64656C652C-
  7491 00002EEF 79616E6B0A         
  7492 00002EF4 702C50090909706173-     db "p,P			paste",10
  7493 00002EFD 74650A             
  7494 00002F00 412C612C492C692C3C-     db "A,a,I,i,<Ins>,O,o	enter ins.mode",10
  7495 00002F09 496E733E2C4F2C6F09-
  7496 00002F12 656E74657220696E73-
  7497 00002F1B 2E6D6F64650A       
  7498 00002F21 522C72090909656E74-     db "R,r			enter ovw.mode,ovw.chr",10
  7499 00002F2A 6572206F76772E6D6F-
  7500 00002F33 64652C6F76772E6368-
  7501 00002F3C 720A               
  7502 00002F3E 4A0909096A6F696E20-     db "J			join lines",10
  7503 00002F47 6C696E65730A       
  7504                                  %ifdef USE_UNDO
  7505                                   %ifdef SYS_kill
  7506 00002F4D 5A5A2C5E5A2C207509-       db "ZZ,^Z, u		save&quit,suspend, undo!",10
  7507 00002F56 097361766526717569-
  7508 00002F5F 742C73757370656E64-
  7509 00002F68 2C20756E646F210A   
  7510                                   %else
  7511                                    db "ZZ, u		save&ex, undo!",10
  7512                                   %endif
  7513                                  %else
  7514                                   %ifdef SYS_kill
  7515                                    db "ZZ,^Z			save&quit,suspend",10
  7516                                   %else
  7517                                    db "ZZ			save&ex",10
  7518                                   %endif
  7519                                  %endif
  7520                                  %ifdef USE_MATH
  7521 00002F70 3B2C23090909453320-     db ";,#			E3 SPECIAL: set edit mode,calculate",10
  7522 00002F79 5350454349414C3A20-
  7523 00002F82 736574206564697420-
  7524 00002F8B 6D6F64652C63616C63-
  7525 00002F94 756C6174650A       
  7526                                  %else
  7527                                  db ";			E3 SPECIAL:set edit mode",10
  7528                                  %endif
  7529 00002F9A 3A772C3A77712C3A78-     db ":w,:wq,:x,:q,:q!,:e	ex mode:save,quit,save_as,edit other",10
  7530 00002FA3 2C3A712C3A71212C3A-
  7531 00002FAC 65096578206D6F6465-
  7532 00002FB5 3A736176652C717569-
  7533 00002FBE 742C736176655F6173-
  7534 00002FC7 2C65646974206F7468-
  7535 00002FD0 65720A             
  7536 00002FD3 3A302C3A242C3A3C6C-     db ":0,:$,:<line#>		ex mode:go BOF,EOF,line",10
  7537 00002FDC 696E65233E09096578-
  7538 00002FE5 206D6F64653A676F20-
  7539 00002FEE 424F462C454F462C6C-
  7540 00002FF7 696E650A           
  7541                                  %ifdef UTF8RTS
  7542                                  db ":h,:u			ex mode:help, UTF-8",10
  7543                                  %else
  7544 00002FFB 3A680909096578206D-     db ":h			ex mode:help",10
  7545 00003004 6F64653A68656C700A 
  7546                                  %endif
  7547                                  %ifndef USE_PIPE
  7548                                  db "         "
  7549                                  %else
  7550                                  %ifdef USE_EX_NO_SED
  7551                                  db ":<other cmd>		pipe buffer thru 'ex' "
  7552                                  %else
  7553 0000300D 3A3C6F746865722063-     db ":<other cmd>		pipe buffer thru 'sed'"
  7554 00003016 6D643E090970697065-
  7555 0000301F 206275666665722074-
  7556 00003028 687275202773656427 
  7557                                  %endif
  7558                                  %endif
  7559                                  help_vi_size equ $-help_vi
  7560                                  ;-------------------------
  7561                                  help_ne:
  7562 00003031 4B65792062696E6469-     db "Key bindings in NEDIT mode:",10
  7563 0000303A 6E677320696E204E45-
  7564 00003043 444954206D6F64653A-
  7565 0000304C 0A                 
  7566 0000304D 0A                      db 10
  7567 0000304E 46696C65733A09095E-     db "Files:		^QN Exit_NoSave	^QY Exit&Save	^QL Save&Load new",10
  7568 00003057 514E20457869745F4E-
  7569 00003060 6F53617665095E5159-
  7570 00003069 204578697426536176-
  7571 00003072 65095E514C20536176-
  7572 0000307B 65264C6F6164206E65-
  7573 00003084 770A               
  7574 00003086 09095E532020536176-     db "		^S  Save	^W  WriteTo=SaveAs",10
  7575 0000308F 65095E572020577269-
  7576 00003098 7465546F3D53617665-
  7577 000030A1 41730A             
  7578 000030A4 4D6F76653A09095E4C-     db "Move:		^L  Line#",10
  7579 000030AD 20204C696E65230A   
  7580 000030B5 09095E46202046696E-     db "		^F  Find	^R Search&Replace (like WS)",10
  7581 000030BE 64095E522053656172-
  7582 000030C7 6368265265706C6163-
  7583 000030D0 6520286C696B652057-
  7584 000030D9 53290A             
  7585 000030DC 09095E472020476F20-     db "		^G  Go repeat last ^F,^R",10
  7586 000030E5 726570656174206C61-
  7587 000030EE 7374205E462C5E520A 
  7588 000030F7 0A                      db 10
  7589 000030F8 53656C6563743A0909-     db "Select:		^<SPACE> begin&extend by cursor keys (like Emacs)",10
  7590 00003101 5E3C53504143453E20-
  7591 0000310A 626567696E26657874-
  7592 00003113 656E64206279206375-
  7593 0000311C 72736F72206B657973-
  7594 00003125 20286C696B6520456D-
  7595 0000312E 616373290A         
  7596 00003133 09095E412020416C6C-     db "		^A  All buffer",10
  7597 0000313C 206275666665720A   
  7598 00003144 09095E582020437574-     db "		^X  Cut		^C Copy 	^V Paste",10
  7599 0000314D 09095E4320436F7079-
  7600 00003156 20095E562050617374-
  7601 0000315F 650A               
  7602 00003161 0A                      db 10
  7603 00003162 4F746865723A09095E-     db "Other:		^E  Set edit mode",10
  7604 0000316B 452020536574206564-
  7605 00003174 6974206D6F64650A   
  7606                                  %ifdef UTF8RTS
  7607                                  db "		^Y  UTF8 view",10
  7608                                  %endif
  7609                                  %ifdef USE_MATH
  7610 0000317C 09095E4B202043616C-     db "		^K  Calculate",10
  7611 00003185 63756C6174650A     
  7612                                  %endif
  7613 0000318C 0909616C7448204865-     db "		altH Help"
  7614 00003195 6C70               
  7615                                  %ifdef SYS_kill
  7616 00003197 095E5A205375737065-     db "	^Z Suspend"
  7617 000031A0 6E64               
  7618                                  %endif
  7619                                  %ifdef USE_UNDO
  7620 000031A2 095E5520556E646F        db "	^U Undo"
  7621                                  %endif
  7622                                  help_ne_size equ $-help_ne
  7623                                  %ifndef YASM
  7624                                  %if help_ws_size != help_pi_size || help_ws_size!= help_em_size || help_ws_size!= help_pi_size || help_ws_size!= help_vi_size
  7625                                  %error Helptext
  7626                                  dw help_vi_size
  7627                                  dw help_ws_size
  7628                                  dw help_pi_size
  7629                                  dw help_em_size
  7630                                  %endif
  7631                                  %endif
  7632                                  %else					;no help texts built in
  7633                                  help_ws:
  7634                                  help_pi:
  7635                                  help_em:
  7636                                  help_vi:
  7637                                  help_ne:
  7638                                  db "This e3 is built w/o help texts."
  7639                                  help_ws_size equ $-help_ws
  7640                                  help_ne_size equ $-help_ws
  7641                                  %endif
  7642                                  ;
  7643                                  errmsgs:errortext 			;see e3.h
  7644                              <1> errmsgs:
  7645 000031AA 4F70206E6F74207065- <1> db "Op not permitted",10
  7646 000031B3 726D69747465640A    <1>
  7647 000031BB 4E6F20737563682066- <1> db "No such file|directory",10
  7648 000031C4 696C657C6469726563- <1>
  7649 000031CD 746F72790A          <1>
  7650 000031D2 0A                  <1> db 10
  7651 000031D3 0A                  <1> db 10
  7652 000031D4 496E7075742F6F7574- <1> db "Input/output",10
  7653 000031DD 7075740A            <1>
  7654 000031E1 4E6F20737563682064- <1> db "No such device",10
  7655 000031EA 65766963650A        <1>
  7656 000031F0 0A                  <1> db 10
  7657 000031F1 0A                  <1> db 10
  7658 000031F2 4261642066696C6520- <1> db "Bad file descriptor",10
  7659 000031FB 64657363726970746F- <1>
  7660 00003204 720A                <1>
  7661 00003206 4E6F206368696C6420- <1> db "No child processes",10
  7662 0000320F 70726F636573736573- <1>
  7663 00003218 0A                  <1>
  7664 00003219 0A                  <1> db 10
  7665 0000321A 4D656D6F7279206578- <1> db "Memory exhausted",10
  7666 00003223 686175737465640A    <1>
  7667 0000322B 5065726D697373696F- <1> db "Permission denied",10
  7668 00003234 6E2064656E6965640A  <1>
  7669 0000323D 0A                  <1> db 10
  7670 0000323E 0A                  <1> db 10
  7671 0000323F 4465766963657C7265- <1> db "Device|resource busy",10
  7672 00003248 736F75726365206275- <1>
  7673 00003251 73790A              <1>
  7674 00003254 46696C652065786973- <1> db "File exists",10
  7675 0000325D 74730A              <1>
  7676 00003260 0A                  <1> db 10
  7677 00003261 4E6F20737563682064- <1> db "No such device",10
  7678 0000326A 65766963650A        <1>
  7679 00003270 0A                  <1> db 10
  7680 00003271 497320612064697265- <1> db "Is a directory",10
  7681 0000327A 63746F72790A        <1>
  7682 00003280 496E76616C69642061- <1> db "Invalid argument",10
  7683 00003289 7267756D656E740A    <1>
  7684 00003291 546F6F206D616E7920- <1> db "Too many open files",10
  7685 0000329A 6F70656E2066696C65- <1>
  7686 000032A3 730A                <1>
  7687 000032A5 546F6F206D616E7920- <1> db "Too many open files",10
  7688 000032AE 6F70656E2066696C65- <1>
  7689 000032B7 730A                <1>
  7690 000032B9 496E617070726F7072- <1> db "Inappropriate ioctl",10
  7691 000032C2 6961746520696F6374- <1>
  7692 000032CB 6C0A                <1>
  7693 000032CD 546578742066696C65- <1> db "Text file busy",10
  7694 000032D6 20627573790A        <1>
  7695 000032DC 46696C6520746F6F20- <1> db "File too large",10
  7696 000032E5 6C617267650A        <1>
  7697 000032EB 4E6F20737061636520- <1> db "No space on device",10
  7698 000032F4 6F6E20646576696365- <1>
  7699 000032FD 0A                  <1>
  7700 000032FE 496C6C6567616C2073- <1> db "Illegal seek",10
  7701 00003307 65656B0A            <1>
  7702 0000330B 522F4F2066696C6520- <1> db "R/O file system",10
  7703 00003314 73797374656D0A      <1>
  7704 0000331B 43616E277420657865- <1> db "Can't exec "
  7705 00003324 6320                <1>
  7706                              <1> %ifdef USE_EX_NO_SED
  7707                              <1> db EX_PATH,10
  7708                              <1> %else
  7709 00003326 2F62696E2F7365640A  <1> db SEDPATH,10
  7710                              <1> %endif
  7711 0000332F 42726F6B656E207069- <1> db "Broken pipe",10
  7712 00003338 70650A              <1>
  7713                                  
  7714                                  ;-------
  7715                                  ;
  7716                                  %ifdef CRIPLED_ELF
  7717                                   filesize      equ     $ - $$
  7718                                  %endif
  7719                                  ;-----------------------------------------------------------------------
  7720                                  %ifdef ATHEOS
  7721                                  section .data				;unused in Linux/FreeBSD/BeOS: save byte in ELF header
  7722                                  bits 32					;unused in W32: save byte in PE header
  7723                                  %endif
  7724                                  ;-----------------------------------------------------------------------
  7725                                  %ifdef NETBSD				;added Sun Oct  9 10:10:00 CEST 2005 
  7726                                  section .note.netbsd.ident
  7727                                  align 4
  7728                                   dd 7
  7729                                   dd 4
  7730                                   dd 1
  7731                                   db "NetBSD",0,0
  7732                                   dd 0 
  7733                                  %endif 
  7734                                  ;-----------------------------------------------------------------------
  7735                                  %ifdef OPENBSD
  7736                                  section .note.openbsd.ident
  7737                                  align 4
  7738                                   dd 8
  7739                                   dd 4
  7740                                   dd 1
  7741                                   db "OpenBSD",0
  7742                                   dd 0 
  7743                                  %endif 
  7744                                  ;-----------------------------------------------------------------------
  7745                                  section .bss
  7746                                  bits 32
  7747                                  align 4
  7748                                  %ifdef CRIPLED_ELF
  7749                                   bssstart:
  7750                                  %endif
  7751                                  screenbuffer_size equ 62*(160+32)	;estimated 62 lines 160 columns, 32 byte ESC seq (ca.12k)
  7752                                  screenbuffer_dwords equ screenbuffer_size/4
  7753 00000000 <res 00002E80>          screenbuffer resb screenbuffer_size
  7754                                  screenbuffer_end equ $			;If you really have higher screen resolution,
  7755                                  					;...no problem, except some useless redrawing happens.
  7756                                  %ifdef W32
  7757                                   attribbuffer	resw 62*160		;estimated 62 lines 160 columns
  7758                                   attribbuffer_end equ $
  7759                                  %else
  7760 00002E80 <res 00000024>           termios:	resb termios_struc_size
  7761 00002EA4 <res 00000024>           termios_orig:	resb termios_struc_size
  7762 00002EC8 <res 00000008>           winsize:	resb winsize_struc_size
  7763                                   setkplen	equ 10
  7764 00002ED0 <res 0000000A>           setkp		resb setkplen		;to store cursor ESC seq like  db 27,'[000;000H'
  7765 00002EDA <res 00000002>           		resb 2			;fill up
  7766 00002EDC <res 00000004>           revvoff	resd 1
  7767                                  %endif
  7768                                  %ifdef USE_UNDO
  7769 00002EE0 <res 00000004>           enter_undo	resd 1			;a status byte: 1 while in a undo process, else 0
  7770 00002EE4 <res 00000004>           last_undo_file resd 1			;a pointer to undo info stored external in a disk file
  7771 00002EE8 <res 00000004>           undoptr	resd 1			;points on top frame in undo ringbuffer stack
  7772                                   undobuffer_size equ 0x10000		;64 k
  7773 00002EEC <res 00010000>           undobuffer	resb undobuffer_size
  7774                                   undobuffer_end equ $
  7775                                  %endif
  7776 00012EEC <res 00000004>          lines		resd 1			;equ 24 or similar i.e. screen lines-1 (1 for statusline)
  7777 00012EF0 <res 00000004>          columns		resd 1			;equ 80 or similar dword (using only LSB)
  7778 00012EF4 <res 00000004>          columne		resd 1			;helper for display of current column
  7779 00012EF8 <res 00000004>          zloffst		resd 1			;helper: chars scrolled out at left border
  7780 00012EFC <res 00000004>          fileptr		resd 1			;helper for temp storage of current pos in file
  7781 00012F00 <res 00000004>          kurspos		resd 1			;cursor position set by DispNewScreen()
  7782 00012F04 <res 00000004>          kurspos2	resd 1			;cursor position set by other functions
  7783                                  
  7784 00012F08 <res 00000004>          tabcnt		resd 1			;internal helper byte in DispNewScreen() only
  7785 00012F0C <res 00000004>          changed		resd 1			;status byte: (UN)CHANGED
  7786 00012F10 <res 00000004>          oldQFpos	resd 1
  7787 00012F14 <res 00000004>          bereitsges	resd 1			;byte used for ^L
  7788                                  
  7789 00012F18 <res 00000004>          blockbegin	resd 1
  7790 00012F1C <res 00000004>          blockende	resd 1
  7791 00012F20 <res 00000004>          endeedit	resd 1			;byte controls program exit
  7792 00012F24 <res 00000004>          old		resd 1			;helper for ^QP
  7793 00012F28 <res 00000004>          veryold		resd 1			;ditto
  7794 00012F2C <res 00000004>          linenr		resd 1			;current line
  7795 00012F30 <res 00000004>          showblock	resd 1			;helper for ^KH
  7796 00012F34 <res 00000004>          suchlaenge	resd 1			;helper for ^QA,^QF
  7797 00012F38 <res 00000004>          repllaenge	resd 1
  7798 00012F3C <res 00000004>          vorwarts	resd 1
  7799 00012F40 <res 00000004>          grossklein	resd 1			;helper byte for ^QF,^QA
  7800                                  					; ^ ^ ^ ^ TODO check UTF-8 stuff here
  7801 00012F44 <res 00000004>          ch2linebeg	resd 1			;helper keeping cursor pos max at EOL (up/dn keys)
  7802 00012F48 <res 00000004>          numeriere	resd 1			;byte controls re-numeration
  7803 00012F4C <res 00000004>          read_b		resd 1			;buffer for getchar
  7804                                  %ifdef W32
  7805                                  		resd 4			;4 extra due size INPUT_RECORD in w32
  7806                                  %endif		
  7807 00012F50 <res 00000004>          isbold		resd 1			;control of bold display of ws-blocks
  7808 00012F54 <res 00000004>          inverse		resd 1
  7809 00012F58 <res 00000004>          insstat		resd 1
  7810                                  
  7811                                  %ifdef AMD64
  7812                                  ErrNr		resq 1
  7813                                  %else
  7814 00012F5C <res 00000004>          ErrNr		resd 1			;used similar libc errno, but not excactly equal
  7815                                  %endif
  7816                                  errlen		equ 100
  7817 00012F60 <res 00000064>          error		resb errlen		;reserved space for string: 'ERROR xxx:tttteeeexxxxtttt',0
  7818                                  
  7819 00012FC4 <res 00000004>          maxlen		resd 1
  7820                                  ;-------
  7821                                  ;
  7822                                  maxfilenamelen	equ 255
  7823 00012FC8 <res 00000100>          filepath	resb maxfilenamelen+1
  7824 000130C8 <res 00000100>          bakpath		resb maxfilenamelen+1
  7825 000131C8 <res 00000100>          blockpath	resb maxfilenamelen+1
  7826 000132C8 <res 00000100>          replacetext	resb maxfilenamelen+1
  7827 000133C8 <res 00000100>          suchtext	resb maxfilenamelen+1
  7828 000134C8 <res 00000100>          suchtext2	resb maxfilenamelen+1	;for PICO mode
  7829 000135C8 <res 0000007C>          optbuffer	resb optslen		;buffer for search/replace options and for ^QI
  7830                                  linkbuffersize	equ 4
  7831 00013644 <res 00000004>          linkbuffer	resb linkbuffersize
  7832 00013648 <res 000000A0>          sigaction	resd 40
  7833                                  ;------
  7834 000136E8 <res 00000004>          perms		resd 1
  7835                                  %ifdef SYS_fstat
  7836 000136EC <res 00000040>           fstatbuf:	resb stat_struc_size	
  7837                                  %endif
  7838                                  %ifdef SYS_utime
  7839 0001372C <res 00000008>           accesstime:	resb utimbuf_struc_size
  7840                                  %endif
  7841                                  ;-------
  7842 00013734 <res 00000138>          screenline	resb 256+4*scolorslen	;max possible columns + 4 color ESC seq per line
  7843                                  					;(buffer for displaying a text line)
  7844                                  %ifdef W32
  7845                                   attribline	resb 256*2		;attrib is a word
  7846                                  %endif
  7847 0001386C <res 00000004>          EmaKiSize	resd 1
  7848 00013870 <res 00000004>          EmaKiSrc	resd 1
  7849 00013874 <res 00000004>          EmaMark		resd 1
  7850                                  EmaCtrl:
  7851 00013878 <res 00000001>          EmaCtrlK	resb 1
  7852 00013879 <res 00000001>          EmaCtrlS	resb 1
  7853 0001387A <res 00000002>          		resb 2
  7854 0001387C <res 00000004>          EmaNumHelper	resd 1
  7855 00013880 <res 00000004>          VICmdMode	resd 1
  7856 00013884 <res 00000004>          VIbufch		resd 1
  7857 00013888 <res 00000004>          VInolinebased	resd 1
  7858 0001388C <res 00000004>          PicoSearch	resd 1			;where search started
  7859                                  %ifdef UTF8RTS
  7860                                  isUTF8		resd 1
  7861                                  %endif
  7862                                  %ifdef USE_PIPE
  7863 00013890 <res 00000004>           sedpipeB0	resd 1
  7864 00013894 <res 00000004>           sedpipeB1	resd 1
  7865 00013898 <res 00000004>           sedpipeC0	resd 1
  7866 0001389C <res 00000004>           sedpipeC1	resd 1
  7867                                  %endif
  7868                                  
  7869 000138A0 <res 00000004>          mode		resd 1
  7870                                  
  7871 000138A4 <res 00000004>          readfds		resd 1			;select data struc
  7872 000138A8 <res 00000004>          timevalsec	resd 1			;lowest
  7873 000138AC <res 00000004>          timevalusec	resd 1			;most significant
  7874                                                                                  
  7875                                  
  7876                                  buffercopysize	equ 1024
  7877 000138B0 <res 00000400>          buffercopy	resb buffercopysize
  7878                                  %ifdef USE_MATH
  7879 00013CB0 <res 00000004>           level		resd 1			;balance
  7880 00013CB4 <res 00000004>           ptlevel	resd 1			;parenthesis balance
  7881                                   %ifdef AMD64
  7882                                   stackptr	resq 1
  7883                                   %else
  7884 00013CB8 <res 00000004>           stackptr	resd 1			;escape recursion
  7885                                   %endif
  7886 00013CBC <res 0000000C>           x87		resd 3			;12 byte (need 10 byte for 80 bit BCD)
  7887 00013CC8 <res 00000020>           lastresult87	resq 4			;8 byte
  7888 00013CE8 <res 00000004>           signctl	resd 1
  7889                                  %endif
  7890                                  %ifdef W32
  7891                                   heap		resd 1
  7892                                   hin		resd 1
  7893                                   hout		resd 1
  7894                                   w32result	resd 1			;for the w32 API calls
  7895                                   csbi		resd 6			;screen_buffer_info
  7896                                  %endif
  7897                                  
  7898                                  %ifdef SYS_brk
  7899                                   max		equ 1024000		;valid for NEW created files only
  7900                                  %else
  7901                                   max		equ 10240000
  7902                                  %endif
  7903                                  ;-------
  7904 00013CEC <res 000FA000>          text		resb max
  7905                                  sot 		equ (text+1)		;start-of-text
  7906                                  
  7907                                  %ifdef CRIPLED_ELF
  7908                                   bsssize equ $-bssstart
  7909                                  %endif
