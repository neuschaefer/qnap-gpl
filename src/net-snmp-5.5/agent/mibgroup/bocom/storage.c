/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17695 2009-07-21 12:22:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/types.h>
#include <net-snmp/library/snmp_api.h>
#include <net-snmp/library/snmp_client.h>
#include <net-snmp/library/snmp_secmod.h>
#include <net-snmp/library/mib.h>
#include <net-snmp/library/snmp_logging.h>
#include <net-snmp/library/snmp_assert.h>

#include "storage.h"
#include "common.h"

//#define SNMP_DPRINTF	printf
#define SNMP_DPRINTF(x, ...) {}

struct SystemIfTable_entry *SystemIfTable_createEntry(long  IfIndex);
struct SystemHdTable_entry *SystemHdTable_createEntry(long  IfIndex);
struct SystemFanTable_entry *SystemFanTable_createEntry(long  IfIndex);
struct SystemVolumeTable_entry *SystemVolumeTable_createEntry(long  IfIndex);
struct SystemCpuTable_entry *SystemCpuTable_createEntry(long  index);
struct SystemMemoryTable_entry *SystemMemoryTable_createEntry(long  index);

/** Initializes the storage module */
void
init_storage(void)
{
  /* here we initialize all the tables we're planning on supporting */
	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    initialize_table_SystemIfTable();
    initialize_table_SystemHdTable();
    initialize_table_SystemFanTable();
    initialize_table_SystemCpuTable();
    initialize_table_SystemMemoryTable();
//    initialize_table_SystemVolumeTable();
}

//  # Determine the first/last column names

/** Initialize the SystemIfTable table by defining its contents and how it's structured */
void
initialize_table_SystemIfTable(void)
{
    oid SystemIfTable_oid[] = {NAS_ROOT_OID,3,1,1,1,10};
    size_t SystemIfTable_oid_len   = OID_LENGTH(SystemIfTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemIfTable\n"));
	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);

    reg = netsnmp_create_handler_registration(
              "SystemIfTable",     SystemIfTable_handler,
              SystemIfTable_oid, SystemIfTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: IfIndex */
                           0);
    table_info->min_column = COLUMN_IFIPADDR;
    table_info->max_column = COLUMN_IFPACKETSSENT;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemIfTable_get_first_data_point;
    iinfo->get_next_data_point  = SystemIfTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, IfNum = GetNasNetworkNumber();
	for (index = 1; index <= IfNum; index ++) {
		SystemIfTable_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemIfTable_entry {
    /* Index values */
    long IfIndex;

    /* Column values */
    long IfIndexData;
    char IfIPAddr[64];
    int   IfLinked;	//0:down, 1:up
    char IfDescr[256];
    size_t IfDescr_len;
    int IfPacketsReceived;
    int IfPacketsSent;
    int IfErrorPackets;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemIfTable_entry *next;
};

struct SystemIfTable_entry  *SystemIfTable_head;

/* create a new row in the (unsorted) table */
struct SystemIfTable_entry *
SystemIfTable_createEntry(
                 long  IfIndex
                ) {
    struct SystemIfTable_entry *entry;

	DEBUGMSGTL(("storage:create", "%s() begin\n", __FUNCTION__));
    entry = SNMP_MALLOC_TYPEDEF(struct SystemIfTable_entry);
    if (!entry)
        return NULL;

    entry->IfIndex = IfIndex;
    entry->IfDescr_len = snprintf(entry->IfDescr, sizeof(entry->IfDescr), "eth%d", IfIndex-1);
    entry->next = SystemIfTable_head;
    SystemIfTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemIfTable_removeEntry( struct SystemIfTable_entry *entry ) {
    struct SystemIfTable_entry *ptr, *prev;

	DEBUGMSGTL(("storage:remove", "%s() begin\n", __FUNCTION__));
    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemIfTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemIfTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

static void output_var_list(netsnmp_variable_list *put_index_data)
{
	if (!put_index_data) 
		return;
	DEBUGMSGTL(("storage:init", "index=%d\nOID=", put_index_data->index));
	int ip;
	for (ip = 0; ip < put_index_data->name_length; ip ++) {
		SNMP_DPRINTF("%d.", put_index_data->name[ip]);
	}
	SNMP_DPRINTF("\n");
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemIfTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
	SNMP_DPRINTF("%s(%x) begin\n", __FUNCTION__, SystemIfTable_head);
	output_var_list(put_index_data);
    *my_loop_context = SystemIfTable_head;
    return SystemIfTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemIfTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemIfTable_entry *entry = (struct SystemIfTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->IfIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemIfTable table */
int
SystemIfTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemIfTable_entry          *table_entry;
	char buff[64], string[512];

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));
	SNMP_DPRINTF("%s(%d) begin\n", __FUNCTION__, reqinfo->mode);

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
		int index = -1, col = -1;
            table_entry = (struct SystemIfTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
			DEBUGMSGTL(("storage:handler", "table_entry=%x, table_info=%x\n", table_entry, table_info));
			if (table_entry)
				index = table_entry->IfIndex;
//				SNMP_DPRINTF("table_entry->IfIndex=%d\n", table_entry->IfIndex);
			if (table_info)
				col = table_info->colnum;
//				SNMP_DPRINTF("table_info->colnum=%d\n", table_info->colnum);
			DEBUGMSGTL(("storage:handler", "(%d, %d)\n", index, col));
    
            switch (table_info->colnum) {
            case COLUMN_IFINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->IfIndex);
                break;
            case COLUMN_IFDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->IfDescr,
                                          table_entry->IfDescr_len);
                break;
            case COLUMN_IFIPADDR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
			snprintf(string, sizeof(string), "/sbin/ifconfig %s | /bin/grep 'inet addr:'", table_entry->IfDescr);
			strcpy(table_entry->IfIPAddr, "0.0.0.0");
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0) {
				char *ptr = strstr(buff, "inet addr:"), *end;
				if (ptr) {
					ptr += strlen("inet addr:");
					end = strchr(ptr, ' ');
					if (end) *end = 0;
					snprintf(table_entry->IfIPAddr, sizeof(table_entry->IfIPAddr), "%s", ptr);
				}
			}
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->IfIPAddr,
                                          strlen(table_entry->IfIPAddr));
                break;
            case COLUMN_IFLINKED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }

			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/operstate", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfLinked = (strncmp(buff, "up", 2) == 0);
			else
				table_entry->IfLinked = 0;
			
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            table_entry->IfLinked);
                break;
            case COLUMN_IFPACKETSRECEIVED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
			//Bocom need KB
			snprintf(string, sizeof(string), "/bin/cat /sys/class/net/%s/statistics/rx_bytes", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfPacketsReceived = atoi(buff)/1024;
			else
				table_entry->IfPacketsReceived = 0;
			
                snmp_set_var_typed_value( request->requestvb, ASN_COUNTER,
                                 (u_char*)&table_entry->IfPacketsReceived,
                                          sizeof(table_entry->IfPacketsReceived));
                break;
            case COLUMN_IFPACKETSSENT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
			//Bocom need KB
			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/tx_bytes", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfPacketsSent = atoi(buff)/1024;
			else
				table_entry->IfPacketsSent = 0;

                snmp_set_var_typed_value( request->requestvb, ASN_COUNTER,
                                 (u_char*)&table_entry->IfPacketsSent,
                                          sizeof(table_entry->IfPacketsSent));
                break;
            case COLUMN_IFERRORPACKETS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/rx_errors", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfErrorPackets = atoi(buff);
			else
				table_entry->IfErrorPackets = 0;
			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/tx_errors", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfErrorPackets += atoi(buff);

                snmp_set_var_typed_value( request->requestvb, ASN_COUNTER,
                                 (u_char*)&table_entry->IfErrorPackets,
                                          sizeof(table_entry->IfErrorPackets));
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the SystemHdTable table by defining its contents and how it's structured */
void
initialize_table_SystemHdTable(void)
{
    const oid SystemHdTable_oid[] = {NAS_ROOT_OID,3,1,1,1,9};
    const size_t SystemHdTable_oid_len   = OID_LENGTH(SystemHdTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemHdTable\n"));

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    reg = netsnmp_create_handler_registration(
              "SystemHdTable",     SystemHdTable_handler,
              SystemHdTable_oid, SystemHdTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: HdIndex */
                           0);
    table_info->min_column = COLUMN_HDUUID;
    table_info->max_column = COLUMN_HDTEMPERATURE;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemHdTable_get_first_data_point;
    iinfo->get_next_data_point  = SystemHdTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, HdNum = GetNasDiskNumber();
	for (index = 1; index <= HdNum; index ++) {
		SystemHdTable_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemHdTable_entry {
    /* Index values */
    long HdIndex;

    /* Column values */
    long HdIndexData;
    char HdDescr[256];
    size_t HdDescr_len;
    char HdTemperature[64];
    size_t HdTemperature_len;
    long HdStatus;
    char HdModel[64];
    size_t HdModel_len;
    char HdCapacity[64];
    size_t HdCapacity_len;
    char HdSmartInfo[64];
    size_t HdSmartInfo_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemHdTable_entry *next;
};

struct SystemHdTable_entry  *SystemHdTable_head;

/* create a new row in the (unsorted) table */
struct SystemHdTable_entry *
SystemHdTable_createEntry(
                 long  HdIndex
                ) {
    struct SystemHdTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct SystemHdTable_entry);
    if (!entry)
        return NULL;

    entry->HdIndex = HdIndex;
    entry->HdDescr_len = snprintf(entry->HdDescr, sizeof(entry->HdDescr), "HDD%d", HdIndex);
    entry->next = SystemHdTable_head;
    SystemHdTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemHdTable_removeEntry( struct SystemHdTable_entry *entry ) {
    struct SystemHdTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemHdTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemHdTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemHdTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemHdTable_head;
    return SystemHdTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemHdTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemHdTable_entry *entry = (struct SystemHdTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->HdIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemHdTable table */
int
SystemHdTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemHdTable_entry          *table_entry;

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct SystemHdTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_HDINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->HdIndex);
                break;
            case COLUMN_HDUUID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
		char cmd[512], uuid[128];
		*uuid = '\0';
		snprintf(cmd, sizeof(cmd), "/usr/local/sbin/blkid -o value -s UUID /dev/sd%c3", (char)table_entry->HdIndex-1+'a');
		GetOneStringFromCommand(cmd, uuid, sizeof(uuid));
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)uuid,
                                          strlen(uuid));
	    	}
                break;
            case COLUMN_HDDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdDescr,
                                          table_entry->HdDescr_len);
                break;
            case COLUMN_MOUNTED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            0);
                break;
            case COLUMN_MOUNTPATH:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)"", 0);
                break;
            case COLUMN_READ_RATE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            0);
                break;
            case COLUMN_WRITE_RATE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            0);
                break;
            case COLUMN_HDTEMPERATURE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
		char cmd[512];
		int hd_temp = 0;
		table_entry->HdTemperature[0] = '\0';
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo hdtmp %d", table_entry->HdIndex);
		GetOneStringFromCommand(cmd, table_entry->HdTemperature, sizeof(table_entry->HdTemperature));
		hd_temp = atoi(table_entry->HdTemperature);
		table_entry->HdTemperature_len = strlen(table_entry->HdTemperature);
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            hd_temp);
	    	}
                break;
            case COLUMN_CANWRITE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
	     	{
		char buff[128];
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo hdstatus %d", table_entry->HdIndex);
		if (GetOneStringFromCommand(cmd, buff, sizeof(buff)) == 0) {
			table_entry->HdStatus = atoi(buff);
		}
		else table_entry->HdStatus = -4;	//Unknown error
    		}
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            (table_entry->HdStatus<0)?0:2);
                break;
            case COLUMN_HDMODEL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
		char file[256];
		snprintf(file, sizeof(file), "/sys/block/sd%c/device/model", 'a'+table_entry->HdIndex-1);
		FILE *fp = fopen(file, "ro");
		if (!fp) {
			strcpy(table_entry->HdModel, "--");
		}
		else {
			fgets(table_entry->HdModel, sizeof(table_entry->HdModel), fp);
			fclose(fp);
		}
		table_entry->HdModel_len = strlen(table_entry->HdModel);
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdModel,
                                          table_entry->HdModel_len);
		}
		break;
            case COLUMN_HDCAPACITY:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
		char file[256], buf[128];
		unsigned long long capBlock, capSize = 0;
		int block_size = 512;
		int ret;
		struct counter64 cap64;
		snprintf(file, sizeof(file), "/sys/block/sd%c/size", 'a'+table_entry->HdIndex-1);
		FILE *fp = fopen(file, "ro");
		if (!fp) {
			DEBUGMSGTL(("storage:HD_handler", "read size (%s) failed\n", file));
			goto WRITE_CAPACITY;
		}
		fgets(buf, sizeof(buf), fp);
		capBlock = atoll(buf);
		fclose(fp);

		snprintf(file, sizeof(file), "/sys/block/sd%c/queue/hw_sector_size", 'a'+table_entry->HdIndex-1);
		fp = fopen(file, "ro");
		if (!fp) {
			goto WRITE_CAPACITY;
			DEBUGMSGTL(("storage:HD_handler", "read sector size (%s) failed\n", file));
		}
		fgets(buf, sizeof(buf), fp);
		block_size = atoi(buf);
		fclose(fp);

		capSize = capBlock*block_size;
		capSize >>= 20;
		DEBUGMSGTL(("storage:HD_handler", "capacity size (%llu MB) for HDD%d\n", capSize, table_entry->HdIndex));
WRITE_CAPACITY:
		cap64.low = capSize & 0xffffffff;
		cap64.high = capSize >> 32;
		table_entry->HdCapacity_len = strlen(table_entry->HdCapacity);
		if (0) {
                ret = snmp_set_var_typed_value( request->requestvb, ASN_COUNTER64,
                                 (u_char*)&cap64,
                                          sizeof(cap64));
		}
		else {
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            (unsigned long)capSize);
		}
		DEBUGMSGTL(("storage:HD_handler", "set value for HDD%d return %d\n", table_entry->HdIndex, ret));
		}
		break;
            case COLUMN_HDUSEDSIZE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		if (0) {
		struct counter64 used64;
		used64.low = 0;
		used64.high = 0;
                snmp_set_var_typed_value( request->requestvb, ASN_COUNTER64,
                                 (u_char*)&used64,
                                          sizeof(used64));
		}
		else {
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            0);
		}
		break;
		case COLUMN_HDSMARTINFO:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo hdsmart %d", table_entry->HdIndex);
		GetOneStringFromCommand(cmd, table_entry->HdSmartInfo, sizeof(table_entry->HdSmartInfo));
		table_entry->HdSmartInfo_len = strlen(table_entry->HdSmartInfo);
	    	}
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdSmartInfo,
                                          table_entry->HdSmartInfo_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the SystemFanTable table by defining its contents and how it's structured */
void
initialize_table_SystemFanTable(void)
{
    const oid SystemFanTable_oid[] = {NAS_ROOT_OID,3,1,1,4,3,5};
    const size_t SystemFanTable_oid_len   = OID_LENGTH(SystemFanTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemFanTable\n"));

    reg = netsnmp_create_handler_registration(
              "SystemFanTable",     SystemFanTable_handler,
              SystemFanTable_oid, SystemFanTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: SysFanIndex */
                           0);
    table_info->min_column = COLUMN_SYSFANINDEX;
    table_info->max_column = COLUMN_SYSFANSPEED;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemFanTable_get_first_data_point;
    iinfo->get_next_data_point  = SystemFanTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, FanNum = GetSystemFanNumber();
	for (index = 1; index <= FanNum; index ++) {
		SystemFanTable_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemFanTable_entry {
    /* Index values */
    long SysFanIndex;

    /* Column values */
    long SysFanIndexData;
    char SysFanDescr[256];
    size_t SysFanDescr_len;
    char SysFanSpeed[64];
    size_t SysFanSpeed_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemFanTable_entry *next;
};

struct SystemFanTable_entry  *SystemFanTable_head;

/* create a new row in the (unsorted) table */
struct SystemFanTable_entry *
SystemFanTable_createEntry(
                 long  SysFanIndex
                ) {
    struct SystemFanTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct SystemFanTable_entry);
    if (!entry)
        return NULL;

    entry->SysFanIndex = SysFanIndex;
    entry->SysFanDescr_len = snprintf(entry->SysFanDescr, sizeof(entry->SysFanDescr), "System FAN %d", SysFanIndex);
    entry->next = SystemFanTable_head;
    SystemFanTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemFanTable_removeEntry( struct SystemFanTable_entry *entry ) {
    struct SystemFanTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemFanTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemFanTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemFanTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemFanTable_head;
    return SystemFanTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemFanTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemFanTable_entry *entry = (struct SystemFanTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->SysFanIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemFanTable table */
int
SystemFanTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemFanTable_entry          *table_entry;

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct SystemFanTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_SYSFANINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->SysFanIndex);
                break;
            case COLUMN_SYSFANDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysFanDescr,
                                          table_entry->SysFanDescr_len);
                break;
            case COLUMN_SYSFANSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            1);
                break;
            case COLUMN_SYSFANSPEED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo sysfan %d", table_entry->SysFanIndex);
		*table_entry->SysFanSpeed = 0;
		GetOneStringFromCommand(cmd, table_entry->SysFanSpeed, sizeof(table_entry->SysFanSpeed));
		table_entry->SysFanSpeed_len = strlen(table_entry->SysFanSpeed);
		}

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysFanSpeed,
                                          table_entry->SysFanSpeed_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the SystemVolumeTable table by defining its contents and how it's structured */
void
initialize_table_SystemVolumeTable(void)
{
    const oid SystemVolumeTable_oid[] = {NAS_ROOT_OID,17};
    const size_t SystemVolumeTable_oid_len   = OID_LENGTH(SystemVolumeTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemVolumeTable\n"));

    reg = netsnmp_create_handler_registration(
              "SystemVolumeTable",     SystemVolumeTable_handler,
              SystemVolumeTable_oid, SystemVolumeTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: SysVolumeIndex */
                           0);
    table_info->min_column = COLUMN_SYSVOLUMEINDEX;
    table_info->max_column = COLUMN_SYSVOLUMESTATUS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemVolumeTable_get_first_data_point;
    iinfo->get_next_data_point  = SystemVolumeTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, VolumeNum = GetSystemVolumeNumber();
	for (index = 1; index <= VolumeNum; index ++) {
		SystemVolumeTable_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemVolumeTable_entry {
    /* Index values */
    long SysVolumeIndex;

    /* Column values */
    long SysVolumeIndexData;
    char SysVolumeDescr[256];
    size_t SysVolumeDescr_len;
    char SysVolumeFS[15];
    size_t SysVolumeFS_len;
    char SysVolumeTotalSize[15];
    size_t SysVolumeTotalSize_len;
    char SysVolumeFreeSize[15];
    size_t SysVolumeFreeSize_len;
    char SysVolumeStatus[256];
    size_t SysVolumeStatus_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemVolumeTable_entry *next;
};

struct SystemVolumeTable_entry  *SystemVolumeTable_head;

static int GetSystemVolumeInformString(int item, int index, char *string, int size)
{
	char cmd[512], *item_str;

	*string = 0;
	switch (item) {
	case COLUMN_SYSVOLUMEDESCR:
		item_str = "vol_desc";
		break;
	case COLUMN_SYSVOLUMEFS:
		item_str = "vol_fs";
		break;
	case COLUMN_SYSVOLUMETOTALSIZE:
		item_str = "vol_totalsize";
		break;
	case COLUMN_SYSVOLUMEFREESIZE:
		item_str = "vol_freesize";
		break;
	case COLUMN_SYSVOLUMESTATUS:
		item_str = "vol_status";
		break;
	default:
		return 0;
	}
	snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo %s %d", item_str, index-1);
	GetOneStringFromCommand(cmd, string, size);
	return strlen(string);
}

/* create a new row in the (unsorted) table */
struct SystemVolumeTable_entry *
SystemVolumeTable_createEntry(
                 long  SysVolumeIndex
                ) {
    struct SystemVolumeTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct SystemVolumeTable_entry);
    if (!entry)
        return NULL;

    entry->SysVolumeIndex = SysVolumeIndex;
    entry->next = SystemVolumeTable_head;
    SystemVolumeTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemVolumeTable_removeEntry( struct SystemVolumeTable_entry *entry ) {
    struct SystemVolumeTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemVolumeTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemVolumeTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemVolumeTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemVolumeTable_head;
    return SystemVolumeTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemVolumeTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemVolumeTable_entry *entry = (struct SystemVolumeTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->SysVolumeIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}

/** handles requests for the SystemVolumeTable table */
int
SystemVolumeTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemVolumeTable_entry          *table_entry;

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct SystemVolumeTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            if ( !table_entry ) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            switch (table_info->colnum) {
            case COLUMN_SYSVOLUMEINDEX:
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->SysVolumeIndex);
                break;
            case COLUMN_SYSVOLUMEDESCR:
		table_entry->SysVolumeDescr_len = GetSystemVolumeInformString(COLUMN_SYSVOLUMEDESCR, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeDescr, sizeof(table_entry->SysVolumeDescr));
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeDescr,
                                          table_entry->SysVolumeDescr_len);
                break;
            case COLUMN_SYSVOLUMEFS:
		   table_entry->SysVolumeFS_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, table_entry->SysVolumeFS, sizeof(table_entry->SysVolumeFS));

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeFS,
                                          table_entry->SysVolumeFS_len);
                break;
		case COLUMN_SYSVOLUMETOTALSIZE:
		   table_entry->SysVolumeTotalSize_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeTotalSize, sizeof(table_entry->SysVolumeTotalSize));

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeTotalSize,
                                          table_entry->SysVolumeTotalSize_len);
			break;
		case COLUMN_SYSVOLUMEFREESIZE:
		   table_entry->SysVolumeFreeSize_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeFreeSize, sizeof(table_entry->SysVolumeFreeSize));

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeFreeSize,
                                          table_entry->SysVolumeFreeSize_len);
			break;
		case COLUMN_SYSVOLUMESTATUS:
		   table_entry->SysVolumeStatus_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeStatus, sizeof(table_entry->SysVolumeStatus));

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeStatus,
                                          table_entry->SysVolumeStatus_len);
			break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}


//  # Determine the first/last column names

/** Initialize the SystemCpuTable table by defining its contents and how it's structured */
void
initialize_table_SystemCpuTable(void)
{
    oid SystemCpuTable_oid[] = {NAS_ROOT_OID,3,1,1,1,7};
    size_t SystemCpuTable_oid_len   = OID_LENGTH(SystemCpuTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemCpuTable\n"));
	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);

    reg = netsnmp_create_handler_registration(
              "SystemCpuTable",     SystemCpuTable_handler,
              SystemCpuTable_oid, SystemCpuTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: CpuIndex */
                           0);
    table_info->min_column = COLUMN_CPURUNTIME;
    table_info->max_column = COLUMN_CPUSPEED;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemCpuTable_get_first_data_point;
    iinfo->get_next_data_point  = SystemCpuTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	char buf[256];
	if (GetOneStringFromCommand("/usr/bin/top -Q 1 2>/dev/null", buf, sizeof(buf)) == 0) {
		if (strncmp(buf, "CPU Number:", 11) == 0) {
			int index, CpuNum = atoi(buf+11)-1;
			for (index = 0; index < CpuNum; index ++) {
				SystemCpuTable_createEntry(index);
			}
		}
	}
}

    /* Typical data structure for a row entry */
struct SystemCpuTable_entry {
    /* Index values */
    long CpuIndex;

    /* Column values */
    char CpuName[256];
    size_t CpuName_len;
    int CpuSpeed;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemCpuTable_entry *next;
};

struct SystemCpuTable_entry  *SystemCpuTable_head;

/* create a new row in the (unsorted) table */
struct SystemCpuTable_entry *
SystemCpuTable_createEntry(
                 long  CpuIndex
                ) {
    struct SystemCpuTable_entry *entry;

	DEBUGMSGTL(("storage:create", "%s() begin\n", __FUNCTION__));
    entry = SNMP_MALLOC_TYPEDEF(struct SystemCpuTable_entry);
    if (!entry)
        return NULL;

    entry->CpuIndex = CpuIndex;
	char buf[1024], *ptr;
	FILE *fp = fopen("/proc/cpuinfo", "r");
	if (fp == NULL) return ;
	int index = -1;
	while (1) {
		if (fgets(buf, sizeof(buf), fp) == NULL) break;
		int len = strlen(buf);
		if (buf[len-1] == '\n' || buf[len-1] == '\r') buf[--len] = 0;
		if (strncmp(buf, "processor", 9) == 0) {
			ptr = strchr(buf, ':');
			if (!ptr) continue;
			index = atoi(ptr+2);
			continue;
		}
		if (index != CpuIndex) continue;
		
		if (strncmp(buf, "model name", 10) == 0) {
			ptr = strchr(buf, ':');
			if (!ptr) continue;
			entry->CpuName_len = snprintf(entry->CpuName, sizeof(entry->CpuName), "%s", ptr+2);
		}
		else if (strncmp(buf, "cpu MHz", 7) == 0) {
			ptr = strchr(buf, ':');
			if (!ptr) continue;
			entry->CpuSpeed = atoi(ptr+2);
		}
	}
	fclose(fp);
    entry->next = SystemCpuTable_head;
    SystemCpuTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemCpuTable_removeEntry( struct SystemCpuTable_entry *entry ) {
    struct SystemCpuTable_entry *ptr, *prev;

	DEBUGMSGTL(("storage:remove", "%s() begin\n", __FUNCTION__));
    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemCpuTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemCpuTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemCpuTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
	SNMP_DPRINTF("%s(%x) begin\n", __FUNCTION__, SystemCpuTable_head);
	output_var_list(put_index_data);
    *my_loop_context = SystemCpuTable_head;
    return SystemCpuTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemCpuTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemCpuTable_entry *entry = (struct SystemCpuTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->CpuIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemCpuTable table */
int
SystemCpuTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemCpuTable_entry          *table_entry;
	char buff[64], string[512];

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));
	SNMP_DPRINTF("%s(%d) begin\n", __FUNCTION__, reqinfo->mode);

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
		int index = -1, col = -1;
            table_entry = (struct SystemCpuTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
			DEBUGMSGTL(("storage:handler", "table_entry=%x, table_info=%x\n", table_entry, table_info));
			if (table_entry)
				index = table_entry->CpuIndex;
//				SNMP_DPRINTF("table_entry->CpuIndex=%d\n", table_entry->CpuIndex);
			if (table_info)
				col = table_info->colnum;
//				SNMP_DPRINTF("table_info->colnum=%d\n", table_info->colnum);
			DEBUGMSGTL(("storage:handler", "(%d, %d)\n", index, col));
    
            switch (table_info->colnum) {
            case COLUMN_CPUINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->CpuIndex);
                break;
            case COLUMN_CPURUNTIME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, 0);
                break;
            case COLUMN_CPUUSAGE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		char buf[256];
		int usage = 0;
		FILE *fp = popen("/usr/bin/top -Q 1 2>/dev/null", "r");
		if (fp == NULL) break;
		while (1) {
			if (fgets(buf, sizeof(buf), fp) == NULL) break;
			if (strncmp(buf, "CPU Usage:", 10) == 0) {
				usage = atoi(buf+(10+6*table_entry->CpuIndex));
				break;
			}
		}
		pclose(fp);
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, usage);
                break;
            case COLUMN_CPUUSER:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, 0);
                break;
            case COLUMN_CPUSYSTEM:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, 0);
                break;
            case COLUMN_CPUIDLE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, 0);
                break;
            case COLUMN_CPUIOWAIT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, 0);
                break;
            case COLUMN_CPUTEMPERATURE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		int cpu_temp=0;
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, cpu_temp);
                break;
            case COLUMN_CPUSPEED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, table_entry->CpuSpeed);
                break;
            case COLUMN_CPUNAME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->CpuName,
                                          table_entry->CpuName_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the SystemMemoryTable table by defining its contents and how it's structured */
void
initialize_table_SystemMemoryTable(void)
{
    oid SystemMemoryTable_oid[] = {NAS_ROOT_OID,3,1,1,1,8};
    size_t SystemMemoryTable_oid_len   = OID_LENGTH(SystemMemoryTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemMemoryTable\n"));
	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);

    reg = netsnmp_create_handler_registration(
              "SystemMemoryTable",     SystemMemoryTable_handler,
              SystemMemoryTable_oid, SystemMemoryTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: MemoryIndex */
                           0);
    table_info->min_column = COLUMN_MEMORY_TOTAL;
    table_info->max_column = COLUMN_MEMORY_VUSED;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemMemoryTable_get_first_data_point;
    iinfo->get_next_data_point  = SystemMemoryTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	SystemMemoryTable_createEntry(0);
}

    /* Typical data structure for a row entry */
struct SystemMemoryTable_entry {
    /* Index values */
    long MemoryIndex;

    /* Column values */
    unsigned int MemoryTotal;
    unsigned int MemoryUsed;
    unsigned int VMemoryTotal;
    unsigned int VMemoryUsed;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemMemoryTable_entry *next;
};

struct SystemMemoryTable_entry  *SystemMemoryTable_head;

static void get_system_memory_table(struct SystemMemoryTable_entry *entry)
{
	char buf[1024];
	FILE *fp = fopen("/proc/meminfo", "r");
	if (fp == NULL) return ;
	while (1) {
		if (fgets(buf, sizeof(buf), fp) == NULL) break;
		int len = strlen(buf);
		if (buf[len-1] == '\n' || buf[len-1] == '\r') buf[--len] = 0;
		if (strncmp(buf, "MemTotal:", 9) == 0) {
			entry->MemoryTotal = atoi(buf+10);
		}
		else if (strncmp(buf, "MemFree:", 8) == 0) {
			entry->MemoryUsed = entry->MemoryTotal - atoi(buf+9);
		}
		else if (strncmp(buf, "VmallocTotal:", 13) == 0) {
			entry->VMemoryTotal = atoi(buf+14);
		}
		else if (strncmp(buf, "VmallocUsed:", 12) == 0) {
			entry->VMemoryUsed = atoi(buf+13);
		}
	}
	fclose(fp);
}
/* create a new row in the (unsorted) table */
struct SystemMemoryTable_entry *
SystemMemoryTable_createEntry(
                 long  MemoryIndex
                ) {
    struct SystemMemoryTable_entry *entry;

	DEBUGMSGTL(("storage:create", "%s() begin\n", __FUNCTION__));
    entry = SNMP_MALLOC_TYPEDEF(struct SystemMemoryTable_entry);
    if (!entry)
        return NULL;

    entry->MemoryIndex = MemoryIndex;
	get_system_memory_table(entry);
    SystemMemoryTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemMemoryTable_removeEntry( struct SystemMemoryTable_entry *entry ) {
    struct SystemMemoryTable_entry *ptr, *prev;

	DEBUGMSGTL(("storage:remove", "%s() begin\n", __FUNCTION__));
    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemMemoryTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemMemoryTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemMemoryTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
	SNMP_DPRINTF("%s(%x) begin\n", __FUNCTION__, SystemMemoryTable_head);
	output_var_list(put_index_data);
    *my_loop_context = SystemMemoryTable_head;
    return SystemMemoryTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemMemoryTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemMemoryTable_entry *entry = (struct SystemMemoryTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->MemoryIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemMemoryTable table */
int
SystemMemoryTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemMemoryTable_entry          *table_entry;
	char buff[64], string[512];

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));
	SNMP_DPRINTF("%s(%d) begin\n", __FUNCTION__, reqinfo->mode);

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
		int index = -1, col = -1;
            table_entry = (struct SystemMemoryTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
			DEBUGMSGTL(("storage:handler", "table_entry=%x, table_info=%x\n", table_entry, table_info));
			if (table_entry)
				index = table_entry->MemoryIndex;
//				SNMP_DPRINTF("table_entry->MemoryIndex=%d\n", table_entry->MemoryIndex);
			if (table_info)
				col = table_info->colnum;
//				SNMP_DPRINTF("table_info->colnum=%d\n", table_info->colnum);
			DEBUGMSGTL(("storage:handler", "(%d, %d)\n", index, col));
    unsigned int MemoryTotal;
    unsigned int MemoryUsed;
    unsigned int VMemoryTotal;
    unsigned int VMemoryUsed;
       #define COLUMN_MEMORY_TOTAL      1
       #define COLUMN_MEMORY_VTOTAL     2
       #define COLUMN_MEMORY_USED       3
       #define COLUMN_MEMORY_VUSED      4
            switch (table_info->colnum) {
            case COLUMN_CPUINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->MemoryIndex);
                break;
            case COLUMN_MEMORY_TOTAL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		get_system_memory_table(table_entry);
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, table_entry->MemoryTotal);
                break;
            case COLUMN_MEMORY_VTOTAL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, table_entry->VMemoryTotal);
                break;
            case COLUMN_MEMORY_USED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, table_entry->MemoryUsed);
                break;
            case COLUMN_MEMORY_VUSED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, table_entry->VMemoryUsed);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

