/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 15999 2007-03-25 22:32:02Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "entityMIB.h"

struct entPhysicalTable_entry *entPhysicalTable_createEntry(long  entPhysicalIndex);
int GetOneStringFromCommand(char *cmd, char *buff, int buf_size);

/** Initializes the entityMIB module */
void
init_entityMIB(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_entPhysicalTable();
    initialize_table_entLogicalTable();
    initialize_table_entLPMappingTable();
    initialize_table_entAliasMappingTable();
    initialize_table_entPhysicalContainsTable();
}

//  # Determine the first/last column names

/** Initialize the entPhysicalTable table by defining its contents and how it's structured */
void
initialize_table_entPhysicalTable(void)
{
    static oid entPhysicalTable_oid[] = {1,3,6,1,2,1,47,1,1,1};
    size_t entPhysicalTable_oid_len   = OID_LENGTH(entPhysicalTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    reg = netsnmp_create_handler_registration(
              "entPhysicalTable",     entPhysicalTable_handler,
              entPhysicalTable_oid, entPhysicalTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: entPhysicalIndex */
                           0);
    table_info->min_column = COLUMN_ENTPHYSICALDESCR;
    table_info->max_column = COLUMN_ENTPHYSICALURIS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = entPhysicalTable_get_first_data_point;
    iinfo->get_next_data_point  = entPhysicalTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	entPhysicalTable_createEntry(1);
}

    /* Typical data structure for a row entry */
struct entPhysicalTable_entry {
    /* Index values */
    long entPhysicalIndex;

    /* Column values */
    char entPhysicalDescr[128];
    size_t entPhysicalDescr_len;
    oid entPhysicalVendorType[128];
    size_t entPhysicalVendorType_len;
    long entPhysicalContainedIn;
    long entPhysicalClass;
    long entPhysicalParentRelPos;
    char entPhysicalName[128];
    size_t entPhysicalName_len;
    char entPhysicalHardwareRev[128];
    size_t entPhysicalHardwareRev_len;
    char entPhysicalFirmwareRev[128];
    size_t entPhysicalFirmwareRev_len;
    char entPhysicalSoftwareRev[128];
    size_t entPhysicalSoftwareRev_len;
    char entPhysicalSerialNum[128];
    size_t entPhysicalSerialNum_len;
    char old_entPhysicalSerialNum[128];
    size_t old_entPhysicalSerialNum_len;
    char entPhysicalMfgName[128];
    size_t entPhysicalMfgName_len;
    char entPhysicalModelName[128];
    size_t entPhysicalModelName_len;
    char entPhysicalAlias[128];
    size_t entPhysicalAlias_len;
    char old_entPhysicalAlias[128];
    size_t old_entPhysicalAlias_len;
    char entPhysicalAssetID[128];
    size_t entPhysicalAssetID_len;
    char old_entPhysicalAssetID[128];
    size_t old_entPhysicalAssetID_len;
    long entPhysicalIsFRU;
    char entPhysicalMfgDate[128];
    size_t entPhysicalMfgDate_len;
    char entPhysicalUris[128];
    size_t entPhysicalUris_len;
    char old_entPhysicalUris[128];
    size_t old_entPhysicalUris_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct entPhysicalTable_entry *next;
};

struct entPhysicalTable_entry  *entPhysicalTable_head;

/* create a new row in the (unsorted) table */
struct entPhysicalTable_entry *
entPhysicalTable_createEntry(long  entPhysicalIndex) {
    struct entPhysicalTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct entPhysicalTable_entry);
    if (!entry)
        return NULL;

    entry->entPhysicalIndex = entPhysicalIndex;
    entry->next = entPhysicalTable_head;
    entPhysicalTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
entPhysicalTable_removeEntry( struct entPhysicalTable_entry *entry ) {
    struct entPhysicalTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = entPhysicalTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        entPhysicalTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
entPhysicalTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = entPhysicalTable_head;
    return entPhysicalTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
entPhysicalTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct entPhysicalTable_entry *entry = (struct entPhysicalTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->entPhysicalIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the entPhysicalTable table */
int
entPhysicalTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct entPhysicalTable_entry          *table_entry;
	int ret;
	char cmd[1024];

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct entPhysicalTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_ENTPHYSICALDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
				{
				char model[64];
				Get_Display_Model_Name(model, sizeof(model));
#if Athens
				char *ptr;

				if (strncmp(model, "NSS", 3) == 0) {
					ptr = model+3;
				}
				else
					ptr = model;
				table_entry->entPhysicalDescr_len = snprintf(table_entry->entPhysicalDescr, sizeof(table_entry->entPhysicalDescr), "Cisco NSS %s Smart Storage", ptr);
#else
				if (Is_Generic_Version()) {
					table_entry->entPhysicalDescr_len = snprintf(table_entry->entPhysicalDescr, sizeof(table_entry->entPhysicalDescr), "%s", model);
				}
				else {
					table_entry->entPhysicalDescr_len = snprintf(table_entry->entPhysicalDescr, sizeof(table_entry->entPhysicalDescr), "QNAP Turbo NAS %s", model);
				}
#endif
				}
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalDescr,
                                          table_entry->entPhysicalDescr_len);
                break;
            case COLUMN_ENTPHYSICALVENDORTYPE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OBJECT_ID,
                                 (u_char*)table_entry->entPhysicalVendorType,
                                          table_entry->entPhysicalVendorType_len);
                break;
            case COLUMN_ENTPHYSICALCONTAINEDIN:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->entPhysicalContainedIn);
                break;
            case COLUMN_ENTPHYSICALCLASS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
				table_entry->entPhysicalClass = 3; //Chassis(3)
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->entPhysicalClass);
                break;
            case COLUMN_ENTPHYSICALPARENTRELPOS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->entPhysicalParentRelPos);
                break;
            case COLUMN_ENTPHYSICALNAME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
				{
				char model[64];
				Get_Display_Model_Name(model, sizeof(model));
#if Athens
				char *ptr;

				if (strncmp(model, "NSS", 3) == 0) {
					ptr = model+3;
				}
				else
					ptr = model;
				table_entry->entPhysicalName_len = snprintf(table_entry->entPhysicalName, sizeof(table_entry->entPhysicalName), "NSS%s", ptr);
#else
				if (Is_Generic_Version()) {
					table_entry->entPhysicalName_len = snprintf(table_entry->entPhysicalName, sizeof(table_entry->entPhysicalName), "%s", model);
				}
				else {
					table_entry->entPhysicalName_len = snprintf(table_entry->entPhysicalName, sizeof(table_entry->entPhysicalName), "Turbo NAS %s", model);
				}
#endif
				}
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalName,
                                          table_entry->entPhysicalName_len);
                break;
            case COLUMN_ENTPHYSICALHARDWAREREV:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
#if Athens
				{
				char hw_ver[32], *ptr;
				Get_Hardware_Version(hw_ver, sizeof(hw_ver));
				if ((ptr = strchr(hw_ver, '.')) != NULL) {
					ptr ++;
				}
				else
					ptr = "0";

				table_entry->entPhysicalHardwareRev_len = snprintf(table_entry->entPhysicalHardwareRev, sizeof(table_entry->entPhysicalHardwareRev), "V%.2d", atoi(ptr)+1);
				}
#else
				Get_Hardware_Version(table_entry->entPhysicalHardwareRev, sizeof(table_entry->entPhysicalHardwareRev));
				table_entry->entPhysicalHardwareRev_len = strlen(table_entry->entPhysicalHardwareRev);
#endif
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalHardwareRev,
                                          table_entry->entPhysicalHardwareRev_len);
                break;
            case COLUMN_ENTPHYSICALFIRMWAREREV:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
				GetOneStringFromCommand("/sbin/getcfg \"System\" \"Version\"", table_entry->entPhysicalFirmwareRev, sizeof(table_entry->entPhysicalFirmwareRev));
				table_entry->entPhysicalFirmwareRev_len = strlen(table_entry->entPhysicalFirmwareRev);
/*
				Get_System_Version(table_entry->entPhysicalFirmwareRev, sizeof(table_entry->entPhysicalFirmwareRev));
				table_entry->entPhysicalFirmwareRev_len = strlen(table_entry->entPhysicalFirmwareRev);
*/
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalFirmwareRev,
                                          table_entry->entPhysicalFirmwareRev_len);
                break;
            case COLUMN_ENTPHYSICALSOFTWAREREV:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
				GetOneStringFromCommand("/sbin/getcfg \"System\" \"Version\"", table_entry->entPhysicalSoftwareRev, sizeof(table_entry->entPhysicalSoftwareRev));
				table_entry->entPhysicalSoftwareRev_len = strlen(table_entry->entPhysicalSoftwareRev);
/*
				Get_System_Version(table_entry->entPhysicalSoftwareRev, sizeof(table_entry->entPhysicalSoftwareRev));
				table_entry->entPhysicalSoftwareRev_len = strlen(table_entry->entPhysicalSoftwareRev);
*/
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalSoftwareRev,
                                          table_entry->entPhysicalSoftwareRev_len);
                break;
            case COLUMN_ENTPHYSICALSERIALNUM:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
				GetOneStringFromCommand("/sbin/get_hwsn", table_entry->entPhysicalSerialNum, sizeof(table_entry->entPhysicalSerialNum));
				table_entry->entPhysicalSerialNum_len = strlen(table_entry->entPhysicalSerialNum);
/*
				{
#if Athens
				char *def_sn = "null";
#else
				char *def_sn = "--";
#endif
				Get_Private_Profile_String("Hardware", "serial number", def_sn, table_entry->entPhysicalSerialNum, sizeof(table_entry->entPhysicalSerialNum), "/var/hw_serial_number");
				if (table_entry->entPhysicalSerialNum[0] == 0) {
					if(system("/sbin/get_hwsn >/dev/null 2>&1") == 0){
						Get_Private_Profile_String("Hardware", "serial number", def_sn, table_entry->entPhysicalSerialNum, sizeof(table_entry->entPhysicalSerialNum), "/var/hw_serial_number");
					}
				}
				if (table_entry->entPhysicalSerialNum[0] == 0) {
					strcpy(table_entry->entPhysicalSerialNum, def_sn);
				}
				table_entry->entPhysicalSerialNum_len = strlen(table_entry->entPhysicalSerialNum);
				}
*/
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalSerialNum,
                                          table_entry->entPhysicalSerialNum_len);
                break;
            case COLUMN_ENTPHYSICALMFGNAME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
#if Athens
				strcpy(table_entry->entPhysicalMfgName, "Cisco Small Business");
#else
				if (Is_Generic_Version()) {
					strcpy(table_entry->entPhysicalMfgName, "NAS");
				}
				else {
					strcpy(table_entry->entPhysicalMfgName, "QNAP Systems, Inc.");
				}
#endif
				table_entry->entPhysicalMfgName_len = strlen(table_entry->entPhysicalMfgName);
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalMfgName,
                                          table_entry->entPhysicalMfgName_len);
                break;
            case COLUMN_ENTPHYSICALMODELNAME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
				Get_Display_Model_Name(table_entry->entPhysicalModelName, sizeof(table_entry->entPhysicalModelName));
				table_entry->entPhysicalModelName_len = strlen(table_entry->entPhysicalModelName);
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalModelName,
                                          table_entry->entPhysicalModelName_len);
                break;
            case COLUMN_ENTPHYSICALALIAS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalAlias,
                                          table_entry->entPhysicalAlias_len);
                break;
            case COLUMN_ENTPHYSICALASSETID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalAssetID,
                                          table_entry->entPhysicalAssetID_len);
                break;
            case COLUMN_ENTPHYSICALISFRU:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->entPhysicalIsFRU);
                break;
            case COLUMN_ENTPHYSICALMFGDATE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalMfgDate,
                                          table_entry->entPhysicalMfgDate_len);
                break;
            case COLUMN_ENTPHYSICALURIS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entPhysicalUris,
                                          table_entry->entPhysicalUris_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
#if _QNAP_SUPPORT_WRITE_
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_entry = (struct entPhysicalTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_ENTPHYSICALSERIALNUM:
	        /* or possiblc 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->entPhysicalSerialNum));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_ENTPHYSICALALIAS:
	        /* or possiblc 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->entPhysicalAlias));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_ENTPHYSICALASSETID:
	        /* or possiblc 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->entPhysicalAssetID));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_ENTPHYSICALURIS:
	        /* or possiblc 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->entPhysicalUris));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;
#endif //_QNAP_SUPPORT_WRITE_
    case MODE_SET_FREE:
        break;
#if _QNAP_SUPPORT_WRITE_
    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            table_entry = (struct entPhysicalTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_ENTPHYSICALSERIALNUM:
                memcpy( table_entry->old_entPhysicalSerialNum,
                        table_entry->entPhysicalSerialNum,
                        sizeof(table_entry->entPhysicalSerialNum));
                table_entry->old_entPhysicalSerialNum_len =
                        table_entry->entPhysicalSerialNum_len;
                memset( table_entry->entPhysicalSerialNum, 0,
                        sizeof(table_entry->entPhysicalSerialNum));
                memcpy( table_entry->entPhysicalSerialNum,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->entPhysicalSerialNum_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_ENTPHYSICALALIAS:
                memcpy( table_entry->old_entPhysicalAlias,
                        table_entry->entPhysicalAlias,
                        sizeof(table_entry->entPhysicalAlias));
                table_entry->old_entPhysicalAlias_len =
                        table_entry->entPhysicalAlias_len;
                memset( table_entry->entPhysicalAlias, 0,
                        sizeof(table_entry->entPhysicalAlias));
                memcpy( table_entry->entPhysicalAlias,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->entPhysicalAlias_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_ENTPHYSICALASSETID:
                memcpy( table_entry->old_entPhysicalAssetID,
                        table_entry->entPhysicalAssetID,
                        sizeof(table_entry->entPhysicalAssetID));
                table_entry->old_entPhysicalAssetID_len =
                        table_entry->entPhysicalAssetID_len;
                memset( table_entry->entPhysicalAssetID, 0,
                        sizeof(table_entry->entPhysicalAssetID));
                memcpy( table_entry->entPhysicalAssetID,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->entPhysicalAssetID_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_ENTPHYSICALURIS:
                memcpy( table_entry->old_entPhysicalUris,
                        table_entry->entPhysicalUris,
                        sizeof(table_entry->entPhysicalUris));
                table_entry->old_entPhysicalUris_len =
                        table_entry->entPhysicalUris_len;
                memset( table_entry->entPhysicalUris, 0,
                        sizeof(table_entry->entPhysicalUris));
                memcpy( table_entry->entPhysicalUris,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->entPhysicalUris_len =
                        request->requestvb->val_len;
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct entPhysicalTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_ENTPHYSICALSERIALNUM:
                memcpy( table_entry->entPhysicalSerialNum,
                        table_entry->old_entPhysicalSerialNum,
                        sizeof(table_entry->entPhysicalSerialNum));
                memset( table_entry->old_entPhysicalSerialNum, 0,
                        sizeof(table_entry->entPhysicalSerialNum));
                table_entry->entPhysicalSerialNum_len =
                        table_entry->old_entPhysicalSerialNum_len;
                break;
            case COLUMN_ENTPHYSICALALIAS:
                memcpy( table_entry->entPhysicalAlias,
                        table_entry->old_entPhysicalAlias,
                        sizeof(table_entry->entPhysicalAlias));
                memset( table_entry->old_entPhysicalAlias, 0,
                        sizeof(table_entry->entPhysicalAlias));
                table_entry->entPhysicalAlias_len =
                        table_entry->old_entPhysicalAlias_len;
                break;
            case COLUMN_ENTPHYSICALASSETID:
                memcpy( table_entry->entPhysicalAssetID,
                        table_entry->old_entPhysicalAssetID,
                        sizeof(table_entry->entPhysicalAssetID));
                memset( table_entry->old_entPhysicalAssetID, 0,
                        sizeof(table_entry->entPhysicalAssetID));
                table_entry->entPhysicalAssetID_len =
                        table_entry->old_entPhysicalAssetID_len;
                break;
            case COLUMN_ENTPHYSICALURIS:
                memcpy( table_entry->entPhysicalUris,
                        table_entry->old_entPhysicalUris,
                        sizeof(table_entry->entPhysicalUris));
                memset( table_entry->old_entPhysicalUris, 0,
                        sizeof(table_entry->entPhysicalUris));
                table_entry->entPhysicalUris_len =
                        table_entry->old_entPhysicalUris_len;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
#endif _QNAP_SUPPORT_WRITE_
    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the entLogicalTable table by defining its contents and how it's structured */
void
initialize_table_entLogicalTable(void)
{
    static oid entLogicalTable_oid[] = {1,3,6,1,2,1,47,1,2,1};
    size_t entLogicalTable_oid_len   = OID_LENGTH(entLogicalTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    reg = netsnmp_create_handler_registration(
              "entLogicalTable",     entLogicalTable_handler,
              entLogicalTable_oid, entLogicalTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: entLogicalIndex */
                           0);
    table_info->min_column = COLUMN_ENTLOGICALDESCR;
    table_info->max_column = COLUMN_ENTLOGICALCONTEXTNAME;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = entLogicalTable_get_first_data_point;
    iinfo->get_next_data_point  = entLogicalTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
}

    /* Typical data structure for a row entry */
struct entLogicalTable_entry {
    /* Index values */
    long entLogicalIndex;

    /* Column values */
    char entLogicalDescr[128];
    size_t entLogicalDescr_len;
    oid entLogicalType[128];
    size_t entLogicalType_len;
    char entLogicalCommunity[128];
    size_t entLogicalCommunity_len;
    char entLogicalTAddress[128];
    size_t entLogicalTAddress_len;
    oid entLogicalTDomain[128];
    size_t entLogicalTDomain_len;
    char entLogicalContextEngineID[128];
    size_t entLogicalContextEngineID_len;
    char entLogicalContextName[128];
    size_t entLogicalContextName_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct entLogicalTable_entry *next;
};

struct entLogicalTable_entry  *entLogicalTable_head;

/* create a new row in the (unsorted) table */
struct entLogicalTable_entry *
entLogicalTable_createEntry(
                 long  entLogicalIndex
                ) {
    struct entLogicalTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct entLogicalTable_entry);
    if (!entry)
        return NULL;

    entry->entLogicalIndex = entLogicalIndex;
    entry->next = entLogicalTable_head;
    entLogicalTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
entLogicalTable_removeEntry( struct entLogicalTable_entry *entry ) {
    struct entLogicalTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = entLogicalTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        entLogicalTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
entLogicalTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = entLogicalTable_head;
    return entLogicalTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
entLogicalTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct entLogicalTable_entry *entry = (struct entLogicalTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->entLogicalIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the entLogicalTable table */
int
entLogicalTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct entLogicalTable_entry          *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct entLogicalTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_ENTLOGICALDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entLogicalDescr,
                                          table_entry->entLogicalDescr_len);
                break;
            case COLUMN_ENTLOGICALTYPE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OBJECT_ID,
                                 (u_char*)table_entry->entLogicalType,
                                          table_entry->entLogicalType_len);
                break;
            case COLUMN_ENTLOGICALCOMMUNITY:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entLogicalCommunity,
                                          table_entry->entLogicalCommunity_len);
                break;
            case COLUMN_ENTLOGICALTADDRESS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entLogicalTAddress,
                                          table_entry->entLogicalTAddress_len);
                break;
            case COLUMN_ENTLOGICALTDOMAIN:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OBJECT_ID,
                                 (u_char*)table_entry->entLogicalTDomain,
                                          table_entry->entLogicalTDomain_len);
                break;
            case COLUMN_ENTLOGICALCONTEXTENGINEID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entLogicalContextEngineID,
                                          table_entry->entLogicalContextEngineID_len);
                break;
            case COLUMN_ENTLOGICALCONTEXTNAME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->entLogicalContextName,
                                          table_entry->entLogicalContextName_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the entLPMappingTable table by defining its contents and how it's structured */
void
initialize_table_entLPMappingTable(void)
{
    static oid entLPMappingTable_oid[] = {1,3,6,1,2,1,47,1,3,1};
    size_t entLPMappingTable_oid_len   = OID_LENGTH(entLPMappingTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    reg = netsnmp_create_handler_registration(
              "entLPMappingTable",     entLPMappingTable_handler,
              entLPMappingTable_oid, entLPMappingTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: entLogicalIndex */
                           ASN_INTEGER,  /* index: entLPPhysicalIndex */
                           0);
    table_info->min_column = COLUMN_ENTLPPHYSICALINDEX;
    table_info->max_column = COLUMN_ENTLPPHYSICALINDEX;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = entLPMappingTable_get_first_data_point;
    iinfo->get_next_data_point  = entLPMappingTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
}

    /* Typical data structure for a row entry */
struct entLPMappingTable_entry {
    /* Index values */
    long entLogicalIndex;
    long entLPPhysicalIndex;

    /* Column values */
//??    long entLPPhysicalIndex;

    /* Illustrate using a simple linked list */
    int   valid;
    struct entLPMappingTable_entry *next;
};

struct entLPMappingTable_entry  *entLPMappingTable_head;

/* create a new row in the (unsorted) table */
struct entLPMappingTable_entry *
entLPMappingTable_createEntry(
                 long  entLogicalIndex,
                 long  entLPPhysicalIndex
                ) {
    struct entLPMappingTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct entLPMappingTable_entry);
    if (!entry)
        return NULL;

    entry->entLogicalIndex = entLogicalIndex;
    entry->entLPPhysicalIndex = entLPPhysicalIndex;
    entry->next = entLPMappingTable_head;
    entLPMappingTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
entLPMappingTable_removeEntry( struct entLPMappingTable_entry *entry ) {
    struct entLPMappingTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = entLPMappingTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        entLPMappingTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
entLPMappingTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = entLPMappingTable_head;
    return entLPMappingTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
entLPMappingTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct entLPMappingTable_entry *entry = (struct entLPMappingTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->entLogicalIndex );
        idx = idx->next_variable;
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->entLPPhysicalIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the entLPMappingTable table */
int
entLPMappingTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct entLPMappingTable_entry          *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct entLPMappingTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_ENTLPPHYSICALINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->entLPPhysicalIndex);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the entAliasMappingTable table by defining its contents and how it's structured */
void
initialize_table_entAliasMappingTable(void)
{
    static oid entAliasMappingTable_oid[] = {1,3,6,1,2,1,47,1,3,2};
    size_t entAliasMappingTable_oid_len   = OID_LENGTH(entAliasMappingTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    reg = netsnmp_create_handler_registration(
              "entAliasMappingTable",     entAliasMappingTable_handler,
              entAliasMappingTable_oid, entAliasMappingTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: entPhysicalIndex */
                           ASN_INTEGER,  /* index: entAliasLogicalIndexOrZero */
                           0);
    table_info->min_column = COLUMN_ENTALIASMAPPINGIDENTIFIER;
    table_info->max_column = COLUMN_ENTALIASMAPPINGIDENTIFIER;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = entAliasMappingTable_get_first_data_point;
    iinfo->get_next_data_point  = entAliasMappingTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
}

    /* Typical data structure for a row entry */
struct entAliasMappingTable_entry {
    /* Index values */
    long entPhysicalIndex;
    long entAliasLogicalIndexOrZero;

    /* Column values */
    oid entAliasMappingIdentifier[128];
    size_t entAliasMappingIdentifier_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct entAliasMappingTable_entry *next;
};

struct entAliasMappingTable_entry  *entAliasMappingTable_head;

/* create a new row in the (unsorted) table */
struct entAliasMappingTable_entry *
entAliasMappingTable_createEntry(
                 long  entPhysicalIndex,
                 long  entAliasLogicalIndexOrZero
                ) {
    struct entAliasMappingTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct entAliasMappingTable_entry);
    if (!entry)
        return NULL;

    entry->entPhysicalIndex = entPhysicalIndex;
    entry->entAliasLogicalIndexOrZero = entAliasLogicalIndexOrZero;
    entry->next = entAliasMappingTable_head;
    entAliasMappingTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
entAliasMappingTable_removeEntry( struct entAliasMappingTable_entry *entry ) {
    struct entAliasMappingTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = entAliasMappingTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        entAliasMappingTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
entAliasMappingTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = entAliasMappingTable_head;
    return entAliasMappingTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
entAliasMappingTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct entAliasMappingTable_entry *entry = (struct entAliasMappingTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->entPhysicalIndex );
        idx = idx->next_variable;
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->entAliasLogicalIndexOrZero );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the entAliasMappingTable table */
int
entAliasMappingTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct entAliasMappingTable_entry          *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct entAliasMappingTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_ENTALIASMAPPINGIDENTIFIER:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OBJECT_ID,
                                 (u_char*)table_entry->entAliasMappingIdentifier,
                                          table_entry->entAliasMappingIdentifier_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the entPhysicalContainsTable table by defining its contents and how it's structured */
void
initialize_table_entPhysicalContainsTable(void)
{
    static oid entPhysicalContainsTable_oid[] = {1,3,6,1,2,1,47,1,3,3};
    size_t entPhysicalContainsTable_oid_len   = OID_LENGTH(entPhysicalContainsTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    reg = netsnmp_create_handler_registration(
              "entPhysicalContainsTable",     entPhysicalContainsTable_handler,
              entPhysicalContainsTable_oid, entPhysicalContainsTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: entPhysicalIndex */
                           ASN_INTEGER,  /* index: entPhysicalChildIndex */
                           0);
    table_info->min_column = COLUMN_ENTPHYSICALCHILDINDEX;
    table_info->max_column = COLUMN_ENTPHYSICALCHILDINDEX;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = entPhysicalContainsTable_get_first_data_point;
    iinfo->get_next_data_point  = entPhysicalContainsTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
}

    /* Typical data structure for a row entry */
struct entPhysicalContainsTable_entry {
    /* Index values */
    long entPhysicalIndex;
    long entPhysicalChildIndex;

    /* Column values */
//??    long entPhysicalChildIndex;

    /* Illustrate using a simple linked list */
    int   valid;
    struct entPhysicalContainsTable_entry *next;
};

struct entPhysicalContainsTable_entry  *entPhysicalContainsTable_head;

/* create a new row in the (unsorted) table */
struct entPhysicalContainsTable_entry *
entPhysicalContainsTable_createEntry(
                 long  entPhysicalIndex,
                 long  entPhysicalChildIndex
                ) {
    struct entPhysicalContainsTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct entPhysicalContainsTable_entry);
    if (!entry)
        return NULL;

    entry->entPhysicalIndex = entPhysicalIndex;
    entry->entPhysicalChildIndex = entPhysicalChildIndex;
    entry->next = entPhysicalContainsTable_head;
    entPhysicalContainsTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
entPhysicalContainsTable_removeEntry( struct entPhysicalContainsTable_entry *entry ) {
    struct entPhysicalContainsTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = entPhysicalContainsTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        entPhysicalContainsTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
entPhysicalContainsTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = entPhysicalContainsTable_head;
    return entPhysicalContainsTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
entPhysicalContainsTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct entPhysicalContainsTable_entry *entry = (struct entPhysicalContainsTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->entPhysicalIndex );
        idx = idx->next_variable;
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->entPhysicalChildIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the entPhysicalContainsTable table */
int
entPhysicalContainsTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct entPhysicalContainsTable_entry          *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct entPhysicalContainsTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_ENTPHYSICALCHILDINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->entPhysicalChildIndex);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
