/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 17337 2009-01-01 14:28:29Z magfr $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "SystemInfo.h"
#include "common.h"




//#define SNMP_DPRINTF	printf
#define SNMP_DPRINTF(x, ...) {}


#ifdef STORAGE_V2
//hd_smart
const mapping_t smartresult_str [] = {
    {"Abnormal", 2},
    {"Normal"  , 1},
    {"Good"    , 0},
    {"Unknown" ,-1},    
};

struct pd_ref 
{
    PD_INFO pd_info;
    struct pd_ref *nextP;
};

static char * convert_byte_to_size(unsigned long long size) {
    static char size_str[64]={};
    memset(size_str, 0, sizeof(size_str));
    
    if (size >= 1152921504606846976ULL) //EB
        snprintf(size_str, 64, "%0.2f EB", (double) (size) / 1152921504606846976.0);	 	
    else if (size >= 1125899906842624ULL) //PB
        snprintf(size_str, 64, "%0.2f PB", (double) (size) / 1125899906842624.0);	
    else if (size >= 1099511627776ULL) //TB
        snprintf(size_str, 64, "%0.2f TB", (double) (size) / 1099511627776.0);	 	
    else if (size >= 1073741824ULL) //GB
        snprintf(size_str, 64, "%0.2f GB", (double) (size) / 1073741824.0);
    else if (size >= 1048576ULL) //MB
        snprintf(size_str, 64, "%.2f MB", (double) (size) / 1048576.0);
    else if (size >= 1024ULL) //KB
        snprintf(size_str, 64, "%.2f KB", (double) (size) / 1024.0);
    else
        snprintf(size_str, 64, "%lld Byte", size);

    return size_str;
}
#endif
/** Initializes the SystemInfo module */
void
init_SystemInfo(void)
{
    const oid SystemCPU_Usage_oid[] = { NAS_ROOT_OID,1 };
    const oid SystemTotalMem_oid[] = { NAS_ROOT_OID,2 };
    const oid SystemFreeMem_oid[] = { NAS_ROOT_OID,3 };
    const oid SystemUptime_oid[] = { NAS_ROOT_OID,4 };
    const oid CPU_Temperature_oid[] = { NAS_ROOT_OID,5 };
    const oid SystemTemperature_oid[] = { NAS_ROOT_OID,6 };
    const oid IfNumber_oid[] = { NAS_ROOT_OID,8 };
    const oid HdNumber_oid[] = { NAS_ROOT_OID,10 };
    const oid ModelName_oid[] = { NAS_ROOT_OID,12 };
    const oid HostName_oid[] = { NAS_ROOT_OID,13 };
    const oid SysFanNumber_oid[] = { NAS_ROOT_OID,14 };
    const oid SysVolumeNumber_oid[] = { NAS_ROOT_OID,16 };
#ifdef STORAGE_V2
    const oid JBODInfo_JBODBitmap_oid[] = { NAS_ROOT_OID,18,1 };
#endif
    
  DEBUGMSGTL(("SystemInfo", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SystemCPU-Usage", handle_SystemCPU_Usage,
                               SystemCPU_Usage_oid, OID_LENGTH(SystemCPU_Usage_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SystemTotalMem", handle_SystemTotalMem,
                               SystemTotalMem_oid, OID_LENGTH(SystemTotalMem_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SystemFreeMem", handle_SystemFreeMem,
                               SystemFreeMem_oid, OID_LENGTH(SystemFreeMem_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SystemUptime", handle_SystemUptime,
                               SystemUptime_oid, OID_LENGTH(SystemUptime_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("CPU-Temperature", handle_CPU_Temperature,
                               CPU_Temperature_oid, OID_LENGTH(CPU_Temperature_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SystemTemperature", handle_SystemTemperature,
                               SystemTemperature_oid, OID_LENGTH(SystemTemperature_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("IfNumber", handle_IfNumber,
                               IfNumber_oid, OID_LENGTH(IfNumber_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("HdNumber", handle_HdNumber,
                               HdNumber_oid, OID_LENGTH(HdNumber_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ModelName", handle_ModelName,
                               ModelName_oid, OID_LENGTH(ModelName_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("HostName", handle_HostName,
                               HostName_oid, OID_LENGTH(HostName_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SysFanNumber", handle_SysFanNumber,
                               SysFanNumber_oid, OID_LENGTH(SysFanNumber_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SysVolumeNumber", handle_SysVolumeNumber,
                               SysVolumeNumber_oid, OID_LENGTH(SysVolumeNumber_oid),
                               HANDLER_CAN_RONLY
        ));
#ifdef STORAGE_V2
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("JBODBitmap", handle_JBODBitmap,
                               JBODInfo_JBODBitmap_oid, OID_LENGTH(JBODInfo_JBODBitmap_oid),
                               HANDLER_CAN_RONLY
        ));
        

    initialize_table_JBODINFOsTable();

    SystemJBODHdTable_head = (struct SystemJBODHdTable_entry**)calloc(JBODID_COUNT, sizeof(struct SystemJBODHdTable_entry*));
    int jidx = 1;
    for(jidx = 1; jidx <= JBODID_COUNT; jidx++)
    {
        initialize_table_SystemJBODHdTable(jidx);
    }
#endif
}
#ifdef STORAGE_V2
int
handle_JBODBitmap(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    

    switch(reqinfo->mode) {

        case MODE_GET:
            {
                char string[MAX_ID_STR_LEN] = "";
                Ini_Conf_Get_Field(HAL_CONF_FILE, HAL_CONF_INDEX_SEC,"enc_bitmap", string, sizeof(string));
#if 0
                char * pch;
                pch = strrchr(string,'0x6');
                pch++;
                    snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                             (u_char *) pch/* XXX: a pointer to the scalar's data */,
                                             strlen(pch)/* XXX: the length of the data in bytes */);
#else
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                             (u_char *) string/* XXX: a pointer to the scalar's data */,
                                             strlen(string)/* XXX: the length of the data in bytes */);
#endif   
            }
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_JBODBitmap\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif



int
handle_SystemCPU_Usage(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	char string[256];
    
    switch(reqinfo->mode) {

        case MODE_GET:
	{
		FILE *fp = popen("/usr/bin/top -c 2>/dev/null", "r");
		strcpy(string, "0 %");
		if (fp) {
			while (fgets(string, sizeof(string), fp)) {
				if (strncmp(string, "CPU Usage:", 10) == 0) {
					char *ptr = string+10;
					double usage = strtod(ptr, &ptr);
					snprintf(string, sizeof(string), "%.2f %%", usage);
					break;
				}
			}
			fclose(fp);
		}
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *) string/* XXX: a pointer to the scalar's data */,
                                     strlen(string)/* XXX: the length of the data in bytes */);
	}
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SystemCPU-Usage\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SystemTotalMem(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	char string[256];
    
    switch(reqinfo->mode) {

        case MODE_GET:
	{
	        *string = 0;
		FILE *fp = fopen("/proc/meminfo", "r");
		if (fp) {
			char buff[256];
			while (fgets(buff, sizeof(buff), fp)) {
				char *ptr;
				if ((ptr = strstr(buff, "MemTotal:"))) {
					snprintf(string, sizeof(string), "%.1f MB", ((float)atol(ptr+10))/1024);
					break;
				}
			}
			fclose(fp);
		}
    	}

            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *) string/* XXX: a pointer to the scalar's data */,
                                     strlen(string)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SystemTotalMem\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SystemFreeMem(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
	char string[256];
    switch(reqinfo->mode) {

        case MODE_GET:
	{
        *string = 0;
	FILE *fp = fopen("/proc/meminfo", "r");
	if (fp) {
		char buff[256];
		float freemem = 0.0;
		float sharemem = 0.0;
		while (fgets(buff, sizeof(buff), fp)) {
			char *ptr;
			if ((ptr = strstr(buff, "MemFree:"))) {
				freemem += (float)atol(ptr+8);
			}
			else if ((ptr = strstr(buff, "Buffers:"))) {
				freemem += (float)atol(ptr+8);
			}
			else if ((ptr = strstr(buff, "Cached:"))) {
				freemem += (float)atol(ptr+7);
			}
			else if ((ptr = strstr(buff, "SReclaimable:"))) {
				freemem += (float)atol(ptr+13);
			}
			else if ((ptr = strstr(buff, "Shmem:"))) {
				sharemem += (float)atol(ptr+6);
			}
		}
		if (freemem >= sharemem) {
			freemem -= sharemem;
		}
		snprintf(string, sizeof(string), "%.1f MB", freemem/1024);
		fclose(fp);
	}
	}
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *) string/* XXX: a pointer to the scalar's data */,
                                     strlen(string)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SystemFreeMem\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SystemUptime(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
	long value = get_uptime();
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_TIMETICKS,
                                     (u_char *) &value/* XXX: a pointer to the scalar's data */,
                                     sizeof(value)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SystemUptime\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_CPU_Temperature(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
	char string[256];
    switch(reqinfo->mode) {

        case MODE_GET:
	*string = 0;
	GetOneStringFromCommand("/sbin/getsysinfo cputmp", string, sizeof(string));
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *) string/* XXX: a pointer to the scalar's data */,
                                     strlen(string)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_CPU-Temperature\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SystemTemperature(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
	char string[256];
    switch(reqinfo->mode) {

        case MODE_GET:
	*string = 0;
	GetOneStringFromCommand("/sbin/getsysinfo systmp", string, sizeof(string));
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *) string/* XXX: a pointer to the scalar's data */,
                                     strlen(string)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SystemTemperature\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_IfNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
	int value = GetNasNetworkNumber();
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *) &value/* XXX: a pointer to the scalar's data */,
                                     sizeof(value)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_IfNumber\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_HdNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
	int value = GetNasDiskNumber();
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *) &value/* XXX: a pointer to the scalar's data */,
                                     sizeof(value)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_HdNumber\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_ModelName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
	char string[256];
    switch(reqinfo->mode) {

        case MODE_GET:
	*string = 0;
	GetOneStringFromCommand("/sbin/getsysinfo model", string, sizeof(string));
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *)string /* XXX: a pointer to the scalar's data */,
                                     strlen(string)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ModelName\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_HostName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
	char string[256];
    switch(reqinfo->mode) {

        case MODE_GET:
	{
        *string = 0;
	FILE *fp = popen("/sbin/getcfg System \"Server Name\" -d \"\"", "r");
	if (fp) {
		fgets(string, sizeof(string), fp);
		fclose(fp);
	}
    	}
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *)string /* XXX: a pointer to the scalar's data */,
                                     strlen(string)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_HostName\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
int
handle_SysFanNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	int value = GetSystemFanNumber();
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *) &value/* XXX: a pointer to the scalar's data */,
                                     sizeof(value)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SysFanNumber\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
int
handle_SysVolumeNumber(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	int value = GetSystemVolumeNumber();
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *) &value/* XXX: a pointer to the scalar's data */,
                                     sizeof(value)/* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SysVolumeNumber\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

#ifdef STORAGE_V2
//JBOD info/////////////////////////////////////////////////////

void
initialize_table_JBODINFOsTable()
{
    const oid SystemJBODHdTable_oid[] = {NAS_ROOT_OID, 18, 2};
    const size_t SystemJBODHdTable_oid_len   = OID_LENGTH(SystemJBODHdTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table JBODINFOsTable\n"));

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    reg = netsnmp_create_handler_registration(
              "JBODINFOsTable",     JBODINFOsTable_handler,
              SystemJBODHdTable_oid, SystemJBODHdTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: HdIndex */
                           0);
    table_info->min_column = COLUMN_JBODID;
    table_info->max_column = COLUMN_JBODHDNUM;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );

    iinfo->get_first_data_point = JBODINFOsTable_get_first_data_point;
    iinfo->get_next_data_point  = JBODINFOsTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, IfNum = JBODID_COUNT;
	for (index = 1; index <= IfNum; index ++) {
		JBODINFOsTable_createEntry(index);
	}


}

struct JBODINFOs_entry *
JBODINFOsTable_createEntry(int JBODid) {
    struct JBODINFOs_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct JBODINFOs_entry);
    if (!entry)
        return NULL;
    entry->JBODid = JBODid;
    entry->next = JBODINFOsTable_head;
    JBODINFOsTable_head = entry;
    return entry;
}

void
JBODINFOsTable_removeEntry( struct JBODINFOs_entry *entry ) {
    struct JBODINFOs_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = JBODINFOsTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        JBODINFOsTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

netsnmp_variable_list *
JBODINFOsTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = JBODINFOsTable_head;
    return JBODINFOsTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
JBODINFOsTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct JBODINFOs_entry *entry = (struct JBODINFOs_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->JBODid );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}

int
JBODINFOsTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct JBODINFOs_entry          *table_entry;

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct JBODINFOs_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            
            case COLUMN_JBODID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
#if 0                
                if(SE_Is_Exist((int)table_entry->JBODid) == 1)
                {
                    snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->JBODid);
                }
                else
#endif                    
                {
                    int i=0, count=0;
                    
                    for(i=1;i<=8;i++)
                    {
                        if(SE_Is_Exist(i)==1 )
                            count++;

                        if ((int)table_entry->JBODid == count)
                        {
                            snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,i);
                            break;
                        }
                    }
                }

                break;
                
            case COLUMN_JBODHDNUM:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
#if 0                
                if(SE_Is_Exist((int)table_entry->JBODid) == 1)
                {
                    table_entry->hdnum = SE_Get_PD_Port_Num((int)table_entry->JBODid);
                    snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->hdnum);
                }
#endif
                {
                    int i=0, count=0;
                    
                    for(i=1;i<=8;i++)
                    {
                        if(SE_Is_Exist(i)==1 )
                            count++;

                        if ((int)table_entry->JBODid == count)
                        {
                            table_entry->hdnum = SE_Get_PD_Port_Num(i);
                            snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->hdnum);
                            break;
                        }
                    }
                }

                break;

            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

//JBOD HDD table////////////////////////////////////////////////

/** Initialize the SystemHdTable table by defining its contents and how it's structured */
void
initialize_table_SystemJBODHdTable(int JBODid)
{
    int tableid = 2 + JBODid;
    const oid SystemJBODHdTable_oid[] = {NAS_ROOT_OID, 18, tableid};
    const size_t SystemJBODHdTable_oid_len   = OID_LENGTH(SystemJBODHdTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemJBODHdTable\n"));

    char SystemJBODHdTable_str[256] = "";
    snprintf(SystemJBODHdTable_str, sizeof(SystemJBODHdTable_str), "JBODHdTable_%d", JBODid);
	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    if(JBODid == 1)
    {
    reg = netsnmp_create_handler_registration(
              SystemJBODHdTable_str,     SystemJBODHdTable_handler_1,
              SystemJBODHdTable_oid, SystemJBODHdTable_oid_len,
              HANDLER_CAN_RONLY
              );
    }
    else if(JBODid == 2)
    {
    reg = netsnmp_create_handler_registration(
              SystemJBODHdTable_str,     SystemJBODHdTable_handler_2,
              SystemJBODHdTable_oid, SystemJBODHdTable_oid_len,
              HANDLER_CAN_RONLY
              );
    }
    else if(JBODid == 3)
    {
    reg = netsnmp_create_handler_registration(
              SystemJBODHdTable_str,     SystemJBODHdTable_handler_3,
              SystemJBODHdTable_oid, SystemJBODHdTable_oid_len,
              HANDLER_CAN_RONLY
              );
    }
    else if(JBODid == 4)
    {
    reg = netsnmp_create_handler_registration(
              SystemJBODHdTable_str,     SystemJBODHdTable_handler_4,
              SystemJBODHdTable_oid, SystemJBODHdTable_oid_len,
              HANDLER_CAN_RONLY
              );
    }
    else if(JBODid == 5)
    {
    reg = netsnmp_create_handler_registration(
              SystemJBODHdTable_str,     SystemJBODHdTable_handler_5,
              SystemJBODHdTable_oid, SystemJBODHdTable_oid_len,
              HANDLER_CAN_RONLY
              );
    }
    else if(JBODid == 6)
    {
    reg = netsnmp_create_handler_registration(
              SystemJBODHdTable_str,     SystemJBODHdTable_handler_6,
              SystemJBODHdTable_oid, SystemJBODHdTable_oid_len,
              HANDLER_CAN_RONLY
              );
    }
    else if(JBODid == 7)
    {
    reg = netsnmp_create_handler_registration(
              SystemJBODHdTable_str,     SystemJBODHdTable_handler_7,
              SystemJBODHdTable_oid, SystemJBODHdTable_oid_len,
              HANDLER_CAN_RONLY
              );
    }
    else if(JBODid == 8)
    {
    reg = netsnmp_create_handler_registration(
              SystemJBODHdTable_str,     SystemJBODHdTable_handler_8,
              SystemJBODHdTable_oid, SystemJBODHdTable_oid_len,
              HANDLER_CAN_RONLY
              );
    }
    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: HdIndex */
                           ASN_INTEGER,  /* index: HdIndex */
                           0);
    table_info->min_column = COLUMN_HDINDEX;
    table_info->max_column = COLUMN_HDSMARTINFO;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    if(JBODid == 1)
    {
        iinfo->get_first_data_point = SystemJBODHdTable_get_first_data_point_1;
    }
    else if(JBODid == 2)
    {
        iinfo->get_first_data_point = SystemJBODHdTable_get_first_data_point_2;
    }
    else if(JBODid == 3)
    {
        iinfo->get_first_data_point = SystemJBODHdTable_get_first_data_point_3;
    }
    else if(JBODid == 4)
    {
        iinfo->get_first_data_point = SystemJBODHdTable_get_first_data_point_4;
    }
    else if(JBODid == 5)
    {
        iinfo->get_first_data_point = SystemJBODHdTable_get_first_data_point_5;
    }
    else if(JBODid == 6)
    {
        iinfo->get_first_data_point = SystemJBODHdTable_get_first_data_point_6;
    }
    else if(JBODid == 7)
    {
        iinfo->get_first_data_point = SystemJBODHdTable_get_first_data_point_7;
    }
    else if(JBODid == 8)
    {
        iinfo->get_first_data_point = SystemJBODHdTable_get_first_data_point_8;
    }
    iinfo->get_next_data_point  = SystemJBODHdTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, HdNum = SE_Get_PD_Port_Num(JBODid);
	for (index = 1; index <= HdNum; index ++) {
		SystemJBODHdTable_createEntry(index, JBODid);
	}
}






/* create a new row in the (unsorted) table */
struct SystemJBODHdTable_entry *
SystemJBODHdTable_createEntry(
                 long  HdIndex,
                 int JBODid
                ) {
    struct SystemJBODHdTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct SystemJBODHdTable_entry);
    if (!entry)
        return NULL;

    entry->HdIndex = HdIndex;
    entry->HdDescr_len = snprintf(entry->HdDescr, sizeof(entry->HdDescr), "HDD%d", HdIndex);
    entry->JBODid = JBODid;
    //DEBUGMSGTL(("storage:init", "initializing SystemJBODHdTable_createEntry JBODid=%d\n", JBODid));
    
    //DEBUGMSGTL(("storage:init", "initializing SystemJBODHdTable_createEntry entry->JBODid=%d\n", entry->JBODid));
    entry->next = SystemJBODHdTable_head[entry->JBODid - 1];
    SystemJBODHdTable_head[entry->JBODid - 1] = entry;
    return entry;
}

/* remove a row from the table */
void
SystemJBODHdTable_removeEntry( struct SystemJBODHdTable_entry *entry ) {
    struct SystemJBODHdTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemJBODHdTable_head[entry->JBODid - 1], prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemJBODHdTable_head[entry->JBODid - 1] = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
    
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemJBODHdTable_get_first_data_point_1(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemJBODHdTable_head[1 - 1];
    return SystemJBODHdTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemJBODHdTable_get_first_data_point_2(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemJBODHdTable_head[2 - 1];
    return SystemJBODHdTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemJBODHdTable_get_first_data_point_3(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemJBODHdTable_head[3 - 1];
    return SystemJBODHdTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemJBODHdTable_get_first_data_point_4(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemJBODHdTable_head[4 - 1];
    return SystemJBODHdTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemJBODHdTable_get_first_data_point_5(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemJBODHdTable_head[5 - 1];
    return SystemJBODHdTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemJBODHdTable_get_first_data_point_6(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemJBODHdTable_head[6 - 1];
    return SystemJBODHdTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemJBODHdTable_get_first_data_point_7(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemJBODHdTable_head[7 - 1];
    return SystemJBODHdTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemJBODHdTable_get_first_data_point_8(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemJBODHdTable_head[8 - 1];
    return SystemJBODHdTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemJBODHdTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemJBODHdTable_entry *entry = (struct SystemJBODHdTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->HdIndex );
        //snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->JBODid );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemHdTable table */
int
SystemJBODHdTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests,
    int                                JBODid) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemJBODHdTable_entry          *table_entry;

    struct pd_ref *pd_list = NULL;
    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    int _JBODid = JBODid;
    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct SystemJBODHdTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            //int _JBODid = (int)(table_entry->JBODid);

            switch (table_info->colnum) {
            case COLUMN_HDINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->HdIndex);
                break;
            case COLUMN_HDDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdDescr,
                                          table_entry->HdDescr_len);
                break;
            case COLUMN_HDTEMPERATURE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                {
                    struct smart_summary summary;
                    memset(&summary, 0, sizeof(struct smart_summary));
                    
                    if(!PD_SMART_Get_Summary(_JBODid, (int)table_entry->HdIndex, &summary))
                    {
                        unsigned char sys_tempc = (summary.temperature & 0xff);
                        unsigned char sys_tempf = CelsiusToFahrenheit(sys_tempc);
                        snprintf(table_entry->HdTemperature, sizeof(table_entry->HdTemperature), "%d C/%d F", sys_tempc, sys_tempf);
                    }
                    else
                    {
                        snprintf(table_entry->HdTemperature, sizeof(table_entry->HdTemperature), "%s", "--");
                    }
                    table_entry->HdTemperature_len = strlen(table_entry->HdTemperature);
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdTemperature,
                                          table_entry->HdTemperature_len);
                break;
            case COLUMN_HDSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                {
                    // HD_STATUS
                    PD_DEV_ID dev_id; 
                    STORAGE_STATUS disk_status;
                    dev_id = PD_MAKE_DEV_ID(_JBODid, (int)table_entry->HdIndex);
                    NAS_Disk_Get_Status(dev_id, &disk_status);
                    // if (strstr(rebuild_list, hdno_buf) && disk_status != SS_RW_ERROR)
                    // {
                        // disk_status = SS_REBUILDING_RAID;
                    // }
                    table_entry->HdStatus = disk_status;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->HdStatus);
                break;
            case COLUMN_HDMODEL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
	
                {
                    char model[256] = "";
                    if(!PD_Get_Model(_JBODid, (int)table_entry->HdIndex, model, sizeof(model)))
                    {
                        snprintf(table_entry->HdModel, sizeof(table_entry->HdModel), "%s", model);
                    }
                    else
                    {
                        snprintf(table_entry->HdModel, sizeof(table_entry->HdModel), "%s", "--");
                    }
                    table_entry->HdModel_len = strlen(table_entry->HdModel);
                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                         (u_char*)table_entry->HdModel,
                                                  table_entry->HdModel_len);
                }
		break;
            case COLUMN_HDCAPACITY:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                {
                    unsigned long long capacity_Byte, dev_capacity;
                    unsigned int dev_sector; 
                    if (!PD_Get_Capacity(_JBODid, (int)table_entry->HdIndex, &dev_capacity, &dev_sector)) {
                        capacity_Byte = dev_capacity * (unsigned long long)dev_sector;
                        
                        if ((capacity_Byte >> 20) > 33554432) {
                            capacity_Byte = 0;
                        }
                         
                        snprintf(table_entry->HdCapacity, sizeof(table_entry->HdCapacity), "%s", convert_byte_to_size(capacity_Byte));
                    }
                    else
                    {
                        snprintf(table_entry->HdCapacity, sizeof(table_entry->HdCapacity), "%s", "--");
                    }
                

                table_entry->HdCapacity_len = strlen(table_entry->HdCapacity);
                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                         (u_char*)table_entry->HdCapacity,
                                                  table_entry->HdCapacity_len);
                }
                break;
            case COLUMN_HDSMARTINFO:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                                              //system("echo 'hdd smart error' >> /tmp/log1");
                    continue;
                }
                {
                    //system("echo 'storage:hddsmart start' >> /tmp/log1");
                    DEBUGMSGTL(("storage:hddsmart", "hd num=%d\n", (int)table_entry->HdIndex));
                    int result;
                    struct smart_summary summary;
                    memset(&summary, 0, sizeof(struct smart_summary));
                    result = PD_SMART_Get_Summary(_JBODid, (int)table_entry->HdIndex, &summary);
                    if(!result)
                    {
                        snprintf(table_entry->HdSmartInfo, sizeof(table_entry->HdSmartInfo), "%s", convert_status((!result ? summary.health : -1), smartresult_str));
                        
                    }
                    else
                    {
                        snprintf(table_entry->HdSmartInfo, sizeof(table_entry->HdSmartInfo), "%s", "--");
                    }
                    DEBUGMSGTL(("storage:hddsmart", " start saving..."));
                    table_entry->HdSmartInfo_len = strlen(table_entry->HdSmartInfo);
                        snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                     (u_char*)table_entry->HdSmartInfo,
                              table_entry->HdSmartInfo_len);
                    //system("echo 'storage:hddsmart end' >> /tmp/log1");
                }

                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}


int
SystemJBODHdTable_handler_1(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {
    return SystemJBODHdTable_handler(handler,reginfo,reqinfo,requests,1);
}

int
SystemJBODHdTable_handler_2(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {
    return SystemJBODHdTable_handler(handler,reginfo,reqinfo,requests,2);
}

int
SystemJBODHdTable_handler_3(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {
    return SystemJBODHdTable_handler(handler,reginfo,reqinfo,requests,3);
}

int
SystemJBODHdTable_handler_4(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {
    return SystemJBODHdTable_handler(handler,reginfo,reqinfo,requests,4);
}

int
SystemJBODHdTable_handler_5(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {
    return SystemJBODHdTable_handler(handler,reginfo,reqinfo,requests,5);
}

int
SystemJBODHdTable_handler_6(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {
    return SystemJBODHdTable_handler(handler,reginfo,reqinfo,requests,6);
}

int
SystemJBODHdTable_handler_7(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {
    return SystemJBODHdTable_handler(handler,reginfo,reqinfo,requests,7);
}

int
SystemJBODHdTable_handler_8(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {
    return SystemJBODHdTable_handler(handler,reginfo,reqinfo,requests,8);
}

//convert string
char * convert_status(int status,const mapping_t *status_all)
{
    int i;
    for (i = 0;i < 25536 ; i++)//temply define a int max value for loop count max value
    {
        if(status == status_all[i].num)
            return status_all[i].name;
    }
    //no match found!!
    return "undefined";
}
#endif
