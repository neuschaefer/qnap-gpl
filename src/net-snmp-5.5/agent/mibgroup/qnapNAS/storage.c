/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17695 2009-07-21 12:22:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "storage.h"
#include "common.h"

#ifdef QNAP_HAL_SUPPORT
#include "err_trace.h"
#include "utils.h"
#include "ini_config.h"
#include "hal.h"
#include "raid.h"
#include "storage_man.h"
#endif 

//#define SNMP_DPRINTF	printf
#define SNMP_DPRINTF(x, ...) {}

struct SystemIfTable_entry *SystemIfTable_createEntry(long  IfIndex);
struct SystemHdTable_entry *SystemHdTable_createEntry(long  IfIndex);
struct SystemFanTable_entry *SystemFanTable_createEntry(long  IfIndex);
struct SystemVolumeTable_entry *SystemVolumeTable_createEntry(long  IfIndex);

/** Initializes the storage module */
void
init_storage(void)
{
  /* here we initialize all the tables we're planning on supporting */
	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    initialize_table_SystemIfTable();
    initialize_table_SystemHdTable();
    initialize_table_SystemFanTable();
    initialize_table_SystemVolumeTable();
}

//  # Determine the first/last column names

/** Initialize the SystemIfTable table by defining its contents and how it's structured */
void
initialize_table_SystemIfTable(void)
{
    oid SystemIfTable_oid[] = {NAS_ROOT_OID,9};
    size_t SystemIfTable_oid_len   = OID_LENGTH(SystemIfTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemIfTable\n"));
	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);

    reg = netsnmp_create_handler_registration(
              "SystemIfTable",     SystemIfTable_handler,
              SystemIfTable_oid, SystemIfTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: IfIndex */
                           0);
    table_info->min_column = COLUMN_IFINDEX;
    table_info->max_column = COLUMN_IFERRORPACKETS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemIfTable_get_first_data_point;
    iinfo->get_next_data_point  = SystemIfTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, IfNum = GetNasNetworkNumber();
	for (index = 1; index <= IfNum; index ++) {
		SystemIfTable_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemIfTable_entry {
    /* Index values */
    long IfIndex;

    /* Column values */
    long IfIndexData;
    char IfDescr[256];
    size_t IfDescr_len;
    u_long IfPacketsReceived;
    u_long IfPacketsSent;
    u_long IfErrorPackets;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemIfTable_entry *next;
};

struct SystemIfTable_entry  *SystemIfTable_head;

/* create a new row in the (unsorted) table */
struct SystemIfTable_entry *
SystemIfTable_createEntry(
                 long  IfIndex
                ) {
    struct SystemIfTable_entry *entry;

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    entry = SNMP_MALLOC_TYPEDEF(struct SystemIfTable_entry);
    if (!entry)
        return NULL;

    entry->IfIndex = IfIndex;
    entry->IfDescr_len = snprintf(entry->IfDescr, sizeof(entry->IfDescr), "eth%d", IfIndex-1);
    entry->next = SystemIfTable_head;
    SystemIfTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemIfTable_removeEntry( struct SystemIfTable_entry *entry ) {
    struct SystemIfTable_entry *ptr, *prev;

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemIfTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemIfTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

static void output_var_list(netsnmp_variable_list *put_index_data)
{
	if (!put_index_data) 
		return;
	SNMP_DPRINTF("index=%d\nOID=", put_index_data->index);
	int ip;
	for (ip = 0; ip < put_index_data->name_length; ip ++) {
		SNMP_DPRINTF("%d.", put_index_data->name[ip]);
	}
	SNMP_DPRINTF("\n");
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemIfTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
	SNMP_DPRINTF("%s(%x) begin\n", __FUNCTION__, SystemIfTable_head);
	output_var_list(put_index_data);
    *my_loop_context = SystemIfTable_head;
    return SystemIfTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemIfTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemIfTable_entry *entry = (struct SystemIfTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->IfIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemIfTable table */
int
SystemIfTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemIfTable_entry          *table_entry;
	char buff[64], string[512];

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));
	SNMP_DPRINTF("%s(%d) begin\n", __FUNCTION__, reqinfo->mode);

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
		int index = -1, col = -1;
            table_entry = (struct SystemIfTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
			SNMP_DPRINTF("table_entry=%x, table_info=%x\n", table_entry, table_info);
			if (table_entry)
				index = table_entry->IfIndex;
//				SNMP_DPRINTF("table_entry->IfIndex=%d\n", table_entry->IfIndex);
			if (table_info)
				col = table_info->colnum;
//				SNMP_DPRINTF("table_info->colnum=%d\n", table_info->colnum);
			SNMP_DPRINTF("(%d, %d)\n", index, col);
    
            switch (table_info->colnum) {
            case COLUMN_IFINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->IfIndex);
                break;
            case COLUMN_IFDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->IfDescr,
                                          table_entry->IfDescr_len);
                break;
            case COLUMN_IFPACKETSRECEIVED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }

			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/rx_packets", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfPacketsReceived = atoi(buff);
			else
				table_entry->IfPacketsReceived = 0;
			
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            table_entry->IfPacketsReceived);
                break;
            case COLUMN_IFPACKETSSENT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/tx_packets", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfPacketsSent = atoi(buff);
			else
				table_entry->IfPacketsSent = 0;

                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            table_entry->IfPacketsSent);
                break;
            case COLUMN_IFERRORPACKETS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/rx_errors", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfErrorPackets = atoi(buff);
			else
				table_entry->IfErrorPackets = 0;
			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/tx_errors", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfErrorPackets += atoi(buff);

                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            table_entry->IfErrorPackets);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the SystemHdTable table by defining its contents and how it's structured */
void
initialize_table_SystemHdTable(void)
{
    const oid SystemHdTable_oid[] = {NAS_ROOT_OID,11};
    const size_t SystemHdTable_oid_len   = OID_LENGTH(SystemHdTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemHdTable\n"));

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    reg = netsnmp_create_handler_registration(
              "SystemHdTable",     SystemHdTable_handler,
              SystemHdTable_oid, SystemHdTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: HdIndex */
                           0);
    table_info->min_column = COLUMN_HDINDEX;
    table_info->max_column = COLUMN_HDSMARTINFO;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemHdTable_get_first_data_point;
    iinfo->get_next_data_point  = SystemHdTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, HdNum = GetNasDiskNumber();
	for (index = 1; index <= HdNum; index ++) {
		SystemHdTable_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemHdTable_entry {
    /* Index values */
    long HdIndex;

    /* Column values */
    long HdIndexData;
    char HdDescr[256];
    size_t HdDescr_len;
    char HdTemperature[64];
    size_t HdTemperature_len;
    long HdStatus;
    char HdModel[64];
    size_t HdModel_len;
    char HdCapacity[64];
    size_t HdCapacity_len;
    char HdSmartInfo[64];
    size_t HdSmartInfo_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemHdTable_entry *next;
};

struct SystemHdTable_entry  *SystemHdTable_head;

/* create a new row in the (unsorted) table */
struct SystemHdTable_entry *
SystemHdTable_createEntry(
                 long  HdIndex
                ) {
    struct SystemHdTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct SystemHdTable_entry);
    if (!entry)
        return NULL;

    entry->HdIndex = HdIndex;
    entry->HdDescr_len = snprintf(entry->HdDescr, sizeof(entry->HdDescr), "HDD%d", HdIndex);
    entry->next = SystemHdTable_head;
    SystemHdTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemHdTable_removeEntry( struct SystemHdTable_entry *entry ) {
    struct SystemHdTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemHdTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemHdTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemHdTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemHdTable_head;
    return SystemHdTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemHdTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemHdTable_entry *entry = (struct SystemHdTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->HdIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemHdTable table */
int
SystemHdTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemHdTable_entry          *table_entry;

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct SystemHdTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_HDINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->HdIndex);
                break;
            case COLUMN_HDDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdDescr,
                                          table_entry->HdDescr_len);
                break;
            case COLUMN_HDTEMPERATURE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo hdtmp %d", table_entry->HdIndex);
		GetOneStringFromCommand(cmd, table_entry->HdTemperature, sizeof(table_entry->HdTemperature));
		table_entry->HdTemperature_len = strlen(table_entry->HdTemperature);
	    	}
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdTemperature,
                                          table_entry->HdTemperature_len);
                break;
            case COLUMN_HDSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
	     	{
		char buff[128];
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo hdstatus %d", table_entry->HdIndex);
		if (GetOneStringFromCommand(cmd, buff, sizeof(buff)) == 0) {
			table_entry->HdStatus = atoi(buff);
		}
		else table_entry->HdStatus = -4;	//Unknown error
    		}
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->HdStatus);
                break;
            case COLUMN_HDMODEL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
#ifndef QNAP_HAL_SUPPORT            
		char file[256];
		snprintf(file, sizeof(file), "/sys/block/sd%c/device/model", 'a'+table_entry->HdIndex-1);
		FILE *fp = fopen(file, "ro");
		if (!fp) {
			strcpy(table_entry->HdModel, "--");
		}
		else {
			fgets(table_entry->HdModel, sizeof(table_entry->HdModel), fp);
			fclose(fp);
		}
#else   /* #ifndef QNAP_HAL_SUPPORT */
        int hdindex = table_entry->HdIndex;
        int ret, enc_id = PD_ENC_ID(hdindex), port_id= PD_PORT_ID(hdindex);

        ret = PD_Get_Model(enc_id, port_id, table_entry->HdModel, sizeof(table_entry->HdModel));

        if (ret < 0)
            strcpy(table_entry->HdModel, "--");
        
        SM_TRACE(TRACE_ENTRY, "%s: hdindex=%d, model=%s.\n", __func__, hdindex, table_entry->HdModel);
        
#endif  /* #ifndef QNAP_HAL_SUPPORT */                
		table_entry->HdModel_len = strlen(table_entry->HdModel);
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdModel,
                                          table_entry->HdModel_len);
		}
		break;
            case COLUMN_HDCAPACITY:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
#ifndef QNAP_HAL_SUPPORT
		char file[256], buf[128];
		unsigned long long capBlock;
		int block_size = 512;
		snprintf(file, sizeof(file), "/sys/block/sd%c/size", 'a'+table_entry->HdIndex-1);
		FILE *fp = fopen(file, "ro");
		if (!fp) {
			strcpy(table_entry->HdCapacity, "--");
			goto WRITE_CAPACITY;
		}
		fgets(buf, sizeof(buf), fp);
		capBlock = atoll(buf);
		fclose(fp);

		snprintf(file, sizeof(file), "/sys/block/sd%c/queue/hw_sector_size", 'a'+table_entry->HdIndex-1);
		fp = fopen(file, "ro");
		if (!fp) {
			strcpy(table_entry->HdCapacity, "--");
			goto WRITE_CAPACITY;
		}
		fgets(buf, sizeof(buf), fp);
		block_size = atoll(buf);
		fclose(fp);

		unsigned long long capKB = capBlock*block_size;
		capKB >>= 10;
		if (capKB >> 10 == 0) {
			snprintf(table_entry->HdCapacity, sizeof(table_entry->HdCapacity), "%.2f KB", (double)capKB);
		}
		else if (capKB >> 20 == 0) {
			snprintf(table_entry->HdCapacity, sizeof(table_entry->HdCapacity), "%.2f MB", (double)capKB/1024);
		}
		else if (capKB >> 30 == 0) {
			snprintf(table_entry->HdCapacity, sizeof(table_entry->HdCapacity), "%.2f GB", (double)capKB/(1024*1024));
		}
		else {
			snprintf(table_entry->HdCapacity, sizeof(table_entry->HdCapacity), "%.2f TB", (double)capKB/(1024*1024*1024));
		}
#else   /* #ifndef QNAP_HAL_SUPPORT */
        int hdindex = table_entry->HdIndex;
        int enc_id = PD_ENC_ID(hdindex), port_id= PD_PORT_ID(hdindex);
        char *p = NULL;
    	char size_str[256];

        p = PD_Get_Size_Str(enc_id, port_id, SIZE_DEFAULT, size_str, sizeof(size_str));

        SM_TRACE(TRACE_ENTRY, "%s: hdindex=%d, capacity=%s.\n", __func__, hdindex, p ? size_str : "--");
        
        if (p)
            snprintf(table_entry->HdCapacity, sizeof(table_entry->HdCapacity), "%s", strstr(p, "N/A") ? "--" : p);
        else
            snprintf(table_entry->HdCapacity, sizeof(table_entry->HdCapacity), "%s", "--");            
#endif  /* #ifndef QNAP_HAL_SUPPORT */        
WRITE_CAPACITY:
		table_entry->HdCapacity_len = strlen(table_entry->HdCapacity);
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdCapacity,
                                          table_entry->HdCapacity_len);
		}
		break;
            case COLUMN_HDSMARTINFO:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo hdsmart %d", table_entry->HdIndex);
		GetOneStringFromCommand(cmd, table_entry->HdSmartInfo, sizeof(table_entry->HdSmartInfo));
		table_entry->HdSmartInfo_len = strlen(table_entry->HdSmartInfo);
	    	}
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdSmartInfo,
                                          table_entry->HdSmartInfo_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the SystemFanTable table by defining its contents and how it's structured */
void
initialize_table_SystemFanTable(void)
{
    const oid SystemFanTable_oid[] = {NAS_ROOT_OID,15};
    const size_t SystemFanTable_oid_len   = OID_LENGTH(SystemFanTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemFanTable\n"));

    reg = netsnmp_create_handler_registration(
              "SystemFanTable",     SystemFanTable_handler,
              SystemFanTable_oid, SystemFanTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: SysFanIndex */
                           0);
    table_info->min_column = COLUMN_SYSFANINDEX;
    table_info->max_column = COLUMN_SYSFANSPEED;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemFanTable_get_first_data_point;
    iinfo->get_next_data_point  = SystemFanTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, FanNum = GetSystemFanNumber();
	for (index = 1; index <= FanNum; index ++) {
		SystemFanTable_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemFanTable_entry {
    /* Index values */
    long SysFanIndex;

    /* Column values */
    long SysFanIndexData;
    char SysFanDescr[256];
    size_t SysFanDescr_len;
    char SysFanSpeed[64];
    size_t SysFanSpeed_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemFanTable_entry *next;
};

struct SystemFanTable_entry  *SystemFanTable_head;

/* create a new row in the (unsorted) table */
struct SystemFanTable_entry *
SystemFanTable_createEntry(
                 long  SysFanIndex
                ) {
    struct SystemFanTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct SystemFanTable_entry);
    if (!entry)
        return NULL;

    entry->SysFanIndex = SysFanIndex;
    entry->SysFanDescr_len = snprintf(entry->SysFanDescr, sizeof(entry->SysFanDescr), "System FAN %d", SysFanIndex);
    entry->next = SystemFanTable_head;
    SystemFanTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemFanTable_removeEntry( struct SystemFanTable_entry *entry ) {
    struct SystemFanTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemFanTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemFanTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemFanTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemFanTable_head;
    return SystemFanTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemFanTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemFanTable_entry *entry = (struct SystemFanTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->SysFanIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemFanTable table */
int
SystemFanTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemFanTable_entry          *table_entry;

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct SystemFanTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_SYSFANINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->SysFanIndex);
                break;
            case COLUMN_SYSFANDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysFanDescr,
                                          table_entry->SysFanDescr_len);
                break;
            case COLUMN_SYSFANSPEED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo sysfan %d", table_entry->SysFanIndex);
		*table_entry->SysFanSpeed = 0;
		GetOneStringFromCommand(cmd, table_entry->SysFanSpeed, sizeof(table_entry->SysFanSpeed));
		table_entry->SysFanSpeed_len = strlen(table_entry->SysFanSpeed);
		}

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysFanSpeed,
                                          table_entry->SysFanSpeed_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the SystemVolumeTable table by defining its contents and how it's structured */
void
initialize_table_SystemVolumeTable(void)
{
    const oid SystemVolumeTable_oid[] = {NAS_ROOT_OID,17};
    const size_t SystemVolumeTable_oid_len   = OID_LENGTH(SystemVolumeTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemVolumeTable\n"));

    reg = netsnmp_create_handler_registration(
              "SystemVolumeTable",     SystemVolumeTable_handler,
              SystemVolumeTable_oid, SystemVolumeTable_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: SysVolumeIndex */
                           0);
    table_info->min_column = COLUMN_SYSVOLUMEINDEX;
    table_info->max_column = COLUMN_SYSVOLUMESTATUS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemVolumeTable_get_first_data_point;
    iinfo->get_next_data_point  = SystemVolumeTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, VolumeNum = GetSystemVolumeNumber();
	for (index = 1; index <= VolumeNum; index ++) {
		SystemVolumeTable_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemVolumeTable_entry {
    /* Index values */
    long SysVolumeIndex;

    /* Column values */
    long SysVolumeIndexData;
    char SysVolumeDescr[256];
    size_t SysVolumeDescr_len;
    char SysVolumeFS[15];
    size_t SysVolumeFS_len;
    char SysVolumeTotalSize[15];
    size_t SysVolumeTotalSize_len;
    char SysVolumeFreeSize[15];
    size_t SysVolumeFreeSize_len;
    char SysVolumeStatus[256];
    size_t SysVolumeStatus_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemVolumeTable_entry *next;
};

struct SystemVolumeTable_entry  *SystemVolumeTable_head;

static int GetSystemVolumeInformString(int item, int index, char *string, int size)
{
	char cmd[512], *item_str;

	*string = 0;
	switch (item) {
	case COLUMN_SYSVOLUMEDESCR:
		item_str = "vol_desc";
		break;
	case COLUMN_SYSVOLUMEFS:
		item_str = "vol_fs";
		break;
	case COLUMN_SYSVOLUMETOTALSIZE:
		item_str = "vol_totalsize";
		break;
	case COLUMN_SYSVOLUMEFREESIZE:
		item_str = "vol_freesize";
		break;
	case COLUMN_SYSVOLUMESTATUS:
		item_str = "vol_status";
		break;
	default:
		return 0;
	}
	snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo %s %d", item_str, index-1);
	GetOneStringFromCommand(cmd, string, size);
	return strlen(string);
}

/* create a new row in the (unsorted) table */
struct SystemVolumeTable_entry *
SystemVolumeTable_createEntry(
                 long  SysVolumeIndex
                ) {
    struct SystemVolumeTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct SystemVolumeTable_entry);
    if (!entry)
        return NULL;

    entry->SysVolumeIndex = SysVolumeIndex;
    entry->next = SystemVolumeTable_head;
    SystemVolumeTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemVolumeTable_removeEntry( struct SystemVolumeTable_entry *entry ) {
    struct SystemVolumeTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemVolumeTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemVolumeTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemVolumeTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemVolumeTable_head;
    return SystemVolumeTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemVolumeTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemVolumeTable_entry *entry = (struct SystemVolumeTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->SysVolumeIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}

/** handles requests for the SystemVolumeTable table */
int
SystemVolumeTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemVolumeTable_entry          *table_entry;

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct SystemVolumeTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            if ( !table_entry ) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            switch (table_info->colnum) {
            case COLUMN_SYSVOLUMEINDEX:
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->SysVolumeIndex);
                break;
            case COLUMN_SYSVOLUMEDESCR:
		table_entry->SysVolumeDescr_len = GetSystemVolumeInformString(COLUMN_SYSVOLUMEDESCR, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeDescr, sizeof(table_entry->SysVolumeDescr));
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeDescr,
                                          table_entry->SysVolumeDescr_len);
                break;
            case COLUMN_SYSVOLUMEFS:
		   table_entry->SysVolumeFS_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, table_entry->SysVolumeFS, sizeof(table_entry->SysVolumeFS));

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeFS,
                                          table_entry->SysVolumeFS_len);
                break;
		case COLUMN_SYSVOLUMETOTALSIZE:
		   table_entry->SysVolumeTotalSize_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeTotalSize, sizeof(table_entry->SysVolumeTotalSize));

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeTotalSize,
                                          table_entry->SysVolumeTotalSize_len);
			break;
		case COLUMN_SYSVOLUMEFREESIZE:
		   table_entry->SysVolumeFreeSize_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeFreeSize, sizeof(table_entry->SysVolumeFreeSize));

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeFreeSize,
                                          table_entry->SysVolumeFreeSize_len);
			break;
		case COLUMN_SYSVOLUMESTATUS:
		   table_entry->SysVolumeStatus_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeStatus, sizeof(table_entry->SysVolumeStatus));

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeStatus,
                                          table_entry->SysVolumeStatus_len);
			break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

