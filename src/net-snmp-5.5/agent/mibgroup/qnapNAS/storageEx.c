/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17695 2009-07-21 12:22:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "storageEx.h"
#include "common.h"

#ifdef QNAP_HAL_SUPPORT
#include "err_trace.h"
#include "utils.h"
#include "ini_config.h"
#include "hal.h"
#include "raid.h"
#include "storage_man.h"
#endif 

//#define SNMP_DPRINTF	printf
#define SNMP_DPRINTF(x, ...) {}

struct SystemIfTableEx_entry *SystemIfTableEx_createEntry(long  IfIndex);
struct SystemHdTableEx_entry *SystemHdTableEx_createEntry(long  IfIndex);
struct SystemFanTableEx_entry *SystemFanTableEx_createEntry(long  IfIndex);
struct SystemVolumeTableEx_entry *SystemVolumeTableEx_createEntry(long  IfIndex);

/** Initializes the storage module */
void
init_storageEx(void)
{
  /* here we initialize all the tables we're planning on supporting */
	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    initialize_table_SystemIfTableEx();
    initialize_table_SystemHdTableEx();
    initialize_table_SystemFanTableEx();
    initialize_table_SystemVolumeTableEx();
}

//  # Determine the first/last column names

/** Initialize the SystemIfTable table by defining its contents and how it's structured */
void
initialize_table_SystemIfTableEx(void)
{
    oid SystemIfTableEx_oid[] = {NAS_EX_ROOT_OID,9};
    size_t SystemIfTableEx_oid_len   = OID_LENGTH(SystemIfTableEx_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemIfTable\n"));
	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);

    reg = netsnmp_create_handler_registration(
              "SystemIfTableEx",     SystemIfTableEx_handler,
              SystemIfTableEx_oid, SystemIfTableEx_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: IfIndex */
                           0);
    table_info->min_column = COLUMN_IFINDEX;
    table_info->max_column = COLUMN_IFERRORPACKETS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemIfTableEx_get_first_data_point;
    iinfo->get_next_data_point  = SystemIfTableEx_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, IfNum = GetNasNetworkNumber();
	for (index = 1; index <= IfNum; index ++) {
		SystemIfTableEx_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemIfTableEx_entry {
    /* Index values */
    long IfIndex;

    /* Column values */
    long IfIndexData;
    char IfDescr[256];
    size_t IfDescr_len;
    u_long IfPacketsReceived;
    u_long IfPacketsSent;
    u_long IfErrorPackets;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemIfTableEx_entry *next;
};

struct SystemIfTableEx_entry  *SystemIfTableEx_head;

/* create a new row in the (unsorted) table */
struct SystemIfTableEx_entry *
SystemIfTableEx_createEntry(
                 long  IfIndex
                ) {
    struct SystemIfTableEx_entry *entry;

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    entry = SNMP_MALLOC_TYPEDEF(struct SystemIfTableEx_entry);
    if (!entry)
        return NULL;

    entry->IfIndex = IfIndex;
    entry->IfDescr_len = snprintf(entry->IfDescr, sizeof(entry->IfDescr), "eth%d", IfIndex-1);
    entry->next = SystemIfTableEx_head;
    SystemIfTableEx_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemIfTableEx_removeEntry( struct SystemIfTableEx_entry *entry ) {
    struct SystemIfTableEx_entry *ptr, *prev;

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemIfTableEx_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemIfTableEx_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

static void output_var_list(netsnmp_variable_list *put_index_data)
{
	if (!put_index_data) 
		return;
	SNMP_DPRINTF("index=%d\nOID=", put_index_data->index);
	int ip;
	for (ip = 0; ip < put_index_data->name_length; ip ++) {
		SNMP_DPRINTF("%d.", put_index_data->name[ip]);
	}
	SNMP_DPRINTF("\n");
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemIfTableEx_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
	SNMP_DPRINTF("%s(%x) begin\n", __FUNCTION__, SystemIfTableEx_head);
	output_var_list(put_index_data);
    *my_loop_context = SystemIfTableEx_head;
    return SystemIfTableEx_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemIfTableEx_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemIfTableEx_entry *entry = (struct SystemIfTableEx_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->IfIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemIfTable table */
int
SystemIfTableEx_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemIfTableEx_entry          *table_entry;
	char buff[64], string[512];

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));
	SNMP_DPRINTF("%s(%d) begin\n", __FUNCTION__, reqinfo->mode);

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
		int index = -1, col = -1;
            table_entry = (struct SystemIfTableEx_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
			SNMP_DPRINTF("table_entry=%x, table_info=%x\n", table_entry, table_info);
			if (table_entry)
				index = table_entry->IfIndex;
//				SNMP_DPRINTF("table_entry->IfIndex=%d\n", table_entry->IfIndex);
			if (table_info)
				col = table_info->colnum;
//				SNMP_DPRINTF("table_info->colnum=%d\n", table_info->colnum);
			SNMP_DPRINTF("(%d, %d)\n", index, col);
    
            switch (table_info->colnum) {
            case COLUMN_IFINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->IfIndex);
                break;
            case COLUMN_IFDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->IfDescr,
                                          table_entry->IfDescr_len);
                break;
            case COLUMN_IFPACKETSRECEIVED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }

			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/rx_packets", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfPacketsReceived = atoi(buff);
			else
				table_entry->IfPacketsReceived = 0;
			
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            table_entry->IfPacketsReceived);
                break;
            case COLUMN_IFPACKETSSENT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/tx_packets", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfPacketsSent = atoi(buff);
			else
				table_entry->IfPacketsSent = 0;

                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            table_entry->IfPacketsSent);
                break;
            case COLUMN_IFERRORPACKETS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/rx_errors", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfErrorPackets = atoi(buff);
			else
				table_entry->IfErrorPackets = 0;
			snprintf(string, sizeof(string), "/bin/cat  /sys/class/net/%s/statistics/tx_errors", table_entry->IfDescr);
			if (GetOneStringFromCommand(string, buff, sizeof(buff)) == 0)
				table_entry->IfErrorPackets += atoi(buff);

                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            table_entry->IfErrorPackets);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the SystemHdTable table by defining its contents and how it's structured */
void
initialize_table_SystemHdTableEx(void)
{
    const oid SystemHdTableEx_oid[] = {NAS_EX_ROOT_OID,11};
    const size_t SystemHdTableEx_oid_len   = OID_LENGTH(SystemHdTableEx_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemHdTable\n"));

	SNMP_DPRINTF("%s() begin\n", __FUNCTION__);
    reg = netsnmp_create_handler_registration(
              "SystemHdTableEx",     SystemHdTableEx_handler,
              SystemHdTableEx_oid, SystemHdTableEx_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: HdIndex */
                           0);
    table_info->min_column = COLUMN_HDINDEX;
    table_info->max_column = COLUMN_HDSMARTINFO;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemHdTableEx_get_first_data_point;
    iinfo->get_next_data_point  = SystemHdTableEx_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, HdNum = GetNasDiskNumber();
	for (index = 1; index <= HdNum; index ++) {
		SystemHdTableEx_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemHdTableEx_entry {
    /* Index values */
    long HdIndex;

    /* Column values */
    long HdIndexData;
    char HdDescr[256];
    size_t HdDescr_len;
    char HdTemperature[64];
    size_t HdTemperature_len;
    long HdStatus;
    char HdModel[64];
    size_t HdModel_len;
    char HdCapacity[64];
    size_t HdCapacity_len;
    char HdSmartInfo[64];
    size_t HdSmartInfo_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemHdTableEx_entry *next;
};

struct SystemHdTableEx_entry  *SystemHdTableEx_head;

/* create a new row in the (unsorted) table */
struct SystemHdTableEx_entry *
SystemHdTableEx_createEntry(
                 long  HdIndex
                ) {
    struct SystemHdTableEx_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct SystemHdTableEx_entry);
    if (!entry)
        return NULL;

    entry->HdIndex = HdIndex;
    entry->HdDescr_len = snprintf(entry->HdDescr, sizeof(entry->HdDescr), "HDD%d", HdIndex);
    entry->next = SystemHdTableEx_head;
    SystemHdTableEx_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemHdTableEx_removeEntry( struct SystemHdTableEx_entry *entry ) {
    struct SystemHdTableEx_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemHdTableEx_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemHdTableEx_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemHdTableEx_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemHdTableEx_head;
    return SystemHdTableEx_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemHdTableEx_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemHdTableEx_entry *entry = (struct SystemHdTableEx_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->HdIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemHdTable table */
int
SystemHdTableEx_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemHdTableEx_entry          *table_entry;

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct SystemHdTableEx_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
			DEBUGMSGTL(("SystemHdTableEx_handler", "table_entry(%p), table_info(%p)\n", table_entry, table_info));
			if ( !table_entry || !table_info ) {
				netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}
			DEBUGMSGTL(("SystemHdTableEx_handler", "colnum(%d)\n", table_info->colnum));
            switch (table_info->colnum) {
            case COLUMN_HDINDEX:
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->HdIndex);
                break;
            case COLUMN_HDDESCR:
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdDescr,
                                          table_entry->HdDescr_len);
                break;
            case COLUMN_HDTEMPERATURE:
		{
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo hdtmp %d", table_entry->HdIndex);
		GetOneStringFromCommand(cmd, table_entry->HdTemperature, sizeof(table_entry->HdTemperature));
		table_entry->HdTemperature_len = strlen(table_entry->HdTemperature);
	    	}
		snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, atoi(table_entry->HdTemperature));
                break;
            case COLUMN_HDSTATUS:
	     	{
		char buff[128];
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo hdstatus %d", table_entry->HdIndex);
		if (GetOneStringFromCommand(cmd, buff, sizeof(buff)) == 0) {
			table_entry->HdStatus = atoi(buff);
		}
		else table_entry->HdStatus = -4;	//Unknown error
    		}
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->HdStatus);
                break;
            case COLUMN_HDMODEL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
#ifndef QNAP_HAL_SUPPORT            
		char file[256];
		snprintf(file, sizeof(file), "/sys/block/sd%c/device/model", 'a'+table_entry->HdIndex-1);
		FILE *fp = fopen(file, "ro");
		if (!fp) {
			strcpy(table_entry->HdModel, "--");
		}
		else {
			fgets(table_entry->HdModel, sizeof(table_entry->HdModel), fp);
			fclose(fp);
		}
#else   /* #ifndef QNAP_HAL_SUPPORT */
        int hdindex = table_entry->HdIndex;
        int ret, enc_id = PD_ENC_ID(hdindex), port_id= PD_PORT_ID(hdindex);

        ret = PD_Get_Model(enc_id, port_id, table_entry->HdModel, sizeof(table_entry->HdModel));

        if (ret < 0)
            strcpy(table_entry->HdModel, "--");
        
        SM_TRACE(TRACE_ENTRY, "%s: hdindex=%d, model=%s.\n", __func__, hdindex, table_entry->HdModel);
        
#endif  /* #ifndef QNAP_HAL_SUPPORT */                
		table_entry->HdModel_len = strlen(table_entry->HdModel);
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdModel,
                                          table_entry->HdModel_len);
		}
		break;
            case COLUMN_HDCAPACITY:
		{
		unsigned long long hd_cap = 0;
#ifndef QNAP_HAL_SUPPORT
		char file[256], buf[128];
		unsigned long long capBlock;
		int block_size = 512;
		snprintf(file, sizeof(file), "/sys/block/sd%c/size", 'a'+table_entry->HdIndex-1);
		FILE *fp = fopen(file, "ro");
		if (!fp) {
			strcpy(table_entry->HdCapacity, "0");
			goto WRITE_CAPACITY;
		}
		fgets(buf, sizeof(buf), fp);
		capBlock = atoll(buf);
		fclose(fp);

		snprintf(file, sizeof(file), "/sys/block/sd%c/queue/hw_sector_size", 'a'+table_entry->HdIndex-1);
		fp = fopen(file, "ro");
		if (!fp) {
			strcpy(table_entry->HdCapacity, "0");
			goto WRITE_CAPACITY;
		}
		fgets(buf, sizeof(buf), fp);
		block_size = atoll(buf);
		fclose(fp);

		hd_cap = capBlock*block_size;
#else   /* #ifndef QNAP_HAL_SUPPORT */
        int hdindex = table_entry->HdIndex;
        int enc_id = PD_ENC_ID(hdindex), port_id= PD_PORT_ID(hdindex);
	unsigned long long sectors = 0, sector_size = 0;
	PD_Get_Capacity(enc_id, port_id, &sectors, &sector_size);
	hd_cap = sector_size*sectors;
#endif  /* #ifndef QNAP_HAL_SUPPORT */        
WRITE_CAPACITY:
//		table_entry->HdCapacity_len = strlen(table_entry->HdCapacity);
		table_entry->HdCapacity_len = sizeof(hd_cap);
		DEBUGMSGTL(("SystemHdTableEx_handler:COLUMN_HDCAPACITY", "hd_cap(%llu, %d)\n", hd_cap, sizeof(hd_cap)));
			qnap_set_var_counter64(request->requestvb, hd_cap);
		}
		break;
            case COLUMN_HDSMARTINFO:
		{
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo hdsmart %d", table_entry->HdIndex);
		GetOneStringFromCommand(cmd, table_entry->HdSmartInfo, sizeof(table_entry->HdSmartInfo));
		table_entry->HdSmartInfo_len = strlen(table_entry->HdSmartInfo);
	    	}
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->HdSmartInfo,
                                          table_entry->HdSmartInfo_len);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
//  # Determine the first/last column names

/** Initialize the SystemFanTable table by defining its contents and how it's structured */
void
initialize_table_SystemFanTableEx(void)
{
    const oid SystemFanTableEx_oid[] = {NAS_EX_ROOT_OID,15};
    const size_t SystemFanTableEx_oid_len   = OID_LENGTH(SystemFanTableEx_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemFanTable\n"));

    reg = netsnmp_create_handler_registration(
              "SystemFanTableEx",     SystemFanTableEx_handler,
              SystemFanTableEx_oid, SystemFanTableEx_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: SysFanIndex */
                           0);
    table_info->min_column = COLUMN_SYSFANINDEX;
    table_info->max_column = COLUMN_SYSFANSPEED;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemFanTableEx_get_first_data_point;
    iinfo->get_next_data_point  = SystemFanTableEx_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, FanNum = GetSystemFanNumber();
	for (index = 1; index <= FanNum; index ++) {
		SystemFanTableEx_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemFanTableEx_entry {
    /* Index values */
    long SysFanIndex;

    /* Column values */
    long SysFanIndexData;
    char SysFanDescr[256];
    size_t SysFanDescr_len;
    char SysFanSpeed[64];
    size_t SysFanSpeed_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemFanTableEx_entry *next;
};

struct SystemFanTableEx_entry  *SystemFanTableEx_head;

/* create a new row in the (unsorted) table */
struct SystemFanTableEx_entry *
SystemFanTableEx_createEntry(
                 long  SysFanIndex
                ) {
    struct SystemFanTableEx_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct SystemFanTableEx_entry);
    if (!entry)
        return NULL;

    entry->SysFanIndex = SysFanIndex;
    entry->SysFanDescr_len = snprintf(entry->SysFanDescr, sizeof(entry->SysFanDescr), "System FAN %d", SysFanIndex);
    entry->next = SystemFanTableEx_head;
    SystemFanTableEx_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemFanTableEx_removeEntry( struct SystemFanTableEx_entry *entry ) {
    struct SystemFanTableEx_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemFanTableEx_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemFanTableEx_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemFanTableEx_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemFanTableEx_head;
    return SystemFanTableEx_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemFanTableEx_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemFanTableEx_entry *entry = (struct SystemFanTableEx_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->SysFanIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the SystemFanTable table */
int
SystemFanTableEx_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemFanTableEx_entry          *table_entry;
	int value = 0;

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct SystemFanTableEx_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_SYSFANINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->SysFanIndex);
                break;
            case COLUMN_SYSFANDESCR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysFanDescr,
                                          table_entry->SysFanDescr_len);
                break;
            case COLUMN_SYSFANSPEED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
		{
		char cmd[512];
		snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo sysfan %d", table_entry->SysFanIndex);
		*table_entry->SysFanSpeed = 0;
		GetOneStringFromCommand(cmd, table_entry->SysFanSpeed, sizeof(table_entry->SysFanSpeed));
		table_entry->SysFanSpeed_len = strlen(table_entry->SysFanSpeed);
		}
		value = atoi(table_entry->SysFanSpeed);
		snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER, value);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the SystemVolumeTable table by defining its contents and how it's structured */
void
initialize_table_SystemVolumeTableEx(void)
{
    const oid SystemVolumeTableEx_oid[] = {NAS_EX_ROOT_OID,17};
    const size_t SystemVolumeTableEx_oid_len   = OID_LENGTH(SystemVolumeTableEx_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("storage:init", "initializing table SystemVolumeTable\n"));

    reg = netsnmp_create_handler_registration(
              "SystemVolumeTableEx",     SystemVolumeTableEx_handler,
              SystemVolumeTableEx_oid, SystemVolumeTableEx_oid_len,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: SysVolumeIndex */
                           0);
    table_info->min_column = COLUMN_SYSVOLUMEINDEX;
    table_info->max_column = COLUMN_SYSVOLUMESTATUS;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = SystemVolumeTableEx_get_first_data_point;
    iinfo->get_next_data_point  = SystemVolumeTableEx_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
	int index, VolumeNum = GetSystemVolumeNumber();
	for (index = 1; index <= VolumeNum; index ++) {
		SystemVolumeTableEx_createEntry(index);
	}
}

    /* Typical data structure for a row entry */
struct SystemVolumeTableEx_entry {
    /* Index values */
    long SysVolumeIndex;

    /* Column values */
    long SysVolumeIndexData;
    char SysVolumeDescr[256];
    size_t SysVolumeDescr_len;
    char SysVolumeFS[15];
    size_t SysVolumeFS_len;
    char SysVolumeTotalSize[15];
    size_t SysVolumeTotalSize_len;
    char SysVolumeFreeSize[15];
    size_t SysVolumeFreeSize_len;
    char SysVolumeStatus[256];
    size_t SysVolumeStatus_len;

    /* Illustrate using a simple linked list */
    int   valid;
    struct SystemVolumeTableEx_entry *next;
};

struct SystemVolumeTableEx_entry  *SystemVolumeTableEx_head;

static int GetSystemVolumeInformString(int item, int index, char *string, int size)
{
	char cmd[512], *item_str;

	*string = 0;
	switch (item) {
	case COLUMN_SYSVOLUMEDESCR:
		item_str = "vol_desc";
		break;
	case COLUMN_SYSVOLUMEFS:
		item_str = "vol_fs";
		break;
	case COLUMN_SYSVOLUMETOTALSIZE:
		item_str = "vol_totalbytes";
		break;
	case COLUMN_SYSVOLUMEFREESIZE:
		item_str = "vol_freebytes";
		break;
	case COLUMN_SYSVOLUMESTATUS:
		item_str = "vol_status";
		break;
	default:
		return 0;
	}
	snprintf(cmd, sizeof(cmd), "/sbin/getsysinfo %s %d", item_str, index-1);
	GetOneStringFromCommand(cmd, string, size);
	return strlen(string);
}

/* create a new row in the (unsorted) table */
struct SystemVolumeTableEx_entry *
SystemVolumeTableEx_createEntry(
                 long  SysVolumeIndex
                ) {
    struct SystemVolumeTableEx_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct SystemVolumeTableEx_entry);
    if (!entry)
        return NULL;

    entry->SysVolumeIndex = SysVolumeIndex;
    entry->next = SystemVolumeTableEx_head;
    SystemVolumeTableEx_head = entry;
    return entry;
}

/* remove a row from the table */
void
SystemVolumeTableEx_removeEntry( struct SystemVolumeTableEx_entry *entry ) {
    struct SystemVolumeTableEx_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = SystemVolumeTableEx_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        SystemVolumeTableEx_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
SystemVolumeTableEx_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = SystemVolumeTableEx_head;
    return SystemVolumeTableEx_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
SystemVolumeTableEx_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct SystemVolumeTableEx_entry *entry = (struct SystemVolumeTableEx_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->SysVolumeIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}

/** handles requests for the SystemVolumeTable table */
int
SystemVolumeTableEx_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct SystemVolumeTableEx_entry          *table_entry;
	unsigned long long value = 0;

    DEBUGMSGTL(("storage:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct SystemVolumeTableEx_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            if ( !table_entry ) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            switch (table_info->colnum) {
            case COLUMN_SYSVOLUMEINDEX:
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->SysVolumeIndex);
                break;
            case COLUMN_SYSVOLUMEDESCR:
		table_entry->SysVolumeDescr_len = GetSystemVolumeInformString(COLUMN_SYSVOLUMEDESCR, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeDescr, sizeof(table_entry->SysVolumeDescr));
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeDescr,
                                          table_entry->SysVolumeDescr_len);
                break;
            case COLUMN_SYSVOLUMEFS:
		   table_entry->SysVolumeFS_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, table_entry->SysVolumeFS, sizeof(table_entry->SysVolumeFS));

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeFS,
                                          table_entry->SysVolumeFS_len);
                break;
		case COLUMN_SYSVOLUMETOTALSIZE:
			table_entry->SysVolumeTotalSize_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, 
			   	table_entry->SysVolumeTotalSize, sizeof(table_entry->SysVolumeTotalSize));
			value = atoll(table_entry->SysVolumeTotalSize);
			qnap_set_var_counter64(request->requestvb, value);
			break;
		case COLUMN_SYSVOLUMEFREESIZE:
		   table_entry->SysVolumeFreeSize_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeFreeSize, sizeof(table_entry->SysVolumeFreeSize));

			value = atoll(table_entry->SysVolumeFreeSize);
			qnap_set_var_counter64(request->requestvb, value);
			break;
		case COLUMN_SYSVOLUMESTATUS:
		   table_entry->SysVolumeStatus_len = GetSystemVolumeInformString(table_info->colnum, table_entry->SysVolumeIndex, 
		   	table_entry->SysVolumeStatus, sizeof(table_entry->SysVolumeStatus));

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->SysVolumeStatus,
                                          table_entry->SysVolumeStatus_len);
			break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}

