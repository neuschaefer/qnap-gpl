diff -urN ./iscsi_tcp.c ../../open-iscsi-2.0-871/kernel/iscsi_tcp.c
--- ./iscsi_tcp.c	2009-10-02 19:35:08.000000000 +0800
+++ ../../open-iscsi-2.0-871/kernel/iscsi_tcp.c	2012-04-05 20:15:54.000000000 +0800
@@ -25,6 +25,7 @@
  *	Arne Redlich
  *	Zhenyu Wang
  */
+#include <linux/module.h>
 #include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
diff -urN ./libiscsi.c ../../open-iscsi-2.0-871/kernel/libiscsi.c
--- ./libiscsi.c	2010-10-01 19:32:25.000000000 +0800
+++ ../../open-iscsi-2.0-871/kernel/libiscsi.c	2012-04-05 20:15:50.000000000 +0800
@@ -21,6 +21,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
+#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/kfifo.h>
 #include <linux/delay.h>
@@ -432,7 +433,7 @@
 	if (conn->login_task == task)
 		return;
 
-	__kfifo_put(session->cmdpool.queue, (void*)&task, sizeof(void*));
+	kfifo_in(session->cmdpool.queue, (void*)&task, sizeof(void*)); 
 
 	if (sc) {
 		task->sc = NULL;
@@ -618,7 +619,7 @@
 		BUG_ON(conn->c_stage == ISCSI_CONN_INITIAL_STAGE);
 		BUG_ON(conn->c_stage == ISCSI_CONN_STOPPED);
 
-		if (!__kfifo_get(session->cmdpool.queue,
+		if (!kfifo_out(session->cmdpool.queue, 
 				 (void*)&task, sizeof(void*)))
 			return NULL;
 	}
@@ -1389,7 +1390,7 @@
 {
 	struct iscsi_task *task;
 
-	if (!__kfifo_get(conn->session->cmdpool.queue,
+	if (!kfifo_out(conn->session->cmdpool.queue, 
 			 (void *) &task, sizeof(void *)))
 		return NULL;
 
@@ -2138,7 +2139,7 @@
 
 /*
  * Pre-allocate a pool of @max items of @item_size. By default, the pool
- * should be accessed via kfifo_{get,put} on q->queue.
+ * should be accessed via kfifo_{in,out} on q->queue. 
  * Optionally, the caller can obtain the array of object pointers
  * by passing in a non-NULL @items pointer
  */
@@ -2159,8 +2160,12 @@
 	if (q->pool == NULL)
 		return -ENOMEM;
 
-	q->queue = kfifo_init((void*)q->pool, max * sizeof(void*),
-			      GFP_KERNEL, NULL);
+	q->queue = kmalloc(sizeof(struct kfifo), GFP_KERNEL); 
+	if (IS_ERR(q->queue)) {
+		kfree(q->pool);
+		return -ENOMEM;
+	}
+	kfifo_init(q->queue, (void*)q->pool, max * sizeof(void*));
 	if (IS_ERR(q->queue)) {
 		q->queue = NULL;
 		goto enomem;
@@ -2172,7 +2177,7 @@
 			q->max = i;
 			goto enomem;
 		}
-		__kfifo_put(q->queue, (void*)&q->pool[i], sizeof(void*));
+		kfifo_in(q->queue, (void*)&q->pool[i], sizeof(void*)); 
 	}
 
 	if (items) {
@@ -2520,7 +2525,7 @@
 
 	/* allocate login_task used for the login/text sequences */
 	spin_lock_bh(&session->lock);
-	if (!__kfifo_get(session->cmdpool.queue,
+	if (!kfifo_out(session->cmdpool.queue,
                          (void*)&conn->login_task,
 			 sizeof(void*))) {
 		spin_unlock_bh(&session->lock);
@@ -2540,7 +2545,7 @@
 	return cls_conn;
 
 login_task_data_alloc_fail:
-	__kfifo_put(session->cmdpool.queue, (void*)&conn->login_task,
+	kfifo_in(session->cmdpool.queue, (void*)&conn->login_task,
 		    sizeof(void*));
 login_task_alloc_fail:
 	iscsi_destroy_conn(cls_conn);
@@ -2603,7 +2608,7 @@
 	free_pages((unsigned long) conn->data,
 		   get_order(ISCSI_DEF_MAX_RECV_SEG_LEN));
 	kfree(conn->persistent_address);
-	__kfifo_put(session->cmdpool.queue, (void*)&conn->login_task,
+	kfifo_in(session->cmdpool.queue, (void*)&conn->login_task, 
 		    sizeof(void*));
 	if (session->leadconn == conn)
 		session->leadconn = NULL;
diff -urN ./libiscsi_tcp.c ../../open-iscsi-2.0-871/kernel/libiscsi_tcp.c
--- ./libiscsi_tcp.c	2009-10-02 16:31:28.000000000 +0800
+++ ../../open-iscsi-2.0-871/kernel/libiscsi_tcp.c	2012-04-05 20:15:52.000000000 +0800
@@ -25,7 +25,7 @@
  *	Arne Redlich
  *	Zhenyu Wang
  */
-
+#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/list.h>
 #include <linux/inet.h>
@@ -445,15 +445,15 @@
 		return;
 
 	/* flush task's r2t queues */
-	while (__kfifo_get(tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {
-		__kfifo_put(tcp_task->r2tpool.queue, (void*)&r2t,
+	while (kfifo_out(tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {
+		kfifo_in(tcp_task->r2tpool.queue, (void*)&r2t, 
 			    sizeof(void*));
 		ISCSI_DBG_TCP(task->conn, "pending r2t dropped\n");
 	}
 
 	r2t = tcp_task->r2t;
 	if (r2t != NULL) {
-		__kfifo_put(tcp_task->r2tpool.queue, (void*)&r2t,
+		kfifo_in(tcp_task->r2tpool.queue, (void*)&r2t, 
 			    sizeof(void*));
 		tcp_task->r2t = NULL;
 	}
@@ -541,7 +541,7 @@
 		return 0;
 	}
 
-	rc = __kfifo_get(tcp_task->r2tpool.queue, (void*)&r2t, sizeof(void*));
+	rc = kfifo_out(tcp_task->r2tpool.queue, (void*)&r2t, sizeof(void*)); 
 	if (!rc) {
 		iscsi_conn_printk(KERN_ERR, conn, "Could not allocate R2T. "
 				  "Target has sent more R2Ts than it "
@@ -554,7 +554,7 @@
 	if (r2t->data_length == 0) {
 		iscsi_conn_printk(KERN_ERR, conn,
 				  "invalid R2T with zero data len\n");
-		__kfifo_put(tcp_task->r2tpool.queue, (void*)&r2t,
+		kfifo_in(tcp_task->r2tpool.queue, (void*)&r2t, 
 			    sizeof(void*));
 		return ISCSI_ERR_DATALEN;
 	}
@@ -570,7 +570,7 @@
 				  "invalid R2T with data len %u at offset %u "
 				  "and total length %d\n", r2t->data_length,
 				  r2t->data_offset, scsi_out(task->sc)->length);
-		__kfifo_put(tcp_task->r2tpool.queue, (void*)&r2t,
+		kfifo_in(tcp_task->r2tpool.queue, (void*)&r2t,
 			    sizeof(void*));
 		return ISCSI_ERR_DATALEN;
 	}
@@ -580,7 +580,7 @@
 	r2t->sent = 0;
 
 	tcp_task->exp_datasn = r2tsn + 1;
-	__kfifo_put(tcp_task->r2tqueue, (void*)&r2t, sizeof(void*));
+	kfifo_in(tcp_task->r2tqueue, (void*)&r2t, sizeof(void*));
 	conn->r2t_pdus_cnt++;
 
 	iscsi_requeue_task(task);
@@ -951,7 +951,7 @@
 		return conn->session->tt->init_pdu(task, 0, task->data_count);
 	}
 
-	BUG_ON(__kfifo_len(tcp_task->r2tqueue));
+	BUG_ON(kfifo_len(tcp_task->r2tqueue));
 	tcp_task->exp_datasn = 0;
 
 	/* Prepare PDU, optionally w/ immediate data */
@@ -982,7 +982,7 @@
 			if (r2t->data_length <= r2t->sent) {
 				ISCSI_DBG_TCP(task->conn,
 					      "  done with r2t %p\n", r2t);
-				__kfifo_put(tcp_task->r2tpool.queue,
+				kfifo_in(tcp_task->r2tpool.queue,
 					    (void *)&tcp_task->r2t,
 					    sizeof(void *));
 				tcp_task->r2t = r2t = NULL;
@@ -990,7 +990,7 @@
 		}
 
 		if (r2t == NULL) {
-			__kfifo_get(tcp_task->r2tqueue,
+			kfifo_out(tcp_task->r2tqueue,
 				    (void *)&tcp_task->r2t, sizeof(void *));
 			r2t = tcp_task->r2t;
 		}
@@ -1105,6 +1105,7 @@
 {
 	int i;
 	int cmd_i;
+	int alloc_ret;
 
 	/*
 	 * initialize per-task: R2T pool and xmit queue
@@ -1127,9 +1128,13 @@
 		}
 
 		/* R2T xmit queue */
-		tcp_task->r2tqueue = kfifo_alloc(
-		      session->max_r2t * 4 * sizeof(void*), GFP_KERNEL, NULL);
-		if (tcp_task->r2tqueue == ERR_PTR(-ENOMEM)) {
+		tcp_task->r2tqueue = kmalloc(sizeof(struct kfifo), GFP_KERNEL); 
+		if (IS_ERR(tcp_task->r2tqueue)) 
+			goto r2t_alloc_fail; 
+		alloc_ret = kfifo_alloc(tcp_task->r2tqueue, 
+		session->max_r2t * 4 * sizeof(void*), GFP_KERNEL); 
+		if (alloc_ret == -ENOMEM) { 
+			kfree(tcp_task->r2tqueue); 
 			iscsi_pool_free(&tcp_task->r2tpool);
 			goto r2t_alloc_fail;
 		}
