2c2,3
<    Copyright (C) 2001, 2002 Free Software Foundation, Inc.
---
>    Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
>    Free Software Foundation, Inc.
8c9
< the Free Software Foundation; either version 2 of the License, or
---
> the Free Software Foundation; either version 3 of the License, or
17,18c18
< along with Wget; if not, write to the Free Software
< Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
---
> along with Wget.  If not, see <http://www.gnu.org/licenses/>.
20,28c20,29
< In addition, as a special exception, the Free Software Foundation
< gives permission to link the code of its release of Wget with the
< OpenSSL project's "OpenSSL" library (or with modified versions of it
< that use the same license as the "OpenSSL" library), and distribute
< the linked executables.  You must obey the GNU General Public License
< in all respects for all of the code used other than "OpenSSL".  If you
< modify this file, you may extend this exception to your version of the
< file, but you are not obligated to do so.  If you do not wish to do
< so, delete this exception statement from your version.  */
---
> Additional permission under GNU GPL version 3 section 7
> 
> If you modify this program, or any covered work, by linking or
> combining it with the OpenSSL project's OpenSSL library (or a
> modified version of that library), containing parts covered by the
> terms of the OpenSSL or SSLeay licenses, the Free Software Foundation
> grants you additional permission to convey the resulting work.
> Corresponding Source for a non-source form of such a combination
> shall include the source code for the parts of OpenSSL used as well
> as that of the covered work.  */
34,38c35
< #ifdef HAVE_STRING_H
< # include <string.h>
< #else
< # include <strings.h>
< #endif /* HAVE_STRING_H */
---
> #include <string.h>
43,44c40,42
< #ifdef HAVE_SIGNAL_H
< # include <signal.h>
---
> #include <signal.h>
> #ifdef HAVE_WCHAR_H
> # include <wchar.h>
54,58c52,56
<   int interactive;
<   void *(*create) PARAMS ((wgint, wgint));
<   void (*update) PARAMS ((void *, wgint, double));
<   void (*finish) PARAMS ((void *, double));
<   void (*set_params) PARAMS ((const char *));
---
>   bool interactive;
>   void *(*create) (wgint, wgint);
>   void (*update) (void *, wgint, double);
>   void (*finish) (void *, double);
>   void (*set_params) (const char *);
63,71c61,69
< static void *dot_create PARAMS ((wgint, wgint));
< static void dot_update PARAMS ((void *, wgint, double));
< static void dot_finish PARAMS ((void *, double));
< static void dot_set_params PARAMS ((const char *));
< 
< static void *bar_create PARAMS ((wgint, wgint));
< static void bar_update PARAMS ((void *, wgint, double));
< static void bar_finish PARAMS ((void *, double));
< static void bar_set_params PARAMS ((const char *));
---
> static void *dot_create (wgint, wgint);
> static void dot_update (void *, wgint, double);
> static void dot_finish (void *, double);
> static void dot_set_params (const char *);
> 
> static void *bar_create (wgint, wgint);
> static void bar_update (void *, wgint, double);
> static void bar_finish (void *, double);
> static void bar_set_params (const char *);
85c83
< /* Fallnback progress implementation should be something that works
---
> /* Fallback progress implementation should be something that works
93,94c91,92
< /* Return non-zero if NAME names a valid progress bar implementation.
<    The characters after the first : will be ignored.  */
---
> /* Return true if NAME names a valid progress bar implementation.  The
>    characters after the first : will be ignored.  */
96c94
< int
---
> bool
106,107c104,105
<       return 1;
<   return 0;
---
>       return true;
>   return false;
117c115
<   char *colon;
---
>   const char *colon;
128,129c126,127
< 	current_impl = pi;
< 	current_impl_locked = 0;
---
>         current_impl = pi;
>         current_impl_locked = 0;
131,139c129,137
< 	if (colon)
< 	  /* We call pi->set_params even if colon is NULL because we
< 	     want to give the implementation a chance to set up some
< 	     things it needs to run.  */
< 	  ++colon;
< 
< 	if (pi->set_params)
< 	  pi->set_params (colon);
< 	return;
---
>         if (colon)
>           /* We call pi->set_params even if colon is NULL because we
>              want to give the implementation a chance to set up some
>              things it needs to run.  */
>           ++colon;
> 
>         if (pi->set_params)
>           pi->set_params (colon);
>         return;
165c163
< 	set_progress_implementation (FALLBACK_PROGRESS_IMPLEMENTATION);
---
>         set_progress_implementation (FALLBACK_PROGRESS_IMPLEMENTATION);
172,175c170,173
< /* Return non-zero if the progress gauge is "interactive", i.e. if it
<    can profit from being called regularly even in absence of data.
<    The progress bar is interactive because it regularly updates the
<    ETA and current update.  */
---
> /* Return true if the progress gauge is "interactive", i.e. if it can
>    profit from being called regularly even in absence of data.  The
>    progress bar is interactive because it regularly updates the ETA
>    and current update.  */
177c175
< int
---
> bool
184c182
<    time in milliseconds since the beginning of the download.  */
---
>    time since the beginning of the download.  */
204,207c202,208
<   wgint initial_length;		/* how many bytes have been downloaded
< 				   previously. */
<   wgint total_length;		/* expected total byte count when the
< 				   download finishes */
---
>   wgint initial_length;         /* how many bytes have been downloaded
>                                    previously. */
>   wgint total_length;           /* expected total byte count when the
>                                    download finishes */
> 
>   int accumulated;              /* number of bytes accumulated after
>                                    the last printed dot */
209c210,211
<   int accumulated;
---
>   int rows;                     /* number of rows printed so far */
>   int dots;                     /* number of dots printed in this row */
211,212d212
<   int rows;			/* number of rows printed so far */
<   int dots;			/* number of dots printed in this row */
228c228
<       wgint row_bytes = opt.dot_bytes * opt.dots_in_line;
---
>       const wgint ROW_BYTES = opt.dot_bytes * opt.dots_in_line;
230c230
<       int remainder = (int) (dp->initial_length % row_bytes);
---
>       int remainder = dp->initial_length % ROW_BYTES;
234,245c234,246
< 	{
< 	  int skipped_k = (int) (skipped / 1024); /* skipped amount in K */
< 	  int skipped_k_len = numdigit (skipped_k);
< 	  if (skipped_k_len < 5)
< 	    skipped_k_len = 5;
< 
< 	  /* Align the [ skipping ... ] line with the dots.  To do
< 	     that, insert the number of spaces equal to the number of
< 	     digits in the skipped amount in K.  */
< 	  logprintf (LOG_VERBOSE, _("\n%*s[ skipping %dK ]"),
< 		     2 + skipped_k_len, "", skipped_k);
< 	}
---
>         {
>           wgint skipped_k = skipped / 1024; /* skipped amount in K */
>           int skipped_k_len = numdigit (skipped_k);
>           if (skipped_k_len < 6)
>             skipped_k_len = 6;
> 
>           /* Align the [ skipping ... ] line with the dots.  To do
>              that, insert the number of spaces equal to the number of
>              digits in the skipped amount in K.  */
>           logprintf (LOG_VERBOSE, _("\n%*s[ skipping %sK ]"),
>                      2 + skipped_k_len, "",
>                      number_to_static_string (skipped_k));
>         }
247c248,249
<       logprintf (LOG_VERBOSE, "\n%5ldK", (long) (skipped / 1024));
---
>       logprintf (LOG_VERBOSE, "\n%6sK",
>                  number_to_static_string (skipped / 1024));
249,254c251,256
< 	{
< 	  if (dp->dots % opt.dot_spacing == 0)
< 	    logputs (LOG_VERBOSE, " ");
< 	  logputs (LOG_VERBOSE, ",");
< 	  ++dp->dots;
< 	}
---
>         {
>           if (dp->dots % opt.dot_spacing == 0)
>             logputs (LOG_VERBOSE, " ");
>           logputs (LOG_VERBOSE, ",");
>           ++dp->dots;
>         }
258c260
<       dp->rows = skipped / row_bytes;
---
>       dp->rows = skipped / ROW_BYTES;
264,269c266,274
< static void
< print_percentage (wgint bytes, wgint expected)
< {
<   int percentage = (int)(100.0 * bytes / expected);
<   logprintf (LOG_VERBOSE, "%3d%%", percentage);
< }
---
> static const char *eta_to_human_short (int, bool);
> 
> /* Prints the stats (percentage of completion, speed, ETA) for current
>    row.  DLTIME is the time spent downloading the data in current
>    row.
> 
>    #### This function is somewhat uglified by the fact that current
>    row and last row have somewhat different stats requirements.  It
>    might be worthwhile to split it to two different functions.  */
272c277
< print_download_speed (struct dot_progress *dp, wgint bytes, double dltime)
---
> print_row_stats (struct dot_progress *dp, double dltime, bool last)
274,276c279,341
<   logprintf (LOG_VERBOSE, " %s",
< 	     retr_rate (bytes, dltime - dp->last_timer_value, 1));
<   dp->last_timer_value = dltime;
---
>   const wgint ROW_BYTES = opt.dot_bytes * opt.dots_in_line;
> 
>   /* bytes_displayed is the number of bytes indicated to the user by
>      dots printed so far, includes the initially "skipped" amount */
>   wgint bytes_displayed = dp->rows * ROW_BYTES + dp->dots * opt.dot_bytes;
> 
>   if (last)
>     /* For last row also count bytes accumulated after last dot */
>     bytes_displayed += dp->accumulated;
> 
>   if (dp->total_length)
>     {
>       /* Round to floor value to provide gauge how much data *has*
>          been retrieved.  12.8% will round to 12% because the 13% mark
>          has not yet been reached.  100% is only shown when done.  */
>       int percentage = 100.0 * bytes_displayed / dp->total_length;
>       logprintf (LOG_VERBOSE, "%3d%%", percentage);
>     }
> 
>   {
>     static char names[] = {' ', 'K', 'M', 'G'};
>     int units;
>     double rate;
>     wgint bytes_this_row;
>     if (!last)
>       bytes_this_row = ROW_BYTES;
>     else
>       /* For last row also include bytes accumulated after last dot.  */
>       bytes_this_row = dp->dots * opt.dot_bytes + dp->accumulated;
>     /* Don't count the portion of the row belonging to initial_length */
>     if (dp->rows == dp->initial_length / ROW_BYTES)
>       bytes_this_row -= dp->initial_length % ROW_BYTES;
>     rate = calc_rate (bytes_this_row, dltime - dp->last_timer_value, &units);
>     logprintf (LOG_VERBOSE, " %4.*f%c",
>                rate >= 99.95 ? 0 : rate >= 9.995 ? 1 : 2,
>                rate, names[units]);
>     dp->last_timer_value = dltime;
>   }
> 
>   if (!last)
>     {
>       /* Display ETA based on average speed.  Inspired by Vladi
>          Belperchinov-Shabanski's "wget-new-percentage" patch.  */
>       if (dp->total_length)
>         {
>           wgint bytes_remaining = dp->total_length - bytes_displayed;
>           /* The quantity downloaded in this download run. */
>           wgint bytes_sofar = bytes_displayed - dp->initial_length;
>           double eta = dltime * bytes_remaining / bytes_sofar;
>           if (eta < INT_MAX - 1)
>             logprintf (LOG_VERBOSE, " %s",
>                        eta_to_human_short ((int) (eta + 0.5), true));
>         }
>     }
>   else
>     {
>       /* When done, print the total download time */
>       if (dltime >= 10)
>         logprintf (LOG_VERBOSE, "=%s",
>                    eta_to_human_short ((int) (dltime + 0.5), true));
>       else
>         logprintf (LOG_VERBOSE, "=%ss", print_decimal (dltime));
>     }
286c351
<   wgint row_bytes = opt.dot_bytes * opt.dots_in_line;
---
>   wgint ROW_BYTES = opt.dot_bytes * opt.dots_in_line;
288c353
<   log_set_flush (0);
---
>   log_set_flush (false);
294c359,360
< 	logprintf (LOG_VERBOSE, "\n%5ldK", (long) (dp->rows * row_bytes / 1024));
---
>         logprintf (LOG_VERBOSE, "\n%6sK",
>                    number_to_static_string (dp->rows * ROW_BYTES / 1024));
297c363
< 	logputs (LOG_VERBOSE, " ");
---
>         logputs (LOG_VERBOSE, " ");
302,305c368,370
< 	{
< 	  wgint row_qty = row_bytes;
< 	  if (dp->rows == dp->initial_length / row_bytes)
< 	    row_qty -= dp->initial_length % row_bytes;
---
>         {
>           ++dp->rows;
>           dp->dots = 0;
307,313c372,373
< 	  ++dp->rows;
< 	  dp->dots = 0;
< 
< 	  if (dp->total_length)
< 	    print_percentage (dp->rows * row_bytes, dp->total_length);
< 	  print_download_speed (dp, row_qty, dltime);
< 	}
---
>           print_row_stats (dp, dltime, false);
>         }
316c376
<   log_set_flush (1);
---
>   log_set_flush (true);
325,326c385
<   int dot_bytes = opt.dot_bytes;
<   wgint row_bytes = opt.dot_bytes * opt.dots_in_line;
---
>   wgint ROW_BYTES = opt.dot_bytes * opt.dots_in_line;
329c388
<   log_set_flush (0);
---
>   log_set_flush (false);
332c391,392
<     logprintf (LOG_VERBOSE, "\n%5ldK", (long) (dp->rows * row_bytes / 1024));
---
>     logprintf (LOG_VERBOSE, "\n%6sK",
>                number_to_static_string (dp->rows * ROW_BYTES / 1024));
336c396
< 	logputs (LOG_VERBOSE, " ");
---
>         logputs (LOG_VERBOSE, " ");
339,352d398
<   if (dp->total_length)
<     {
<       print_percentage (dp->rows * row_bytes
< 			+ dp->dots * dot_bytes
< 			+ dp->accumulated,
< 			dp->total_length);
<     }
< 
<   {
<     wgint row_qty = dp->dots * dot_bytes + dp->accumulated;
<     if (dp->rows == dp->initial_length / row_bytes)
<       row_qty -= dp->initial_length % row_bytes;
<     print_download_speed (dp, row_qty, dltime);
<   }
353a400
>   print_row_stats (dp, dltime, true);
355c402
<   log_set_flush (0);
---
>   log_set_flush (false);
378c425
< 	 line.  */
---
>          line.  */
386c433
< 	 (384K) in a line.  */
---
>          (384K) in a line.  */
394c441
< 	 64K, 8 dots in a cluster, 6 clusters (3M) in a line.  */
---
>          64K, 8 dots in a cluster, 6 clusters (3M) in a line.  */
402,403c449,450
< 	 each dot is 1M, 8 dots in a cluster, 4 clusters (32M) in a
< 	 line.  */
---
>          each dot is 1M, 8 dots in a cluster, 4 clusters (32M) in a
>          line.  */
410,411c457,458
< 	     _("Invalid dot style specification `%s'; leaving unchanged.\n"),
< 	     params);
---
>              _("Invalid dot style specification `%s'; leaving unchanged.\n"),
>              params);
438c485
< #define DLSPEED_SAMPLE_MIN 150
---
> #define DLSPEED_SAMPLE_MIN 0.15
443c490,498
< #define STALL_START_TIME 5000
---
> #define STALL_START_TIME 5
> 
> /* Time between screen refreshes will not be shorter than this, so
>    that Wget doesn't swamp the TTY with output.  */
> #define REFRESH_INTERVAL 0.2
> 
> /* Don't refresh the ETA too often to avoid jerkiness in predictions.
>    This allows ETA to change approximately once per second.  */
> #define ETA_REFRESH_INTERVAL 0.99
446,466c501,521
<   wgint initial_length;		/* how many bytes have been downloaded
< 				   previously. */
<   wgint total_length;		/* expected total byte count when the
< 				   download finishes */
<   wgint count;			/* bytes downloaded so far */
< 
<   double last_screen_update;	/* time of the last screen update,
< 				   measured since the beginning of
< 				   download. */
< 
<   int width;			/* screen width we're using at the
< 				   time the progress gauge was
< 				   created.  this is different from
< 				   the screen_width global variable in
< 				   that the latter can be changed by a
< 				   signal. */
<   char *buffer;			/* buffer where the bar "image" is
< 				   stored. */
<   int tick;			/* counter used for drawing the
< 				   progress bar where the total size
< 				   is not known. */
---
>   wgint initial_length;         /* how many bytes have been downloaded
>                                    previously. */
>   wgint total_length;           /* expected total byte count when the
>                                    download finishes */
>   wgint count;                  /* bytes downloaded so far */
> 
>   double last_screen_update;    /* time of the last screen update,
>                                    measured since the beginning of
>                                    download. */
> 
>   int width;                    /* screen width we're using at the
>                                    time the progress gauge was
>                                    created.  this is different from
>                                    the screen_width global variable in
>                                    that the latter can be changed by a
>                                    signal. */
>   char *buffer;                 /* buffer where the bar "image" is
>                                    stored. */
>   int tick;                     /* counter used for drawing the
>                                    progress bar where the total size
>                                    is not known. */
473c528
<     wgint times[DLSPEED_HISTORY_SIZE];
---
>     double times[DLSPEED_HISTORY_SIZE];
478c533
<     wgint total_time;
---
>     double total_time;
482,488c537,543
<   double recent_start;		/* timestamp of beginning of current
< 				   position. */
<   wgint recent_bytes;		/* bytes downloaded so far. */
< 
<   int stalled;			/* set when no data arrives for longer
< 				   than STALL_START_TIME, then reset
< 				   when new data arrives. */
---
>   double recent_start;          /* timestamp of beginning of current
>                                    position. */
>   wgint recent_bytes;           /* bytes downloaded so far. */
> 
>   bool stalled;                 /* set when no data arrives for longer
>                                    than STALL_START_TIME, then reset
>                                    when new data arrives. */
492,495c547,550
<   double last_eta_time;		/* time of the last update to download
< 				   speed and ETA, measured since the
< 				   beginning of download. */
<   wgint last_eta_value;
---
>   double last_eta_time;         /* time of the last update to download
>                                    speed and ETA, measured since the
>                                    beginning of download. */
>   int last_eta_value;
498,499c553,554
< static void create_image PARAMS ((struct bar_progress *, double));
< static void display_image PARAMS ((char *));
---
> static void create_image (struct bar_progress *, double, bool);
> static void display_image (char *);
520c575
< 	screen_width = DEFAULT_SCREEN_WIDTH;
---
>         screen_width = DEFAULT_SCREEN_WIDTH;
522c577
< 	screen_width = MINIMUM_SCREEN_WIDTH;
---
>         screen_width = MINIMUM_SCREEN_WIDTH;
528,529c583,585
<   /* + 1 for the terminating zero. */
<   bp->buffer = xmalloc (bp->width + 1);
---
>   /* + enough space for the terminating zero, and hopefully enough room
>    * for multibyte characters. */
>   bp->buffer = xmalloc (bp->width + 100);
533c589
<   create_image (bp, 0.0);
---
>   create_image (bp, 0, false);
539c595
< static void update_speed_ring PARAMS ((struct bar_progress *, wgint, double));
---
> static void update_speed_ring (struct bar_progress *, wgint, double);
545c601
<   int force_screen_update = 0;
---
>   bool force_screen_update = false;
566c622
< 	screen_width = DEFAULT_SCREEN_WIDTH;
---
>         screen_width = DEFAULT_SCREEN_WIDTH;
568c624
< 	screen_width = MINIMUM_SCREEN_WIDTH;
---
>         screen_width = MINIMUM_SCREEN_WIDTH;
570,574c626,630
< 	{
< 	  bp->width = screen_width - 1;
< 	  bp->buffer = xrealloc (bp->buffer, bp->width + 1);
< 	  force_screen_update = 1;
< 	}
---
>         {
>           bp->width = screen_width - 1;
>           bp->buffer = xrealloc (bp->buffer, bp->width + 100);
>           force_screen_update = true;
>         }
578c634
<   if (dltime - bp->last_screen_update < 200 && !force_screen_update)
---
>   if (dltime - bp->last_screen_update < REFRESH_INTERVAL && !force_screen_update)
582c638
<   create_image (bp, dltime);
---
>   create_image (bp, dltime, false);
597c653
<   create_image (bp, dltime);
---
>   create_image (bp, dltime, true);
642,644c698,700
< 	 i.e. not downloading anything for an extended period of time.
< 	 Since 0-reads do not enter the history ring, recent_age
< 	 effectively measures the time since last read.  */
---
>          i.e. not downloading anything for an extended period of time.
>          Since 0-reads do not enter the history ring, recent_age
>          effectively measures the time since last read.  */
646,653c702,709
< 	{
< 	  /* If we're stalling, reset the ring contents because it's
< 	     stale and because it will make bar_update stop printing
< 	     the (bogus) current bandwidth.  */
< 	  bp->stalled = 1;
< 	  xzero (*hist);
< 	  bp->recent_bytes = 0;
< 	}
---
>         {
>           /* If we're stalling, reset the ring contents because it's
>              stale and because it will make bar_update stop printing
>              the (bogus) current bandwidth.  */
>           bp->stalled = true;
>           xzero (*hist);
>           bp->recent_bytes = 0;
>         }
662c718
<       bp->stalled = 0;
---
>       bp->stalled = false;
664,668c720,724
< 	 could be very long.  Don't update the speed ring with that
< 	 value because the current bandwidth would start too small.
< 	 Start with an arbitrary (but more reasonable) time value and
< 	 let it level out.  */
<       recent_age = 1000;
---
>          could be very long.  Don't update the speed ring with that
>          value because the current bandwidth would start too small.
>          Start with an arbitrary (but more reasonable) time value and
>          let it level out.  */
>       recent_age = 1;
700,701c756,757
< 	sumt += hist->times[i];
< 	sumb += hist->bytes[i];
---
>         sumt += hist->times[i];
>         sumb += hist->bytes[i];
703d758
<     assert (sumt == hist->total_time);
704a760,766
>     /* We can't use assert(sumt==hist->total_time) because some
>        precision is lost by adding and subtracting floating-point
>        numbers.  But during a download this precision should not be
>        detectable, i.e. no larger than 1ns.  */
>     double diff = sumt - hist->total_time;
>     if (diff < 0) diff = -diff;
>     assert (diff < 1e-9);
709,711c771,840
< #define APPEND_LITERAL(s) do {			\
<   memcpy (p, s, sizeof (s) - 1);		\
<   p += sizeof (s) - 1;				\
---
> #if USE_NLS_PROGRESS_BAR
> int
> count_cols (const char *mbs)
> {
>   wchar_t wc;
>   int     bytes;
>   int     remaining = strlen(mbs);
>   int     cols = 0;
>   int     wccols;
> 
>   while (*mbs != '\0')
>     {
>       bytes = mbtowc (&wc, mbs, remaining);
>       assert (bytes != 0);  /* Only happens when *mbs == '\0' */
>       if (bytes == -1)
>         {
>           /* Invalid sequence. We'll just have to fudge it. */
>           return cols + remaining;
>         }
>       mbs += bytes;
>       remaining -= bytes;
>       wccols = wcwidth(wc);
>       cols += (wccols == -1? 1 : wccols);
>     }
>   return cols;
> }
> #else
> # define count_cols(mbs) ((int)(strlen(mbs)))
> #endif
> 
> const char *
> get_eta (int *bcd)
> {
>   /* Translation note: "ETA" is English-centric, but this must
>      be short, ideally 3 chars.  Abbreviate if necessary.  */
>   static const char eta_str[] = N_("  eta %s");
>   static const char *eta_trans;
>   static int bytes_cols_diff;
>   if (eta_trans == NULL)
>     {
>       int nbytes;
>       int ncols;
> 
> #if USE_NLS_PROGRESS_BAR
>       eta_trans = _(eta_str);
> #else
>       eta_trans = eta_str;
> #endif
> 
>       /* Determine the number of bytes used in the translated string,
>        * versus the number of columns used. This is to figure out how
>        * many spaces to add at the end to pad to the full line width.
>        *
>        * We'll store the difference between the number of bytes and
>        * number of columns, so that removing this from the string length
>        * will reveal the total number of columns in the progress bar. */
>       nbytes = strlen (eta_trans);
>       ncols = count_cols (eta_trans);
>       bytes_cols_diff = nbytes - ncols;
>     }
> 
>   if (bcd != NULL)
>     *bcd = bytes_cols_diff;
> 
>   return eta_trans;
> }
> 
> #define APPEND_LITERAL(s) do {                  \
>   memcpy (p, s, sizeof (s) - 1);                \
>   p += sizeof (s) - 1;                          \
713a843,847
> /* Use move_to_end (s) to get S to point the end of the string (the
>    terminating \0).  This is faster than s+=strlen(s), but some people
>    are confused when they see strchr (s, '\0') in the code.  */
> #define move_to_end(s) s = strchr (s, '\0');
> 
719c853
< create_image (struct bar_progress *bp, double dl_total_time)
---
> create_image (struct bar_progress *bp, double dl_total_time, bool done)
724,725c858,862
<   char *size_legible = with_thousand_seps (size);
<   int size_legible_len = strlen (size_legible);
---
>   const char *size_grouped = with_thousand_seps (size);
>   int size_grouped_len = count_cols (size_grouped);
>   /* Difference between num cols and num bytes: */
>   int size_grouped_diff = strlen (size_grouped) - size_grouped_len;
>   int size_grouped_pad; /* Used to pad the field width for size_grouped. */
730c867
<      xx% [=======>             ] nn,nnn 12.34K/s ETA 00:00
---
>      xx% [=======>             ] nn,nnn 12.34K/s  eta 36m 51s
742,743c879,880
<      " 1012.56K/s"     - dl rate                  - 11 chars
<      " ETA xx:xx:xx"   - ETA                      - 13 chars
---
>      " 12.5K/s"        - download rate             - 8 chars
>      "  eta 36m 51s"   - ETA                      - 14 chars
747,748c884,889
<   int dlbytes_size = 1 + MAX (size_legible_len, 11);
<   int progress_size = bp->width - (4 + 2 + dlbytes_size + 11 + 13);
---
>   int dlbytes_size = 1 + MAX (size_grouped_len, 11);
>   int progress_size = bp->width - (4 + 2 + dlbytes_size + 8 + 14);
> 
>   /* The difference between the number of bytes used,
>      and the number of columns used. */
>   int bytes_cols_diff = 0;
756,757c897
<       int percentage = (int)(100.0 * size / bp->total_length);
< 
---
>       int percentage = 100.0 * size / bp->total_length;
761c901
< 	sprintf (p, "%2d%% ", percentage);
---
>         sprintf (p, "%2d%% ", percentage);
763c903
< 	strcpy (p, "100%");
---
>         strcpy (p, "100%");
788c928
< 	 rest with '=' and one '>'.  */
---
>          rest with '=' and one '>'.  */
790c930
< 	*p++ = '+';
---
>         *p++ = '+';
793,797c933,937
< 	{
< 	  for (i = 0; i < dlsz - 1; i++)
< 	    *p++ = '=';
< 	  *p++ = '>';
< 	}
---
>         {
>           for (i = 0; i < dlsz - 1; i++)
>             *p++ = '=';
>           *p++ = '>';
>         }
800c940
< 	*p++ = ' ';
---
>         *p++ = ' ';
806c946
< 	 *something* to the user.  */
---
>          *something* to the user.  */
812c952
< 	pos = ind + 1;
---
>         pos = ind + 1;
814c954
< 	pos = progress_size - (ind - progress_size + 5);
---
>         pos = progress_size - (ind - progress_size + 5);
818,824c958,964
< 	{
< 	  if      (i == pos - 1) *p++ = '<';
< 	  else if (i == pos    ) *p++ = '=';
< 	  else if (i == pos + 1) *p++ = '>';
< 	  else
< 	    *p++ = ' ';
< 	}
---
>         {
>           if      (i == pos - 1) *p++ = '<';
>           else if (i == pos    ) *p++ = '=';
>           else if (i == pos + 1) *p++ = '>';
>           else
>             *p++ = ' ';
>         }
831,832c971,981
<   sprintf (p, " %-11s", with_thousand_seps (size));
<   p += strlen (p);
---
>   sprintf (p, " %s", size_grouped);
>   move_to_end (p);
>   /* Pad with spaces to 11 chars for the size_grouped field;
>    * couldn't use the field width specifier in sprintf, because
>    * it counts in bytes, not characters. */
>   for (size_grouped_pad = 11 - size_grouped_len;
>        size_grouped_pad > 0;
>        --size_grouped_pad)
>     {
>       *p++ = ' ';
>     }
834,835c983,984
<   /* " 1012.45K/s" */
<   if (hist->total_time && hist->total_bytes)
---
>   /* " 12.52K/s" */
>   if (hist->total_time > 0 && hist->total_bytes)
840c989
< 	 recent data that hasn't made it to the ring yet.  */
---
>          recent data that hasn't made it to the ring yet.  */
844,845c993,995
<       sprintf (p, " %7.2f%s", dlspeed, short_units[units]);
<       p += strlen (p);
---
>       sprintf (p, " %4.*f%s", dlspeed >= 99.95 ? 0 : dlspeed >= 9.995 ? 1 : 2,
>                dlspeed, short_units[units]);
>       move_to_end (p);
848c998
<     APPEND_LITERAL ("   --.--K/s");
---
>     APPEND_LITERAL (" --.-K/s");
850,900c1000,1041
<   /* " ETA xx:xx:xx"; wait for three seconds before displaying the ETA.
<      That's because the ETA value needs a while to become
<      reliable.  */
<   if (bp->total_length > 0 && bp->count > 0 && dl_total_time > 3000)
<     {
<       wgint eta;
<       int eta_hrs, eta_min, eta_sec;
< 
<       /* Don't change the value of ETA more than approximately once
< 	 per second; doing so would cause flashing without providing
< 	 any value to the user. */
<       if (bp->total_length != size
< 	  && bp->last_eta_value != 0
< 	  && dl_total_time - bp->last_eta_time < 900)
< 	eta = bp->last_eta_value;
<       else
< 	{
< 	  /* Calculate ETA using the average download speed to predict
< 	     the future speed.  If you want to use a speed averaged
< 	     over a more recent period, replace dl_total_time with
< 	     hist->total_time and bp->count with hist->total_bytes.
< 	     I found that doing that results in a very jerky and
< 	     ultimately unreliable ETA.  */
< 	  double time_sofar = (double)dl_total_time / 1000;
< 	  wgint bytes_remaining = bp->total_length - size;
< 	  eta = (wgint) (time_sofar * bytes_remaining / bp->count);
< 	  bp->last_eta_value = eta;
< 	  bp->last_eta_time = dl_total_time;
< 	}
< 
<       eta_hrs = eta / 3600, eta %= 3600;
<       eta_min = eta / 60,   eta %= 60;
<       eta_sec = eta;
< 
<       if (eta_hrs > 99)
< 	goto no_eta;
< 
<       if (eta_hrs == 0)
< 	{
< 	  /* Hours not printed: pad with three spaces. */
< 	  APPEND_LITERAL ("   ");
< 	  sprintf (p, " ETA %02d:%02d", eta_min, eta_sec);
< 	}
<       else
< 	{
< 	  if (eta_hrs < 10)
< 	    /* Hours printed with one digit: pad with one space. */
< 	    *p++ = ' ';
< 	  sprintf (p, " ETA %d:%02d:%02d", eta_hrs, eta_min, eta_sec);
< 	}
<       p += strlen (p);
---
>   if (!done)
>     {
>       /* "  eta ..m ..s"; wait for three seconds before displaying the ETA.
>          That's because the ETA value needs a while to become
>          reliable.  */
>       if (bp->total_length > 0 && bp->count > 0 && dl_total_time > 3)
>         {
>           int eta;
> 
>           /* Don't change the value of ETA more than approximately once
>              per second; doing so would cause flashing without providing
>              any value to the user. */
>           if (bp->total_length != size
>               && bp->last_eta_value != 0
>               && dl_total_time - bp->last_eta_time < ETA_REFRESH_INTERVAL)
>             eta = bp->last_eta_value;
>           else
>             {
>               /* Calculate ETA using the average download speed to predict
>                  the future speed.  If you want to use a speed averaged
>                  over a more recent period, replace dl_total_time with
>                  hist->total_time and bp->count with hist->total_bytes.
>                  I found that doing that results in a very jerky and
>                  ultimately unreliable ETA.  */
>               wgint bytes_remaining = bp->total_length - size;
>               double eta_ = dl_total_time * bytes_remaining / bp->count;
>               if (eta_ >= INT_MAX - 1)
>                 goto skip_eta;
>               eta = (int) (eta_ + 0.5);
>               bp->last_eta_value = eta;
>               bp->last_eta_time = dl_total_time;
>             }
> 
>           sprintf (p, get_eta(&bytes_cols_diff),
>                    eta_to_human_short (eta, false));
>           move_to_end (p);
>         }
>       else if (bp->total_length > 0)
>         {
>         skip_eta:
>           APPEND_LITERAL ("             ");
>         }
902c1043
<   else if (bp->total_length > 0)
---
>   else
904,905c1045,1060
<     no_eta:
<       APPEND_LITERAL ("             ");
---
>       /* When the download is done, print the elapsed time.  */
>       int nbytes;
>       int ncols;
> 
>       /* Note to translators: this should not take up more room than
>          available here.  Abbreviate if necessary.  */
>       strcpy (p, _("   in "));
>       nbytes = strlen (p);
>       ncols  = count_cols (p);
>       bytes_cols_diff = nbytes - ncols;
>       p += nbytes;
>       if (dl_total_time >= 10)
>         strcpy (p, eta_to_human_short ((int) (dl_total_time + 0.5), false));
>       else
>         sprintf (p, "%ss", print_decimal (dl_total_time));
>       move_to_end (p);
908,910c1063
<   assert (p - bp->buffer <= bp->width);
< 
<   while (p < bp->buffer + bp->width)
---
>   while (p - bp->buffer - bytes_cols_diff - size_grouped_diff < bp->width)
921c1074
<   int old = log_set_save_context (0);
---
>   bool old = log_set_save_context (false);
939,940c1092,1093
< 	  TTY -- when logging to file, it is better to review the
< 	  dots.  */
---
>           TTY -- when logging to file, it is better to review the
>           dots.  */
944,947c1097,1100
< 	  progress bar only uses ^M to move the cursor to the
< 	  beginning of line, which works even on dumb terminals.  But
< 	  Jamie Zawinski reports that ^M and ^H tricks don't work in
< 	  Emacs shell buffers, and only make a mess.  */
---
>           progress bar only uses ^M to move the cursor to the
>           beginning of line, which works even on dumb terminals.  But
>           Jamie Zawinski reports that ^M and ^H tricks don't work in
>           Emacs shell buffers, and only make a mess.  */
953,956c1106,1109
< 	 display.  #### We're recursively calling
< 	 set_progress_implementation here, which is slightly kludgy.
< 	 It would be nicer if we provided that function a return value
< 	 indicating a failure of some sort.  */
---
>          display.  #### We're recursively calling
>          set_progress_implementation here, which is slightly kludgy.
>          It would be nicer if we provided that function a return value
>          indicating a failure of some sort.  */
963c1116
< RETSIGTYPE
---
> void
969a1123,1167
> 
> /* Provide a short human-readable rendition of the ETA.  This is like
>    secs_to_human_time in main.c, except the output doesn't include
>    fractions (which would look silly in by nature imprecise ETA) and
>    takes less room.  If the time is measured in hours, hours and
>    minutes (but not seconds) are shown; if measured in days, then days
>    and hours are shown.  This ensures brevity while still displaying
>    as much as possible.
> 
>    If CONDENSED is true, the separator between minutes and seconds
>    (and hours and minutes, etc.) is not included, shortening the
>    display by one additional character.  This is used for dot
>    progress.
> 
>    The display never occupies more than 7 characters of screen
>    space.  */
> 
> static const char *
> eta_to_human_short (int secs, bool condensed)
> {
>   static char buf[10];          /* 8 should be enough, but just in case */
>   static int last = -1;
>   const char *space = condensed ? "" : " ";
> 
>   /* Trivial optimization.  create_image can call us every 200 msecs
>      (see bar_update) for fast downloads, but ETA will only change
>      once per 900 msecs.  */
>   if (secs == last)
>     return buf;
>   last = secs;
> 
>   if (secs < 100)
>     sprintf (buf, "%ds", secs);
>   else if (secs < 100 * 60)
>     sprintf (buf, "%dm%s%ds", secs / 60, space, secs % 60);
>   else if (secs < 48 * 3600)
>     sprintf (buf, "%dh%s%dm", secs / 3600, space, (secs / 60) % 60);
>   else if (secs < 100 * 86400)
>     sprintf (buf, "%dd%s%dh", secs / 86400, space, (secs / 3600) % 60);
>   else
>     /* even (2^31-1)/86400 doesn't overflow BUF. */
>     sprintf (buf, "%dd", secs / 86400);
> 
>   return buf;
> }
